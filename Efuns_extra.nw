\section{[[core/]]}

\subsection*{[[core/efuns.ml]]}

<<exception Efuns.UnboundKey>>=
exception UnboundKey
@

<<type Efuns.map>>=
type map =
  { char_map : binding array;
    mutable complex_bindings : (key * binding) list;
    mutable interactives : (string * (action * prefix option)) list;
  } 
@

<<type Efuns.key>>=
and key = mod_ident * Xtypes.keySym
@

<<type Efuns.action>>=
and action = frame -> unit
@

<<type Efuns.generic_action>>=
and generic_action =
  BufferAction of (buffer -> unit)
| FrameAction of (frame -> unit)
@

<<type Efuns.mod_ident>>=
and mod_ident = 
  NormalMap
| ControlMap
| MetaMap
| ControlMetaMap
@

<<type Efuns.prefix>>=
and prefix = key list
@

<<type Efuns.binding>>=
and binding = 
  Function of action
| Prefix of map
| Unbound
@

<<type Efuns.buffer>>=
and buffer =
  { 
    mutable buf_text : Text.t;
    mutable buf_modified : int;
    
    mutable buf_name : string;
    mutable buf_filename : string option;
    mutable buf_last_saved : int;
    
    mutable buf_history : (int * Text.action) list;
    
    mutable buf_charreprs : string array;
    mutable buf_syntax_table : bool array;
    
    mutable buf_map_partial : bool;
    buf_map : map;
    
    mutable buf_sync : bool;
    mutable buf_mark : Text.point option;
    mutable buf_point : Text.point;
    mutable buf_start : Text.point;
    mutable buf_shared : int; (* number of frames for that buffer *)
    mutable buf_minor_modes : minor_mode list;
    mutable buf_major_mode : major_mode;
    mutable buf_finalizers : (unit -> unit) list;
    
    mutable buf_vars : vars;
    buf_location : location;
  } 
@

<<type Efuns.major_mode>>=
and major_mode = {
    maj_name : string;
    maj_map : map;
    mutable maj_hooks : (buffer -> unit) list;
    mutable maj_vars : vars;
  }
@

<<type Efuns.minor_mode>>=
and minor_mode = {
    min_name : string;
    min_map : map;
    mutable min_hooks : (buffer -> unit) list;
    mutable min_vars : vars;
  }
@

<<type Efuns.frame>>=
and frame  =
  {
    mutable frm_buffer : buffer;
    mutable frm_location : location;
    mutable frm_window : window;
    mutable frm_last_text_updated : int;
    mutable frm_last_buf_updated : int;
    
    mutable frm_prefix : key list;
    
    mutable frm_repeat_action : int;
    mutable frm_last_action : action;
    
    mutable frm_start : Text.point;(* first point of the first buffer-line on screen *)
    mutable frm_end : Text.point; (* last point on screen, -1 if modified *)
    mutable frm_y_offset : int; (* offset(+/-) of screen-lines after frm_start *)
    mutable frm_point : Text.point; (* insert point *)
    
    mutable frm_cursor_x : int;
    mutable frm_cursor_y : int;
    mutable frm_cursor : string;
    mutable frm_cursor_attr : Text.attribute;
    
    mutable frm_force_point : bool;
    mutable frm_force_start : bool;
    mutable frm_force_cursor : bool;
    
    mutable frm_x_offset : int;
    mutable frm_cutline : int; (* max_int for no, else length *)
    
    mutable frm_has_scrollbar : int;(* 0 for no scrollbar, 2 for scrollbar *)
    mutable frm_has_status_line : int;(* 0 for minibuffer, 1 for normal frame *)
    mutable frm_status : status;    
    
    mutable frm_xpos : int;
    mutable frm_ypos : int;
    mutable frm_width : int;
    mutable frm_height : int;
    
    mutable frm_table : line_repr array;
    mutable frm_killed : bool;
    mutable frm_mini_buffer : string option;
    mutable frm_redraw : bool;    
  } 
@

<<type Efuns.status_info>>=
and status_info =
  StatModified
| StatName
| StatLine
| StatCol
| StatFile
| StatMode
@

<<type Efuns.status>>=
and status =
  { mutable status_string : string;
    mutable status_modified : bool;
    mutable status_format : (status_info * (int * int)) list;
    mutable stat_col : int;
    mutable stat_name : string;
    mutable stat_file : string;
    mutable stat_line : int;
    mutable stat_modified : bool;
    mutable stat_modes : minor_mode list;
    mutable stat_mode : major_mode;
  }
@

<<type Efuns.line_repr>>=
and line_repr =
  { 
    mutable repr_line : Text.line;
    mutable repr_y : int;
    mutable repr_x : int;
    mutable repr_prev_offset : int;
    mutable repr_prev_reprs : Text.repr list;
    mutable repr_offset : int;
    mutable repr_reprs : Text.repr list;
  } 
@

<<type Efuns.top_window>>=
and top_window = 
  { mutable top_location : location;
    mutable top_display : WX_xterm.xterm_display option;
    mutable top_xterm : WX_xterm.xterm_window option;
    mutable top_term : WX_xterm.t;
    top_attrs : WX_xterm.xterm_gc option array;
    mutable top_windows : window;
    mutable top_mini_buffers : frame list;
    mutable top_width : int;
    mutable top_height : int;
    mutable top_name : string;
    mutable top_active_frame : frame;
    mutable top_second_cursor : frame option;
    mutable top_root : WX_root.t;
    mutable top_appli : WX_appli.t;
    mutable top_scrollbar : WX_adjust.t;
  } 
@

<<type Efuns.window>>=
and window =
  { 
    mutable win_xpos : int;
    mutable win_ypos : int;
    mutable win_width : int;
    mutable win_height : int;
    mutable win_down : window_down;
    mutable win_up : window_up;
    mutable win_mini : bool;
  } 
@

<<type Efuns.window_up>>=
and window_up =
  Window of window
| TopWindow of top_window
@

<<type Efuns.window_down>>=
and window_down =
| HComb of window * window 
| VComb of window * window
| NoFrame of unit
| WFrame of frame
@

<<type Efuns.location>>=
and location =
  { 
    loc_map : map;
    mutable loc_windows : top_window list;
    mutable loc_buffers : (string, buffer) Hashtbl.t;
    mutable loc_files : (string, buffer) Hashtbl.t;
    mutable loc_dirname : string;
    mutable loc_width : int;
    mutable loc_height : int;
    mutable loc_fg : string;
    mutable loc_bg : string;
    mutable loc_font : string;
    loc_vars : vars;
    mutable loc_counter : int;
(*    
    loc_vars_table : (string, (Obj.t -> string) * (string -> Obj.t)) Hashtbl.t;
  *)  
    loc_fonts : (string,int) Hashtbl.t;
    loc_fonts_names : string array;
    mutable loc_fonts_n : int;
    loc_colors : (string,int) Hashtbl.t;
    loc_colors_names : string array;
    mutable loc_colors_n : int;
    
    loc_mutex : Concur.Mutex.t;
  } 
@

<<type Efuns.sens>>=
type sens = 
  Backward | 
  Forward
@

<<type Efuns.to_regexp>>=
type to_regexp =
  Regexp
| RegexpString
@

<<constant Efuns.start_hooks>>=
(* Les hooks de lancement apres le chargement d'un module *)

let start_hooks = ref []
@

<<function Efuns.add_start_hook>>=
let add_start_hook hook = start_hooks := hook :: !start_hooks
@

<<function Efuns.init>>=
let init (location : location) =
  let rec iter hooks =
    match hooks with
      [] -> ()
    | (f : location -> unit) :: hooks -> 
        f location;
        iter hooks
  in
  let hooks = List.rev !start_hooks in
  start_hooks := [];
  iter hooks
@

<<function Efuns.set_global>>=
let set_global location var value = Local.set location.loc_vars var value
@

<<function Efuns.set_local>>=
let set_local buf var value = Local.set buf.buf_vars var value
@

<<function Efuns.get_var>>=
let get_var buf var = 
  try Local.get buf.buf_vars var with Not_found ->
      try
        Local.get buf.buf_major_mode.maj_vars var with
        Not_found ->
          let rec iter list =
            match list with
              [] -> Local.get buf.buf_location.loc_vars var
            | min :: list -> 
                try
                  Local.get min.min_vars var
                with _ -> iter list
          in
          iter buf.buf_minor_modes
@

<<function Efuns.get_global>>=
let get_global location var = Local.get location.loc_vars var
@

<<function Efuns.get_local>>=
let get_local buf var = Local.get buf.buf_vars var
@

<<function Efuns.set_minor_var>>=
let set_minor_var min var value = Local.set min.min_vars var value
@

<<function Efuns.set_major_var>>=
let set_major_var maj var value = Local.set maj.maj_vars var value
@

<<function Efuns.exec_hooks>>=
let rec exec_hooks hooks arg =
  match hooks with
    [] -> ()
  | f :: hooks -> 
      (try f arg with _ -> ());
      exec_hooks hooks arg
@

<<function Efuns.add_hook>>=
let add_hook location hook_var hook =
  let tail = try
      get_global location hook_var
    with _ -> [] in
  set_global location hook_var (hook :: tail)
@

<<constant Efuns.load_path>>=
let load_path = define_option ["efuns_path"] 
  "<load_path> is the path where modules (.cmo and .cma) can be found
  for dynamic linking." path_option []
@

<<constant Efuns.path>>=
let path = Dyneval.load_path
@

<<constant Efuns.efuns_path>>=
let efuns_path = [ 
      (Filename.concat homedir ".efuns") ;
      Version.efuns_lib ; 
      Version.installdir; 
      Version.ocamllib]
@

<<toplevel Efuns._1>>=
let _ = 
  path := !!load_path @ efuns_path;
  option_hook load_path (fun _ -> path := !!load_path @ efuns_path)
@

<<constant Efuns.init_files>>=
let init_files = ref []
@

<<constant Efuns.init_frames>>=
let init_frames = ref []
@

<<constant Efuns.displayname>>=
let displayname = ref ""
@

<<constant Efuns.height>>=
let height = ref 27
@

<<constant Efuns.no_init>>=
let no_init = ref false
@

<<constant Efuns.xdefaults>>=
(*--------------------    Ressources *)

let xdefaults = try Sys.getenv "XUSERFILESEARCHPATH" with
    Not_found -> Filename.concat Utils.homedir ".Xdefaults"
@

<<constant Efuns.resname>>=
let resname = ["Efuns";"efuns"]
@

<<constant Efuns.x_res>>=
let x_res = Xrm.create ()
@

<<toplevel Efuns._2>>=
let _ =
  begin    
    try
      let efuns_res = 
        let path = try Utils.string_to_path (Sys.getenv "XFILESEARCHPATH") with _ -> 
              [] in
        let xenv = try Sys.getenv "XENVIRONMENT" with _ -> "" in
        let xroot = try Filename.concat  (Sys.getenv "X11ROOT")
            "lib/X11/app-defaults/" with _ -> "" in
        Utils.find_in_path (path@[
            xenv; xroot; "/usr/X11/lib/X11/app-defaults/"]) "Efuns"
      in
      Xrm.safe_load x_res efuns_res
    with _ -> ()
  end;
  Xrm.safe_load x_res xdefaults
@

<<constant Efuns.t>>=
let t = x_res
@

<<constant Efuns.width_opt>>=
(*--------------------    Arguments *)

let width_opt = ref None
@

<<constant Efuns.height_opt>>=
let height_opt = ref None
@

<<constant Efuns.font_opt>>=
let font_opt = ref None
@

<<constant Efuns.fg_opt>>=
let fg_opt = ref None
@

<<constant Efuns.bg_opt>>=
let bg_opt = ref None
@

<<constant Efuns.check>>=
let check = ref false
@

<<toplevel Efuns._3>>=
  let _ =
  Arg.parse [
    "-d", Arg.String(fun s -> displayname :=s),"<dpy>: Name of display";
    "--display", Arg.String(fun s -> displayname :=s),"<dpy>: Name of display";
    "-fg", Arg.String(fun s -> fg_opt :=Some s), "<color>: Foreground color";
    "-bg", Arg.String(fun s -> bg_opt :=Some s), "<color>: Background color";
    "-font", Arg.String(fun s -> font_opt :=Some s), "<font>: Font name";
    "-check", Arg.Set check, ": only for testing";
    "-width", Arg.Int (fun i -> width_opt := Some i), "<len>: Width in chars";
    "-height", Arg.Int (fun i -> height_opt := Some i), "<len>: Height in chars";
    "-q", Arg.Set no_init,": Don't load init files";
    "-I",Arg.String (fun s -> load_path =:= 
        (string_to_path s) @ !!load_path), "<path>: Load Path";
    "-c", Arg.String Dyneval.compile,"<file.ml>: compile file";
    "-frame", Arg.String (fun s -> init_frames := s:: !init_frames), "<file>: open a frame with <file>";
  ] (fun name -> init_files := name :: !init_files) 
  "A small editor entirely written in Objective Caml 
@

<<toplevel Efuns._4>>=
let _ =
  Options.filename := 
  (try Utils.find_in_path (Utils.homedir :: !!load_path) ".efunsrc" with
      _ -> Filename.concat Utils.homedir ".efunsrc");
  (try Options.init () with _ -> ())
@

<<constant Efuns.width>>=
let width = define_option ["width"] "" int_option 80
@

<<constant Efuns.height (core/efuns.ml)>>=
let height = define_option ["height"] "" int_option 25
@

<<constant Efuns.font>>=
let font = define_option ["font"] "" string_option "fixed"
@

<<constant Efuns.foreground>>=
let foreground = define_option ["foreground"] "" string_option "white"
@

<<constant Efuns.background>>=
let background = define_option ["background"] "" string_option "black"
@

<<toplevel Efuns._5>>=
let _ =
  (match !fg_opt with None -> () | Some color -> foreground =:= color);
  (match !bg_opt with None -> () | Some color -> background =:= color);
  (match !font_opt with None -> () | Some color -> font =:= color);
  (match !width_opt with None -> () | Some color -> width =:= color);
  (match !height_opt with None -> () | Some color -> height =:= color)  
@

<<function Efuns.define_action>>=
let define_action action_name action_fun =
  (try ignore (Hashtbl.find actions action_name);
      Printf.printf "Warning: action \"%s\" defined twice" action_name;
      print_newline ();
    with _ -> ());
  Hashtbl.add actions action_name (FrameAction action_fun)
@

<<function Efuns.define_buffer_action>>=
let define_buffer_action action_name action_fun =
  (try ignore (Hashtbl.find actions action_name);
      Printf.printf "Warning: action \"%s\" defined twice" action_name;
      print_newline ();
    with _ -> ());
  Hashtbl.add actions action_name (BufferAction action_fun)
@

<<constant Efuns.no_action>>=
let no_action = BufferAction (fun _ -> ())
@

<<function Efuns.get_action>>=
let get_action action =
  try Hashtbl.find actions action with Not_found -> no_action
@

<<function Efuns.execute_action>>=
let execute_action action frame = 
  match (get_action action) with
    BufferAction f -> f frame.frm_buffer
  | FrameAction f -> f frame 
@

<<function Efuns.execute_buffer_action>>=
let execute_buffer_action action buf =
  match (get_action action) with
    BufferAction f -> f buf
  | FrameAction f -> 
      Printf.printf "Can't apply action %s on buffer" action;
      print_newline ()
@

<<function Efuns.string_to_regex>>=
let string_to_regex s = s, Str.regexp s
@

<<constant Efuns.regexp_option>>=
let regexp_option = define_option_class "Regexp" 
    (fun v -> match v with
        Value s ->  string_to_regex s | _ -> raise Not_found)
  (fun (s,r) -> Value s)
@


%-------------------------------------------------------------

<<core/efuns.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

(* Useful types for Efuns *)

(*************************************************************************)
               (*      Types      *)
(*************************************************************************)

open Utils
open Obj
open Local
  
<<exception Efuns.UnboundKey>>

<<type Efuns.map>>

<<type Efuns.key>>

<<type Efuns.action>>

<<type Efuns.generic_action>>

<<type Efuns.mod_ident>>

<<type Efuns.prefix>>

<<type Efuns.binding>>

(* a buffer containing a file in Text.t *)
<<type Efuns.buffer>>

<<type Efuns.major_mode>>

<<type Efuns.minor_mode>>
  
(* a frame: a view of a buffer for a window *)
<<type Efuns.frame>>

<<type Efuns.status_info>>

<<type Efuns.status>>

<<type Efuns.line_repr>>

(* an xterm: a window containing some frames *)
<<type Efuns.top_window>>

<<type Efuns.window>>

<<type Efuns.window_up>>

<<type Efuns.window_down>>

<<type Efuns.location>>

<<type Efuns.sens>>
<<type Efuns.to_regexp>>

(*************************************************************************)
               (*      Values      *)
(*************************************************************************)

<<constant Efuns.start_hooks>>
<<function Efuns.add_start_hook>>

<<function Efuns.init>>

  (* Les variables locales *)
  
<<function Efuns.set_global>>
<<function Efuns.set_local>>
<<function Efuns.get_var>>
          
<<function Efuns.get_global>>
<<function Efuns.get_local>>
  
<<function Efuns.set_minor_var>>
<<function Efuns.set_major_var>>
  
<<function Efuns.exec_hooks>>

<<function Efuns.add_hook>>
  
(*************************************************************************)
               (*      Initialization      *)
(*************************************************************************)

  
(* Les variables importantes dans le reste du programme. *)
open Options
  
  
<<constant Efuns.load_path>>

<<constant Efuns.path>>
  
<<constant Efuns.efuns_path>>
  
<<toplevel Efuns._1>>

<<constant Efuns.init_files>>
<<constant Efuns.init_frames>>
<<constant Efuns.displayname>>
<<constant Efuns.height>>
<<constant Efuns.no_init>>
  
<<constant Efuns.xdefaults>>

<<constant Efuns.resname>>

<<constant Efuns.x_res>>
<<toplevel Efuns._2>>
  
<<constant Efuns.t>>
  (*
  let _ = Printf.printf "%d %d %s %s %s" !width !height !font !fg !bg; 
  print_newline () 
*)
  
<<constant Efuns.width_opt>>
<<constant Efuns.height_opt>>
<<constant Efuns.font_opt>>
<<constant Efuns.fg_opt>>
<<constant Efuns.bg_opt>>
<<constant Efuns.check>>
  
<<toplevel Efuns._3>>
by Fabrice LE FESSANT, INRIA Rocquencourt, FRANCE
  http ://pauillac.inria.fr/efuns

Options :
  " 
  
<<toplevel Efuns._4>>

open Options
  
<<constant Efuns.width>>
<<constant Efuns.height (core/efuns.ml)>>
<<constant Efuns.font>>
<<constant Efuns.foreground>>
<<constant Efuns.background>>
  
<<toplevel Efuns._5>>
    
let (actions : (string, generic_action) Hashtbl.t) = Hashtbl.create 63

<<function Efuns.define_action>>

<<function Efuns.define_buffer_action>>

<<constant Efuns.no_action>>
<<function Efuns.get_action>>

<<function Efuns.execute_action>>

<<function Efuns.execute_buffer_action>>
      
      
<<function Efuns.string_to_regex>>
    
<<constant Efuns.regexp_option>>
@


\subsection*{[[core/text.ml]]}

<<type Text.attribute>>=
type attribute = int
@

<<type Text.delta>>=
type delta = int
@

<<type Text.position>>=
type position = int
@

<<type Text.direct>>=
type direct = int
@

<<type Text.session>>=
type session = int
@

<<type Text.line>>=
and line = {
    mutable position : direct;
    mutable representation : repr list;
    mutable modified : int; (* first modified position *)
    mutable repr_len : int;
    mutable repr_string : string;
    mutable line_hlt : int;
    (* hightlighting on the line:
    0 => no hightlighting
    n => chars are hightlighted from the beginning of the line until pos n
    *)
    mutable items : item array;
  } 
@

<<type Text.point>>=
and point = {
    mutable point : int;
    mutable point_y : int;
  }
@

<<type Text.repr>>=
and repr = 
  { 
    repr_line_pos : int;   (* pos of repr in Text.t string *)
    repr_line_len : int;   (* len of repr in Text.t string *)
    
    mutable repr_attr : int;    (* common attribute *)
    repr_charsize : int; (* common size *)
    
    repr_size : int;
    repr_pos : int;  (* pos of repr in representation string *)
  } 
@

<<type Text.text>>=
type text = {
    mutable text_string : string;
    mutable text_attrs : int array;
    mutable text_size : int;
    
    mutable text_points : point list;
    
    mutable text_gpoint : int;
    mutable text_gline : int;
    mutable text_gsize : int;
    
    mutable text_newlines : line array;
    mutable text_nlines : int;
    
    mutable text_modified : int;
    mutable text_clean : bool;
    
    mutable text_readonly : bool;
    mutable text_history : action list;
  } 
@

<<type Text.action>>=
and  action =
  Insertion of int * int * int
| Deletion of int * string * int
| Session of action list
@

<<type Text.t>>=
type t = tree tree_desc  
@

<<function Text.version>>=
(*
let print msg text =
  let s = text.text_string in
  let gpoint = text.text_gpoint in
  let gsize  = text.text_gsize in
  let len = text.text_size in
  let gap_end = gpoint + gsize in
    Printf.printf "%s: <<%s[gap:%d]%s>>" msg (String.sub s 0 gpoint) gsize 
      (String.sub s gap_end (len - gap_end));
    print_newline ()
 
let print_newlines text =
  print_string "Newlines :";
  for i = 0 to text.text_nlines - 1 do
    Printf.printf " %d" text.text_newlines.(i).position;
  done;
  print_newline ()
*)

let version tree = 
    let text = tree.tree_text in    
  text.text_modified
@

<<function Text.nbre_lines>>=
let nbre_lines tree = 
  let text = tree.tree_text in    
  text.text_nlines - 2
@

<<function Text.size>>=
let size tree = 
  let text = tree.tree_text in    
  text.text_size - text.text_gsize
@

<<function Text.point_col>>=
let point_col tree point = 
  let text = tree.tree_text in    
  let gpoint = text.text_gpoint in
  let bol = text.text_newlines.(point.point_y).position in
  let point = point.point in
  if point > gpoint && bol <= gpoint then
    point - bol - text.text_gsize
  else
    point - bol
@

<<function Text.make_attr>>=
let make_attr fg bg font highlighted =
  let attr = fg + (bg lsl 8) + (font lsl 16) + 
      (if highlighted then 1 lsl 24 else 0) 
  in
  attr
@

<<constant Text.direct_attr>>=
let direct_attr =  make_attr 0 1 0 false
@

<<constant Text.inverse_attr>>=
let inverse_attr =  make_attr 1 0 0 false
@

<<function Text.move_gpoint_to>>=
let move_gpoint_to text point =
  let gpoint = text.text_gpoint in
  let gsize = text.text_gsize in
  let gline = text.text_gline in
  text.text_clean <- false;
  if point <> gpoint then 
    let gap_end = gpoint + gsize in
    if point < gpoint then
      let delta = gpoint - point in
      let (delta_line,_) = count_char_sub text.text_string
          point delta '\n' in
      String.blit text.text_string point 
        text.text_string (point + gsize) delta;
      Array.blit text.text_attrs point 
        text.text_attrs (point + gsize) delta;
      for i = gline - delta_line + 1 to gline do
        text.text_newlines.(i).position
          <- text.text_newlines.(i).position + gsize 
      done;
      List.iter (fun p -> 
          if p.point > point && p.point <= gpoint then
            p.point <- p.point + gsize
      ) text.text_points;
      text.text_gpoint <- point;
      text.text_gline <- gline - delta_line;
    else
    let delta = point - gap_end in
    let (delta_line,_) = 
      count_char_sub text.text_string gap_end delta '\n' in
    String.blit text.text_string gap_end text.text_string gpoint delta;
    Array.blit text.text_attrs gap_end text.text_attrs gpoint delta;
    for i = gline + 1 to gline + delta_line do
      text.text_newlines.(i).position
        <- text.text_newlines.(i).position - gsize
    done;
    List.iter (fun p -> 
        if p.point >= gap_end && p.point <= point then
          p.point <- p.point - gsize
    ) text.text_points;
    text.text_gpoint <- point - gsize;
    text.text_gline <- gline + delta_line
@

<<function Text.cancel_repr>>=
let cancel_repr text point n =
  let line = text.text_newlines.(n) in
  let pos =  point - line.position in
  line.modified <- 
    (if line.modified < 0 then pos
    else min line.modified pos)
@

<<constant Text.add_amount>>=
let add_amount = define_option ["add_amount"] "Size of the gap in the buffer"
  int_option 200
@

<<function Text.extend_gap>>=
let extend_gap text amount =
  let add_size = max !!add_amount 
      ((amount / !!add_amount) * !!add_amount + !!add_amount) in
  let old_size = text.text_size in
(* use String.create here *)
  let new_text = String.create (old_size + add_size) in
  let new_attrs = Array.create (old_size + add_size) direct_attr in
  let gpoint = text.text_gpoint in
  let gsize = text.text_gsize in
  let gap_end = gpoint + gsize in
  String.blit text.text_string 0 new_text 0 gpoint; 
  Array.blit text.text_attrs 0 new_attrs 0 gpoint; 
  String.blit text.text_string gap_end
    new_text (gap_end + add_size) 
  (old_size - gap_end);
  Array.blit text.text_attrs gap_end
    new_attrs (gap_end + add_size) 
  (old_size - gap_end);
  for i = text.text_gline + 1 to text.text_nlines - 1 do
    text.text_newlines.(i).position <- 
      text.text_newlines.(i).position + add_size
  done;
  List.iter (fun p -> 
      if p.point > gpoint then
        p.point <- p.point + add_size
  ) text.text_points;
  text.text_gsize <- gsize + add_size;
  text.text_size <- old_size + add_size;
  text.text_string <- new_text;
  text.text_attrs <- new_attrs
@

<<exception Text.ReadOnlyBuffer>>=
exception ReadOnlyBuffer
@

<<function Text.tree_insert>>=
let tree_insert tree t gline nbr = ()
@

<<function Text.low_insert>>=
(*
  let rec iter tree lines =
    match tree with
      Parts text ->
        if lines = text.tree_nlines || lines = -1 then
          (* Insert in the last part *)
          iter text.tree_parts.(Array.length text.tree_parts - 1) (-1)
        else
        let rec iter2 lines i =
          let tlines = match text.tree_parts.(i) with
              Parts t -> t.tree_nlines
            | Lines t -> t.tree_nlines 
          in
          if tlines > lines then
            iter text.tree_parts.(i) lines
          else
            iter2 (lines - tlines) (i+1)
        in
        iter2 lines 0;
        text.tree_modified <- true;
        text.tree_nlines <- text.tree_nlines + nbr
    | Lines text ->
        let newtext = Array.create text.tree_nlines text.tree_parts.(0) in
        Array.blit text.tree_parts 0 newtext 0 lines;
        Array.blit t.text_newlines gline newtext lines nbr;
        Array.blit text.tree_parts lines newtext (lines+nbr) (
          text.tree_nlines - lines);
        text.tree_modified <- true;        
        text.tree_nlines <- text.tree_nlines + nbr
  in
  iter (Parts tree) gline
*)

let low_insert tree point str =
  let text = tree.tree_text in
  if text.text_readonly then failwith "Buffer is read-only";
  move_gpoint_to text point;
  let gpoint = text.text_gpoint in
  let gsize = text.text_gsize in
  let gline = text.text_gline in
  let gchars = gpoint - text.text_newlines.(gline).position in
  cancel_repr text gpoint gline;
  let strlen = String.length str in
  if strlen > gsize then extend_gap text strlen;
  let gsize = text.text_gsize in
  String.blit str 0 text.text_string gpoint strlen;
  Array.fill text.text_attrs gpoint strlen direct_attr;
  let (nbr_newlines,nbr_chars) = count_char str '\n' in
  if nbr_newlines > 0 then
    begin
      if (Array.length text.text_newlines - text.text_nlines)
        < nbr_newlines then
        begin
          let old_size = text.text_nlines in
          let new_cache = Array.create (old_size + (max 20 nbr_newlines)) 
            { position = -1;
              representation = [];
              modified = -1;
              repr_len = 0;
              repr_string = "";
              line_hlt = 0;
              items = [||];
            } 
          in
          Array.blit text.text_newlines 0 new_cache 0 old_size;
          text.text_newlines <- new_cache;
        end;
      Array.blit text.text_newlines (gline+1) 
      text.text_newlines (gline+1+ nbr_newlines) 
      (text.text_nlines - gline -1);
      text.text_nlines <- text.text_nlines + nbr_newlines;
      let rec iter n pos =
        let new_pos = String.index_from text.text_string pos '\n' in
        text.text_newlines.(gline+n) <- { position = (new_pos + 1);
          representation = [];
          modified = 0;
          repr_len = 0;
          repr_string = "";
          line_hlt = 0;
          items = [||];
        };
        if n < nbr_newlines then
          iter (n+1) (new_pos + 1)
      in
      iter 1 gpoint;
      tree_insert tree text text.text_gline nbr_newlines;
    end;
  let gline = text.text_gline in
  List.iter (fun p ->
      if p.point > gpoint then
        begin
          if p.point_y = gline then 
            (* p.point_x <- (p.point_x - (if nbr_newlines > 0 then gchars else 0)) + nbr_chars; *)
            p.point_y <- p.point_y + nbr_newlines;
        end
  ) text.text_points;
  text.text_gpoint <- gpoint + strlen;
  text.text_gsize <- gsize - strlen;
  text.text_gline <- gline + nbr_newlines;
  (gpoint,strlen,text.text_modified) 
@

<<function Text.low_delete>>=
let low_delete tree point len =
  let text = tree.tree_text in      
  if text.text_readonly then failwith "Buffer is read-only";
  move_gpoint_to text point;
  let gsize = text.text_gsize in
  let size = text.text_size in
  let gpoint = text.text_gpoint in
  let gline = text.text_gline in
  cancel_repr text gpoint gline;
  let gchars = gpoint - text.text_newlines.(gline).position in
  let gap_end = gpoint + gsize in
  let len = min (size - gap_end) len in
  let str = String.sub text.text_string gap_end len
  in
  let (nbr_newlines, nbr_chars) = count_char str '\n' in
  if nbr_newlines > 0 then
    begin
      Array.blit text.text_newlines (gline + nbr_newlines + 1)
      text.text_newlines (gline + 1) 
      (text.text_nlines - gline - nbr_newlines - 1);
      text.text_nlines <- text.text_nlines - nbr_newlines;
    end;
  text.text_gsize <- gsize + len;
  List.iter (fun p -> 
      if p.point > gap_end + len then
        begin
          (*if p.point_y = gline + nbr_newlines then
            p.point_x <- (p.point_x - nbr_chars) + 
              (if nbr_newlines > 0 then gchars else 0);*)
          p.point_y <- p.point_y - nbr_newlines;
        end 
      else
      if p.point > gpoint then
        ( p.point <- gpoint;
          (* p.point_x <- gchars; *)
          p.point_y <- gline);
  ) text.text_points;
  (gpoint,str,text.text_modified) 
@

<<function Text.undo>>=
let undo tree =
  let text = tree.tree_text in  
  let rec undo action =
    let gpoint = text.text_gpoint in
    let gsize = text.text_gsize in
    match action with
      Insertion(point_pos, len, modified) ->
        let point = if gpoint < point_pos then point_pos + gsize else point_pos in
        let (pos,str,modif) = low_delete tree point len in
        text.text_modified <- modified;
        Deletion(pos,str,modif), point_pos, 0
    | Deletion (point_pos, str, modified) ->
        let point = if gpoint < point_pos then point_pos + gsize else point_pos in
        let (pos,len,modif) = low_insert tree point str in
        text.text_modified <- modified;
        Insertion(pos,len,modif), point_pos, String.length str
    | Session actions ->
        let last_point = ref 0 in
        let last_len = ref 0 in
        let rev_actions =
          List.fold_left (fun undos action -> 
              let (rev_action,point,len) = undo action in
              last_point := point;
              last_len := len;
              rev_action :: undos
          ) [] actions
        in
        Session rev_actions, !last_point, !last_len
  in
  match text.text_history with
    [] -> raise Not_found
  | action :: tail -> 
      let rev_action = undo action in
      text.text_history <- tail;
      rev_action
@

<<function Text.insert_at_end>>=
let insert_at_end tree str =
  let text = tree.tree_text in
  let _ = low_insert tree text.text_size str in
  text.text_history <- [];
  text.text_modified <- text.text_modified + 1
@

<<function Text.insert_res>>=
let insert_res tree point str =
  let text = tree.tree_text in
  let (pos,len,modif) = low_insert tree point.point str in
  text.text_history <- Insertion(pos,len,modif) :: text.text_history;
  text.text_modified <- text.text_modified + 1;
  pos, len
@

<<function Text.insert>>=
let insert text point str = let _ = insert_res text point str in ()
@

<<function Text.delete_res>>=
let delete_res tree point len =
  let text = tree.tree_text in  
  let (pos,str,modif) = low_delete tree point.point len in
  text.text_history <- Deletion(pos,str,modif) :: text.text_history;
  text.text_modified <- text.text_modified + 1;
  pos, str
@

<<function Text.delete>>=
let delete text point len = let _ = delete_res text point len in ()
@

<<function Text.compute_newlines>>=
let compute_newlines string =
  let (nbr_newlines,_) = count_char string '\n' in
  let newlines = Array.create (nbr_newlines + 2) 
    { position = 0; representation = []; modified = 0; repr_len = 0; repr_string = ""; line_hlt = 0; items = [||]; } in
  let curs = ref 0 in
  for i = 1 to nbr_newlines do
    let pos = String.index_from string !curs '\n' in
    newlines.(i) <- { position = pos+1; representation = []; 
      modified = 0; repr_len = 0; repr_string = "";
      line_hlt = 0; items = [||];
    };
    curs := pos + 1;
  done;
  newlines.(nbr_newlines+1) <- { position = String.length string + 1; 
    representation = []; modified = 0; 
    repr_len = 0; repr_string = "";
    line_hlt = 0; items = [||];
  };
  newlines
@

<<function Text.create>>=
let create str =
  let newlines = compute_newlines str in
  let nlines = Array.length newlines in
  let attrs = (Array.create (String.length str) direct_attr) in
  let rec text =
    {
      text_string = str;
      text_attrs = attrs;
      text_size = String.length str;
      
      text_points = [];
      
      text_gpoint = 0;
      text_gline = 0;
      text_gsize = 0;
      
      text_newlines = newlines;
      text_nlines = nlines;
      
      text_modified = 0;
      text_clean = false;
      text_history = [];
      text_readonly = false;
    }
  in
  make_text text (Array.copy newlines)
@

<<function Text.find_xy>>=
let find_xy text point line pos =
  let text = text.tree_text in    
  let gpoint = text.text_gpoint in
  let gline = text.text_gline in
  let gap_end = gpoint + text.text_gsize in
  let y,x =
    if pos >= gap_end then
(* go forward *)
      let rec iter line =
        if line >= text.text_nlines then
          text.text_nlines - 1
        else
        if text.text_newlines.(line).position > pos then line - 1
        else
          iter (line + 1)
      in
      let line = 
        if point > gap_end && pos > point then
          iter (line+1) 
        else
          iter (gline+1) 
      in
      if line = gline then
        let gchars = gpoint - text.text_newlines.(gline).position in
        line, gchars + pos - gap_end
      else
        line, pos - text.text_newlines.(line).position
    else
(* go backward *)
    let rec iter line =
      if line > 0 then
        if text.text_newlines.(line).position > pos then 
          iter (line - 1)
        else
          line
      else
        0
    in
    let line = 
      if point < gpoint && pos <= point then
        iter line 
      else
        iter gline in
    line, pos - text.text_newlines.(line).position
  in
  x,y
@

<<function Text.add_point>>=
let add_point tree =
  let text = tree.tree_text in      
  let point = {
      point = 0;
      point_y = 0;
    } in    
  text.text_points <- point :: text.text_points;
  point
@

<<function Text.dup_point>>=
let dup_point tree point =
  let text = tree.tree_text in      
  let p = {
      point = point.point;
      point_y = point.point_y
    } in
  text.text_points <- p :: text.text_points;
  p
@

<<function Text.goto_point>>=
let goto_point text p1 p2 =
  p1.point <- p2.point;
  p1.point_y <- p2.point_y
@

<<function Text.move_point_to>>=
let move_point_to tree point p =
  let text = tree.tree_text in    
  let gpoint = text.text_gpoint in
  let gline = text.text_gline in
  let x,y = find_xy tree gpoint gline p in
  point.point <- p;
  point.point_y <- y
@

<<function Text.remove_point>>=
let remove_point tree p =
  let text = tree.tree_text in      
  text.text_points <- 
    (List.fold_left (fun points point ->
        if point == p then points else point :: points) 
    [] text.text_points)
@

<<function Text.read>>=
let read inc =
  create (read_string inc)
@

<<function Text.save>>=
let save tree outc =
  let text = tree.tree_text in    
  let str = text.text_string in
  let gpoint = text.text_gpoint in
  let gsize = text.text_gsize in
  output outc str 0 gpoint;
  output outc str (gpoint + gsize) 
  (text.text_size - gpoint - gsize)
@

<<function Text.unset_attr>>=
let unset_attr text =
  let text = text.tree_text in  
  Array.fill text.text_attrs 0 (Array.length text.text_attrs) direct_attr;
  Array.iter (fun line -> line.modified <- 0) text.text_newlines
@

<<function Text.set_attr>>=
let set_attr tree point len attr = (* should not exceed one line *)
  let text = tree.tree_text in  
  if len > 0 then
    let point = point.point in
    let gpoint = text.text_gpoint in
    let gline = text.text_gline in
    let size = text.text_size in
    let gap_end = gpoint + text.text_gsize in
    let x,y = find_xy tree gpoint gline point in
    cancel_repr text point y;
    let before, after, after_pos =
      if point > gap_end then
        0, (min (size - point) len), point
      else
      if point + len <= gpoint then
        0, len, point
      else
      let before = gpoint - point in
      let after = min (len - before) (size - gap_end) in
      before, after, gap_end
    in
    let attrs = text.text_attrs in
    if before > 0 then Array.fill attrs point before attr;
    Array.fill attrs after_pos after attr
@

<<function Text.low_distance>>=
let low_distance text p1 p2 =
  if p1 >= p2 then 0 else
  if p1 <= text.text_gpoint then
    if p2 <= text.text_gpoint then
      p2 - p1
    else
      p2 - p1 - text.text_gsize
  else
  if p2 <= text.text_gpoint then
    p2 - p1 + text.text_gsize
  else
    p2 - p1
@

<<function Text.distance>>=
let distance tree p1 p2 =
  let text = tree.tree_text in    
  low_distance text p1.point p2.point
@

<<function Text.compare>>=
let compare text p1 p2 = compare p1.point p2.point
@

<<function Text.add>>=
let add text point delta =
  let gpoint = text.text_gpoint in
  let gap_end = gpoint + text.text_gsize in
  if point <= gpoint && point + delta > gpoint then
    point + delta + text.text_gsize
  else
  if point >= gap_end && point+delta < gap_end then
    point + delta - text.text_gsize
  else
    point + delta
@

<<function Text.get_char>>=
let get_char tree point =
  let text = tree.tree_text in    
  let point = point.point in
  let gpoint = text.text_gpoint in
  let gsize = text.text_gsize in
  let size = text.text_size in
  let string = text.text_string in
  let point = 
    if point = gpoint then point + gsize else point
  in
  if point < size then
    string.[point]
  else
    '\000'
@

<<function Text.get_attr>>=
let get_attr tree point =
  let text = tree.tree_text in    
  let point = point.point in
  let gpoint = text.text_gpoint in
  let gsize = text.text_gsize in
  let size = text.text_size in
  let attrs = text.text_attrs in
  let point = 
    if point = gpoint then point + gsize else point
  in
  if point < size then
    attrs.(point)
  else
    direct_attr
@

<<function Text.set_char_attr>>=
let set_char_attr tree point attr =
  let text = tree.tree_text in    
  let line = point.point_y in
  let point = point.point in
  let gpoint = text.text_gpoint in
  let gsize = text.text_gsize in
  let size = text.text_size in
  let attrs = text.text_attrs in
  let point = 
    if point = gpoint then point + gsize else point
  in
  if point < size then
    (cancel_repr text point line;
      attrs.(point) <- attr)
@

<<function Text.fmove_res>>=
let fmove_res tree p delta =
  let text = tree.tree_text in    
  if delta = 0 then 0 else
  let gpoint = text.text_gpoint in
  let gsize = text.text_gsize in
  let size = text.text_size in
  let gap_end = gpoint + text.text_gsize in
  let gline = text.text_gline in
  let point = p.point in
  let old_point = point in
  let string = text.text_string in
  let lines = text.text_newlines in
  let rec iter y point end_point =
    if end_point > point then
      let end_line = lines.(y+1).position in
      if end_point >= end_line then
        iter (y+1) end_line end_point
      else
        (y, end_point)
    else
      (y,point)
  in
  let (y,point) = 
    if point + delta <= gpoint then
      iter p.point_y point (point+delta)
    else
    if point >= gap_end then
      let delta = min delta (size - point) in
      iter p.point_y point (point + delta)
    else
    let delta = min (delta - (gpoint - point)) (size - gap_end) in
    iter gline gap_end
      (gap_end + delta) 
  in
  p.point <- point;
  p.point_y <- y;
  low_distance text old_point point
@

<<function Text.bmove_res>>=
let bmove_res tree p delta =
  let text = tree.tree_text in    
  if delta = 0 then 0 else
  let gpoint = text.text_gpoint in
  let gsize = text.text_gsize in
  let size = text.text_size in
  let gap_end = gpoint + text.text_gsize in
  let gline = text.text_gline in
  let point = p.point in
  let old_point = point in
  let string = text.text_string in
  let lines = text.text_newlines in
  let rec iter y end_point =
    let start_line = lines.(y).position in
    if end_point >= start_line then
      (y, end_point)
    else
      iter (y-1) end_point
  in
  let (y,point) = 
    if point - delta >= gap_end then
      if point - delta < lines.(gline+1).position then
        (
          gline, point - delta)
      else
        iter p.point_y (point-delta)
    else
    if point <= gpoint then
      let delta = min delta point in
      iter p.point_y (point - delta)
    else
    let delta = min (delta - (point - gap_end)) gpoint in
    iter gline (gpoint - delta) 
  in
  p.point <- point;
  p.point_y <- y;
  low_distance text point old_point
@

<<function Text.bmove>>=
let bmove text p delta = 
  let _ = bmove_res text p delta in ()
@

<<function Text.fmove>>=
let fmove text p delta = 
  let _ = fmove_res text p delta in ()
@

<<function Text.to_string>>=
let to_string tree =
  let text = tree.tree_text in    
  let len = text.text_size - text.text_gsize in
  if len = 0 then "" else
  let str = String.create len in
  let gpoint = text.text_gpoint in
  let gap_end = gpoint + text.text_gsize in
  String.blit text.text_string 0 str 0 gpoint;
  String.blit text.text_string gap_end str gpoint (len- gpoint);
  str
@

<<function Text.clean_text>>=
let clean_text text =
  if not text.text_clean then
    let size = text.text_size in
    let gsize = text.text_gsize in
    let string = text.text_string in
    move_gpoint_to text size;
    String.fill string (size - gsize) gsize '\000';
    text.text_clean <- true
@

<<function Text.blit>>=
let blit str tree point len =
  let text = tree.tree_text in      
  let len = min len (low_distance text point.point text.text_size) in
  let gpoint = text.text_gpoint in
  let gap_end = gpoint + text.text_gsize in
  if point.point+len >= gpoint && point.point < gap_end then clean_text text;
  (try
    String.blit text.text_string point.point str 0 len
    with 
      e -> raise e);
  len
@

<<function Text.get_position>>=
let get_position tree point = 
  let text = tree.tree_text in    
  if point.point > text.text_gpoint then
    point.point - text.text_gsize
  else
    point.point
@

<<function Text.set_position>>=
let set_position tree point pos =
  let text = tree.tree_text in    
  move_point_to tree point
    (if pos > text.text_gpoint then pos + text.text_gsize
    else
      pos)
@

<<function Text.sub>>=
let sub text point len =
  let str = String.create len in
  let _ = blit str text point len in
  str
@

<<function Text.search_forward>>=
let search_forward tree regexp point =
  let text = tree.tree_text in    
  let gsize = text.text_gsize in
  let gap_end = text.text_gpoint + gsize in
  if point.point = text.text_gpoint then point.point <- gap_end;
  if point.point < gap_end then clean_text text;
  let gap_end = text.text_gpoint + gsize in  
  let string = text.text_string in
  let pos = Str.search_forward regexp string point.point in
  let pos = if pos >= gap_end then pos - gsize else pos in
  set_position tree point pos;
  Str.match_end () - Str.match_beginning ()
@

<<function Text.replace_matched>>=
let replace_matched tree repl =
  let text = tree.tree_text in    
  Str2.replace_matched repl text.text_string
@

<<function Text.search_forward_matched>>=
let search_forward_matched tree regexp point =
  let text = tree.tree_text in      
  let gsize = text.text_gsize in
  let gap_end = text.text_gpoint + gsize in
  if point.point = text.text_gpoint then point.point <- gap_end;
  if point.point < gap_end then clean_text text;
  let gap_end = text.text_gpoint + gsize in  
  let string = text.text_string in
  let pos = Str.search_forward regexp string point.point in
  let pos = if pos >= text.text_gpoint + gsize then pos - gsize else pos in
  set_position tree point pos;
  Str.matched_string string
@

<<function Text.search_forward_groups>>=
let search_forward_groups tree regexp point groups =
  let text = tree.tree_text in      
  let gsize = text.text_gsize in
  let gap_end = text.text_gpoint + gsize in
  if point.point = text.text_gpoint then point.point <- gap_end;
  if point.point < gap_end then clean_text text;
  let gap_end = text.text_gpoint + gsize in  
  let string = text.text_string in
  let pos = Str.search_forward regexp string point.point in
  let pos = if pos >= gap_end then pos - gsize else pos in
  let array = Array.init groups (fun i -> Str.matched_group (i+1) string) in
  set_position tree point pos;
  array
@

<<function Text.search_backward>>=
let search_backward tree regexp point =
  let text = tree.tree_text in    
  if point.point > text.text_gpoint then clean_text text;
  let string = text.text_string in
  let start_pos =     
    if point.point > 0 then point.point - 1 
    else raise Not_found  in
  let pos =  Str.search_backward regexp string start_pos in
  set_position tree point pos;
  Str.match_end () - Str.match_beginning ()
@

<<function Text.search_backward_groups>>=
let search_backward_groups tree regexp point groups =  
  let text = tree.tree_text in    
  if point.point > text.text_gpoint then clean_text text;
  let string = text.text_string in
  let start_pos =     
    if point.point > 0 then point.point - 1 
    else raise Not_found  in
  let pos =  Str.search_backward regexp string start_pos in
  let array = Array.init groups (fun i -> Str.matched_group (i+1) string) in
  set_position tree point pos;
  array
@

<<constant Text.repr_string>>=
let repr_string = ref ""
@

<<constant Text.repr_size>>=
let repr_size = ref 0
@

<<constant Text.tabreprs>>=
let tabreprs = [|
@

<<function Text.compute_representation>>=
(* On devrait reprendre la representation la ou elle est ... *)
let compute_representation tree charreprs n =
  let text = tree.tree_text in      
  if n >= text.text_nlines - 1 then 
    begin
      dummy_line.position <- text.text_size;
      dummy_line
    end
  else
  let line = text.text_newlines.(n) in
  if line.modified >= 0 then
    begin
      let start_pos = line.position in
      let end_pos = text.text_newlines.(n+1).position - 1
      in
      let len = low_distance text end_pos start_pos in
      let rec iter repr_list =
        match repr_list with
          repr :: tail ->
            let next_pos = repr.repr_line_pos + repr.repr_line_len in
            if next_pos < line.modified then
              repr_list, next_pos, repr.repr_pos + repr.repr_size
            else
              iter tail
        | [] ->
            [], 0, 0
      in
      let (repr_tail, next_pos, repr_pos) = iter line.representation in
      let repr_tail = ref repr_tail in
      let line_curs = ref (line.position + next_pos) in
      let line_start = ref next_pos in
      let repr_curs = ref repr_pos in
      let repr_start = ref repr_pos in
      let gpoint = text.text_gpoint in
      let gsize = text.text_gsize in
      let char_repr = ref "" in
      let char_size = ref 0 in
      repr_string := line.repr_string;
      repr_size := String.length line.repr_string;
      if !line_curs >= gpoint && 
        !line_curs < gpoint + gsize then 
        line_curs := !line_curs + gsize;
      while !line_curs < end_pos do
        let charattr = text.text_attrs.(!line_curs) in
        let char = Char.code text.text_string.[!line_curs] in      
        let charrepr =
          let char = Char.code text.text_string.[!line_curs] in      
          if char = 9 then tabreprs.(!repr_curs mod 9)
          else charreprs.(char) in
        let charsize = String.length charrepr in
        let line_len = ref 0 in
        (* for J.G. Malecki: tabs have a different representation depending
  on their position in the text (as in xterms) *)
        
        while !line_curs < end_pos && 
          (
            let char = Char.code text.text_string.[!line_curs] in
            char_repr := 
            (let char = Char.code text.text_string.[!line_curs] in      
              if char = 9 then tabreprs.(!repr_curs mod 9)
              else charreprs.(char));
            char_size := String.length !char_repr;
            !char_size == charsize && 
            charattr == text.text_attrs.(!line_curs)) do
          if !repr_curs + charsize >= !repr_size then
            begin
(* find a better heuristic to realloc the line string *)
              let new_len = !repr_size + 
                  (low_distance text end_pos !line_curs) + charsize * 2 
              in
              let new_repr = String.create new_len in
              String.blit !repr_string 0 new_repr 0 !repr_curs;
              repr_string := new_repr;
              repr_size := new_len;
            end;
          String.blit !char_repr 0 !repr_string !repr_curs charsize;
          repr_curs := !repr_curs + charsize;
          line_curs := !line_curs + 1;
          line_len := !line_len +1;
          if !line_curs = gpoint then line_curs := gpoint + gsize;
        done;
        let repr = {
            repr_line_pos = !line_start;
            repr_line_len = !line_len;
            
            repr_attr = charattr;
            repr_charsize = charsize;
            
            repr_size = !line_len * charsize;
            repr_pos = !repr_start;
          } in
        repr_start := !repr_curs;
        line_start := !line_start + !line_len;
        repr_tail := repr :: !repr_tail;
      done;
      line.representation <- !repr_tail;
      line.modified <- -1;
      line.repr_len <- !repr_curs;
      line.repr_string <- !repr_string;

      (* once we have computed the simple representation, we can add more
      complicated things, such as highlighting ... *)
      if line.line_hlt <> 0 then
        if line.line_hlt > 0 then
          (* the line is hightlighted from the beginning to pos the
            line.line_hlt char *)
          begin
            let first = line.line_hlt - 1 in
            let rec iter list tail =
              match list with
                [] -> List.rev tail 
              | repr :: list_r ->
                  if repr.repr_line_pos > first then
                    iter list_r (repr :: tail)
                  else
                  let len = first - repr.repr_line_pos + 1 in
                  (List.rev tail) @
                    (let before, after = 
                      if len = repr.repr_line_len then
                        [], list
                      else
                        [ 
                          { 
                            repr_attr = repr.repr_attr;
                            repr_charsize = repr.repr_charsize;
                            repr_line_pos = repr.repr_line_pos+len;
                            repr_line_len = repr.repr_line_len - len;
                            repr_size = repr.repr_charsize * (repr.repr_line_len - len);
                            repr_pos = repr.repr_pos + (len * repr.repr_charsize)
                          }
                        ], (
                          { 
                            repr_attr = repr.repr_attr;
                            repr_charsize = repr.repr_charsize;
                            repr_line_pos = repr.repr_line_pos;
                            repr_pos = repr.repr_pos;
                            repr_line_len = len;
                            repr_size = repr.repr_charsize * len;
                          }
                            :: list_r)
                    in
                    List.iter 
                      (fun repr ->
                        repr.repr_attr <- repr.repr_attr lor (1 lsl 24))
                    after;
                    before @ after)
            in
            line.representation <- iter line.representation []
          end
        else
        (* the line is hightlighted from then end to pos line.line_hlt *)
          begin
            let first = line.line_hlt - 1 in
            let rec iter list tail =
              match list with
                [] -> List.rev tail 
              | repr :: list_r ->
                  if repr.repr_line_pos > first then
                    iter list_r (repr :: tail)
                  else
                  let len = first - repr.repr_line_pos + 1 in
                  (List.rev tail) @
                    (let before, after = 
                      if len = repr.repr_line_len then
                        [], list
                      else
                        [ 
                          {repr_attr = repr.repr_attr;
                            repr_charsize = repr.repr_charsize;
                            repr_line_pos = repr.repr_line_pos+len;
                            repr_line_len = repr.repr_line_len - len;
                            repr_size = repr.repr_charsize * (repr.repr_line_len - len);
                            repr_pos = repr.repr_pos + (len * repr.repr_charsize)
                          }
                        ], (
                          { 
                             repr_attr = repr.repr_attr;
                            repr_charsize = repr.repr_charsize;
                            repr_line_pos = repr.repr_line_pos;
                            repr_pos = repr.repr_pos;
                            repr_line_len = len;
                            repr_size = repr.repr_charsize * len;
                          }
                            :: list_r)
                    in
                    List.iter 
                      (fun repr ->
                        repr.repr_attr <- repr.repr_attr lor (1 lsl 24))
                    after;
                    before @ after)
            in
            line.representation <- iter line.representation []
          end;
    
    end;
  line
@

<<function Text.point_to_eol>>=
let point_to_eol tree point =
  let text = tree.tree_text in    
  low_distance text point.point 
    (text.text_newlines.(point.point_y + 1).position - 1)
@

<<function Text.point_to_bol>>=
let point_to_bol tree point =
  let text = tree.tree_text in    
  low_distance text 
    text.text_newlines.(point.point_y).position
    point.point
@

<<function Text.point_to_eof>>=
let point_to_eof tree point =
  let text = tree.tree_text in    
  low_distance text point.point text.text_size
@

<<function Text.point_to_bof>>=
let point_to_bof tree point =
  let text = tree.tree_text in    
  low_distance text 0 point.point
@

<<function Text.move_res>>=
let move_res text point n =
  if n > 0 then
    fmove_res text point n
  else
    bmove_res text point (-n)
@

<<function Text.move>>=
let move text point n = let _ = move_res text point n in ()
@

<<function Text.point_to_lof>>=
let point_to_lof text point n =
  if n > 0 then
    point_to_eof text point
  else
    point_to_bof text point
@

<<function Text.point_to_lol>>=
let point_to_lol text point n =
  if n > 0 then
    point_to_eol text point
  else
    point_to_bol text point
@

<<function Text.point_to_line>>=
let point_to_line tree point line =
  let text = tree.tree_text in    
  let pos = 
    if text.text_nlines <= line + 1 then text.text_size
    else
      text.text_newlines.(line).position
  in
  move_point_to tree point text.text_newlines.(line).position
@

<<function Text.clear>>=
let clear tree =
  let text = tree.tree_text in      
  let _ = low_delete tree 0 (text.text_size - text.text_gsize) in
  text.text_history <- [];
  List.iter (fun p -> p.point <- 0; p.point_y <- 0) text.text_points
@

<<function Text.point_line>>=
let point_line text point = point.point_y
@

<<function Text.goto_line>>=
let goto_line tree point y =
  let text = tree.tree_text in      
  if text.text_nlines - 1 <= y then  
    set_position tree point (size tree)
  else 
  let line = text.text_newlines.(y) in
  point.point <- line.position;
  point.point_y <- y
@

<<function Text.region>>=
let rec region tree p1 p2 =
  let text = tree.tree_text in    
  if p1>p2 then region tree p2 p1
  else
    sub tree p1 (distance tree p1 p2)
@

<<function Text.goto_xy>>=
let goto_xy tree point x y =
  let text = tree.tree_text in    
  let y =
    if y < text.text_nlines then y
    else text.text_nlines - 1
  in
  point.point <- text.text_newlines.(y).position;
  point.point_y <- y;
  let _ = fmove tree point x in ()
@

<<function Text.update>>=
let update tree str =
  let text = tree.tree_text in    
  let newlines = compute_newlines str in
  let len = String.length str in
  let pts = List.map (fun point -> 
        point.point <- get_position tree point) text.text_points
  in
  text.text_string <- str;
  text.text_attrs <- (Array.create len direct_attr);
  text.text_size <- len;
  text.text_gpoint <- 0;
  text.text_gline <- 0;
  text.text_gsize <- 0;
  text.text_newlines <- newlines;
  text.text_nlines <- Array.length newlines;
  text.text_modified <- text.text_modified + 1 ;
  text.text_clean <- true;
  text.text_history <- [];
  List.iter (fun point -> 
      let pos = point.point in
      point.point <- 0;
      point.point_y <- 0;
      set_position tree point pos) 
  text.text_points
@

<<function Text.lexing>>=
let lexing tree curseur end_point =
  let text = tree.tree_text in    
  clean_text text;
  Lexing.from_function 
    (fun str len ->
      let len = min len (distance tree curseur end_point) in
      let len = blit str tree curseur len in
      let _ = fmove tree curseur len in
      len
  )
@

<<function Text.start_session>>=
let start_session tree =   
  let text = tree.tree_text in    
  text.text_modified
@

<<function Text.commit_session>>=
let commit_session tree session_date =
  let text = tree.tree_text in      
  if text.text_modified > session_date then
    let rec iter session history =
      match history with
        [] -> assert false
      | action :: history ->
          let date =
            match action with
              Session _ -> failwith "Can not commit nested sessions"
            | Insertion (_,_,date) -> date
            | Deletion (_,_,date) -> date
          in
          if date = session_date then
            text.text_history <- (Session (List.rev (action::session)))
            :: history
          else
            iter (action::session) history
    in
    iter [] text.text_history
@

<<function Text.readonly>>=
let readonly tree = 
  let text = tree.tree_text in    
  text.text_readonly
@

<<function Text.toggle_readonly>>=
let toggle_readonly tree = 
  let text = tree.tree_text in    
  text.text_readonly <- not text.text_readonly
@


%-------------------------------------------------------------

<<core/text.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

(* A FAIRE:
On doit faire converger ce text vers un text directement affichable par
WX_text. Pour cela:

Modifier WX_text pour qu'il se satisfasse de l'interface de Text.
En particulier, il doit n'utiliser que les fonctions suivantes:

Text.representation text line --> string (buffer or copy) * int (position)
Text.items line -> item array
  
Il doit aussi utiliser la structure un peu particuliere de l'arbre utiliser
ici.
  
*)

open Options
open Utils
open WX_types
open WX_text
  
<<type Text.attribute>>
<<type Text.delta>>
<<type Text.position>>

<<type Text.direct>>
<<type Text.session>>

<<type Text.line>>

<<type Text.point>>

<<type Text.repr>>

<<type Text.text>>
  
<<type Text.action>>

module Text = struct
    type t = text
    type text = t
    type l = line
    type line = l
      
    let representation tree line = line.repr_string, line.position
    let items tree line = line.items
  end
      
module TextTree = WX_text.Make(Text)
open TextTree
  
<<type Text.t>>

external id: t -> tree tree_desc = "%identity"
  
<<function Text.version>>
  
<<function Text.nbre_lines>>
  
<<function Text.size>>
  
<<function Text.point_col>>

<<function Text.make_attr>>

<<constant Text.direct_attr>>
<<constant Text.inverse_attr>>

<<function Text.move_gpoint_to>>

<<function Text.cancel_repr>>

<<constant Text.add_amount>>
<<function Text.extend_gap>>

<<exception Text.ReadOnlyBuffer>>

<<function Text.tree_insert>>
<<function Text.low_insert>>

<<function Text.low_delete>>

<<function Text.undo>>

<<function Text.insert_at_end>>

<<function Text.insert_res>>

<<function Text.insert>>
  
<<function Text.delete_res>>

<<function Text.delete>>
  
<<function Text.compute_newlines>>

<<function Text.create>>
  
<<function Text.find_xy>>

<<function Text.add_point>>

<<function Text.dup_point>>

<<function Text.goto_point>>

<<function Text.move_point_to>>

<<function Text.remove_point>>

<<function Text.read>>

<<function Text.save>>

<<function Text.unset_attr>>

<<function Text.set_attr>>

<<function Text.low_distance>>

<<function Text.distance>>

<<function Text.compare>>
  
<<function Text.add>>

<<function Text.get_char>>

<<function Text.get_attr>>


<<function Text.set_char_attr>>

<<function Text.fmove_res>>



<<function Text.bmove_res>>

<<function Text.bmove>>

<<function Text.fmove>>
  
<<function Text.to_string>>


<<function Text.clean_text>>


<<function Text.blit>>
  
<<function Text.get_position>>

<<function Text.set_position>>
    
<<function Text.sub>>
    
<<function Text.search_forward>>

<<function Text.replace_matched>>
  
<<function Text.search_forward_matched>>

<<function Text.search_forward_groups>>

<<function Text.search_backward>>

<<function Text.search_backward_groups>>


<<constant Text.repr_string>>
<<constant Text.repr_size>>

let (dummy_line : line) = 
  {
    position = max_int;
    representation = [];
    modified = 0;
    repr_len = 0;
    repr_string = "";
    line_hlt = 0;
    items = [||];
  } 

  
<<constant Text.tabreprs>>
    "         ";
    "        ";
    "       ";
    "      ";
    "     ";
    "    ";
    "   ";
    "  ";
    " ";
    ""
  |]
      
<<function Text.compute_representation>>


<<function Text.point_to_eol>>

<<function Text.point_to_bol>>

<<function Text.point_to_eof>>

<<function Text.point_to_bof>>

<<function Text.move_res>>

<<function Text.move>>

<<function Text.point_to_lof>>

<<function Text.point_to_lol>>

<<function Text.point_to_line>>

<<function Text.clear>>


<<function Text.point_line>>


<<function Text.goto_line>>


<<function Text.region>>

<<function Text.goto_xy>>

<<function Text.update>>

<<function Text.lexing>>

<<function Text.start_session>>
  
<<function Text.commit_session>>
    
<<function Text.readonly>>
  
<<function Text.toggle_readonly>>
  
@


\subsection*{[[core/ebuffer.ml]]}

<<constant Ebuffer.create_buf_hook>>=
let create_buf_hook = Local.create_abstr "create_buf_hook"
@

<<constant Ebuffer.modes_alist>>=
let modes_alist = Local.create_abstr "modes_alist"
@

<<function Ebuffer.create_syntax_table>>=
let create_syntax_table ()  =
  let table = Array.create 256 false 
  in  
  for i = Char.code 'a' to Char.code 'z' do
    table.(i) <- true;
  done;
  for i = Char.code 'A' to Char.code 'Z' do
    table.(i) <- true;
  done;
  for i = Char.code '0' to Char.code '9' do
    table.(i) <- true;
  done;
  table
@

<<constant Ebuffer.default_syntax_table>>=
let default_syntax_table = create_syntax_table ()
@

<<function Ebuffer.get_name>>=
let get_name location filename =
  let basename = Filename.basename filename in
  let name = 
    if basename = "" then
      (Filename.basename (Filename.dirname filename)) ^ "/"
    else
      basename
  in
  let i = ref 0 in
  let compute_name () =
    if !i = 0 then name else
      Printf.sprintf "%s<%d>" name !i
  in
  try
    while true do
      let _ = Hashtbl.find location.loc_buffers (compute_name ()) in 
      incr i
    done; assert false
  with
    Not_found -> 
      compute_name ()
@

<<function Ebuffer.new_minor_mode>>=
let new_minor_mode name = {
    min_name = name;
    min_map = Keymap.create ();
    min_hooks = [];
    min_vars = Local.vars ()
  }
@

<<function Ebuffer.new_minor_mode (core/ebuffer.ml)>>=
let new_minor_mode name hooks  = {
    min_name = name;
    min_map = Keymap.create ();
    min_hooks = hooks;
    min_vars = Local.vars ()
  }
@

<<function Ebuffer.new_major_mode>>=
let new_major_mode name hooks = {
    maj_name = name;
    maj_map = Keymap.create ();
    maj_hooks = hooks;
    maj_vars = Local.vars ();
  }
@

<<constant Ebuffer.fondamental_mode>>=
let fondamental_mode = new_major_mode "Fondamental" []
@

<<constant Ebuffer.tab_size>>=
let tab_size = ref 9
@

<<function Ebuffer.create>>=
let create location name filename text local_map =
  let name = get_name location name in
  let buf =
    { 
      buf_modified = 0;
      buf_text = text;
      buf_name = name;
      buf_filename = filename;
      buf_last_saved = version text;
      buf_history = [];
      buf_charreprs = Array.init 256 (fun i ->   String.make 1 (Char.chr i));
      buf_map_partial = true;
      buf_map = local_map;
      buf_sync = false;
      buf_mark = None;
      buf_point = Text.add_point text;
      buf_start = Text.add_point text;
      buf_shared = 0;
      buf_syntax_table = default_syntax_table;
      buf_finalizers = [];
      buf_vars = Local.vars ();
      buf_location = location;
      buf_minor_modes = [];
      buf_major_mode = fondamental_mode;
    } in
  Hashtbl.add location.loc_buffers name buf;
  for i=0 to 25 do
    let s = String.make 2 '^' in
    s.[1] <- Char.chr (97+i);    
    buf.buf_charreprs.(i) <- s
  done;
  buf.buf_charreprs.(9) <- String.make !tab_size ' ';
  let hooks =  try
      get_global location create_buf_hook
    with Not_found -> []
  in
  exec_hooks hooks buf;
  buf
@

<<function Ebuffer.kill>>=
let kill location buf =
  Hashtbl.remove location.loc_buffers buf.buf_name;
  begin
    match buf.buf_filename with
      None -> ()
    | Some filename ->
        Hashtbl.remove location.loc_files filename
  end;
  List.iter (fun f -> f () ) buf.buf_finalizers;
  Gc.compact ();
  buf.buf_shared <- -1
@

<<constant Ebuffer.save_buffer_hooks>>=
let save_buffer_hooks = define_option ["save_buffer_hooks"] "" 
    (list_option string_option)
  [ ]
@

<<constant Ebuffer.saved_buffer_hooks>>=
let saved_buffer_hooks = define_option ["saved_buffer_hooks"] "" 
    (list_option string_option)
  ["update_time" ]
@

<<function Ebuffer.exec_named_buf_hooks>>=
let rec exec_named_buf_hooks hooks frame =
  match hooks with
    [] -> ()
  | action :: hooks ->
      exec_named_buf_hooks hooks frame;
      try execute_buffer_action action frame with _ -> ()
@

<<function Ebuffer.exec_named_buf_hooks_with_abort>>=
let rec exec_named_buf_hooks_with_abort hooks frame =
  match hooks with
    [] -> ()
  | action :: hooks ->
      exec_named_buf_hooks_with_abort hooks frame;
      execute_buffer_action action frame
@

<<function Ebuffer.save>>=
let save buf =
  exec_named_buf_hooks_with_abort !!saved_buffer_hooks buf;
  let filename =
    match buf.buf_filename with
      None -> raise Not_found
    | Some name -> name
  in
  let outc = open_out filename in
  Text.save buf.buf_text outc;
  close_out outc;
  buf.buf_last_saved <- version buf.buf_text;
  exec_named_buf_hooks !!saved_buffer_hooks buf
@

<<exception Ebuffer.Found>>=
exception Found of buffer
@

<<function Ebuffer.read>>=
let read location filename local_map =
  try
    let filename = Utils.normal_name location.loc_dirname filename in
    try
      Hashtbl.find location.loc_files filename
    with
      Not_found ->
        let text =
          try
            let inc = open_in filename in
            let text = Text.read inc in         
            close_in inc; 
            text
          with
            _ -> Text.create ""
        in
        let buf = create location filename (Some filename) text local_map in
        Hashtbl.add location.loc_files filename buf;
        buf
  with
    Found buf -> buf
@

<<function Ebuffer.default>>=
let default location name =
  try
    Hashtbl.find location.loc_buffers name
  with
    Not_found ->
      let str = 
        if name = "*help*" then
          "Welcome to Efuns, a small demo editor written in Ocaml.

Version is " ^ Version.efuns_version ^"
built by "^ Version.builder ^ " " ^ Version.date ^ " 
with
Efuns installation directory : " ^ Version.efuns_lib ^ "
Ocaml installation directory : " ^ Version.ocamllib ^ "

Fabrice Le Fessant
PARA/SOR Project
INRIA Rocquencourt

Help for Key Bindings: C-h K
See changes in "^ Version.efuns_lib ^"/Changes
"
        else ""
      in
      create location name None (Text.create str) (Keymap.create ())
@

<<function Ebuffer.compute_representation>>=
let compute_representation buf n =
  Text.compute_representation buf.buf_text buf.buf_charreprs n
@

<<exception Ebuffer.BufferAlreadyOpened>>=
exception BufferAlreadyOpened
@

<<function Ebuffer.change_name>>=
let change_name location buf filename =
  Hashtbl.remove location.loc_buffers buf.buf_name;
  (match buf.buf_filename with
      None -> ()
    | Some filename ->
        Hashtbl.remove location.loc_files filename);
  let filename = 
    if Filename.is_relative filename then
      Filename.concat location.loc_dirname filename
    else
      filename
  in
  if hashtbl_mem location.loc_files filename then
    raise BufferAlreadyOpened;
  let filename = Utils.normal_name location.loc_dirname filename in
  let name = get_name location filename in
  Hashtbl.add location.loc_buffers name buf;
  Hashtbl.add location.loc_files filename buf;
  buf.buf_filename <- Some filename;
  buf.buf_name <- name
@

<<function Ebuffer.set_mark>>=
let set_mark buf point =
  let text = buf.buf_text in
  buf.buf_modified <- buf.buf_modified + 1;
  match buf.buf_mark with
    None ->
      let mark = dup_point text point in
      buf.buf_mark <- Some mark
  | Some mark ->
      goto_point text mark point
@

<<function Ebuffer.get_mark>>=
let rec get_mark buf point =
  match buf.buf_mark with
    None -> 
      set_mark buf point;
      get_mark buf point
  | Some mark -> mark
@

<<function Ebuffer.remove_mark>>=
let remove_mark buf =
  match buf.buf_mark with
    None -> ()
  | Some mark ->
      buf.buf_mark <- None;
      remove_point buf.buf_text mark;
      buf.buf_modified <- buf.buf_modified + 1
@

<<constant Ebuffer.modes_old>>=
let modes_old = ref []
@

<<constant Ebuffer.regexp_alist>>=
let regexp_alist = ref []
@

<<function Ebuffer.set_major_mode>>=
let set_major_mode buf mode =
  buf.buf_modified <- buf.buf_modified + 1;
  buf.buf_major_mode <- mode;
  List.iter (fun f -> 
      try f buf with _ -> ()) mode.maj_hooks
@

<<function Ebuffer.set_minor_mode>>=
let set_minor_mode buf mode =
  buf.buf_minor_modes <- mode :: buf.buf_minor_modes;
  buf.buf_modified <- buf.buf_modified + 1;
  List.iter (fun f -> 
      try f buf with _ -> ()) mode.min_hooks
@

<<function Ebuffer.del_minor_mode>>=
let del_minor_mode buf minor =
  buf.buf_minor_modes <- 
    List.fold_right 
    (fun mode list -> 
      if mode == minor then
        begin
          buf.buf_modified <- buf.buf_modified + 1;
          list
        end
      else (mode :: list)) buf.buf_minor_modes []
@

<<function Ebuffer.modep>>=
let modep buf minor =
  List.memq minor buf.buf_minor_modes
@

<<constant Ebuffer.suffix_reg>>=
let suffix_reg = Str.regexp "\(.*\)<[0-9]+>$"
@
%$

<<function Ebuffer.set_buffer_mode>>=
let set_buffer_mode buf =
  let buf_name = 
    match buf.buf_filename with
      None -> 
        (try
          if Str.string_match suffix_reg buf.buf_name 0 then
            Str.matched_group 1 buf.buf_name else buf.buf_name 
        with
          _ -> buf.buf_name)
    | Some file_name -> file_name 
  in 
  let modes_alist = get_var buf modes_alist in
  if not (!modes_old == modes_alist) then
    begin
      regexp_alist := 
      List.map 
        (fun (file_reg, major) ->
          Str.regexp file_reg, major) modes_alist;
      modes_old := modes_alist;
    end;
  try
    List.iter (fun (regexp, major) ->
        if Str.string_match regexp buf_name 0 then
          try
            set_major_mode buf major;
            raise Exit
          with
            _ -> raise Exit
    ) !regexp_alist
  with
    Exit -> ()
@

<<function Ebuffer.get_binding>>=
let get_binding buf keylist =
  let binding = ref Unbound in
  try
    List.iter (fun minor ->
        let b = Keymap.get_binding minor.min_map keylist in
        match b with
          Prefix map -> binding := b
        | Function f -> binding := b; raise Exit
        | Unbound -> ()
    ) buf.buf_minor_modes; 
    (let b = Keymap.get_binding buf.buf_major_mode.maj_map keylist in
      match b with
        Prefix map -> binding := b
      | Function f -> binding := b; raise Exit
      | Unbound -> ());
    (let b = Keymap.get_binding buf.buf_map keylist in
      match b with
        Prefix map -> binding := b;
      | Function f -> binding := b; raise Exit
      | Unbound -> ());
    if buf.buf_map_partial then
      (let b = Keymap.get_binding buf.buf_location.loc_map keylist in
        match b with
          Prefix map -> binding := b;
        | Function f -> binding := b; raise Exit
        | Unbound -> ());
    !binding
  with
    Exit -> !binding
@

<<function Ebuffer.message>>=
let message buf m =
  let location = buf.buf_location in
  let name = "*Messages*" in
  try
    let buf = Hashtbl.find location.loc_buffers name in
    Text.insert_at_end buf.buf_text (m ^ "\n");
  with
    Not_found ->
      let buf = create location name None (Text.create (m^"\n")) (
          Keymap.create ())
      in ()
@

<<function Ebuffer.catch>>=
let catch format buf f =
  try
    f ()
  with e ->
      let location = buf.buf_location in
      let name = "*Messages*" in
      let m = Printf.sprintf format (Utils.printexn e) in
      try
        let buf = Hashtbl.find location.loc_buffers name in
        Text.insert_at_end buf.buf_text (m ^ "\n");
      with
        Not_found ->
          let buf = create location name None (Text.create (m^"\n")) (
              Keymap.create ())
          in ()
@

<<toplevel Ebuffer._1>>=
let _ =
  Efuns.add_start_hook 
    (fun location ->
      set_global location create_buf_hook [set_buffer_mode];
      set_global location modes_alist []
      )
@


%-------------------------------------------------------------

<<core/ebuffer.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Utils
open Efuns
open Text

<<constant Ebuffer.create_buf_hook>>
<<constant Ebuffer.modes_alist>>

<<function Ebuffer.create_syntax_table>>

<<constant Ebuffer.default_syntax_table>>

<<function Ebuffer.get_name>>

      
<<function Ebuffer.new_minor_mode>>
      
<<function Ebuffer.new_minor_mode (core/ebuffer.ml)>>

<<function Ebuffer.new_major_mode>>

<<constant Ebuffer.fondamental_mode>>
  
<<constant Ebuffer.tab_size>>

<<function Ebuffer.create>>

<<function Ebuffer.kill>>

open Options
  
<<constant Ebuffer.save_buffer_hooks>>
  
<<constant Ebuffer.saved_buffer_hooks>>

<<function Ebuffer.exec_named_buf_hooks>>

<<function Ebuffer.exec_named_buf_hooks_with_abort>>
      
<<function Ebuffer.save>>


<<exception Ebuffer.Found>>

  
<<function Ebuffer.read>>

<<function Ebuffer.default>>
      

<<function Ebuffer.compute_representation>>

<<exception Ebuffer.BufferAlreadyOpened>>

<<function Ebuffer.change_name>>
  
  
<<function Ebuffer.set_mark>>

<<function Ebuffer.get_mark>>

<<function Ebuffer.remove_mark>>

<<constant Ebuffer.modes_old>>
<<constant Ebuffer.regexp_alist>>

<<function Ebuffer.set_major_mode>>

<<function Ebuffer.set_minor_mode>>

<<function Ebuffer.del_minor_mode>>
  
<<function Ebuffer.modep>>

<<constant Ebuffer.suffix_reg>>
  
<<function Ebuffer.set_buffer_mode>>
      
<<function Ebuffer.get_binding>>

<<function Ebuffer.message>>

<<function Ebuffer.catch>>
          
      
<<toplevel Ebuffer._1>>
@


\subsection*{[[core/keymap.ml]]}

<<function Keymap.dummy_action>>=
let dummy_action frame = () 
@

<<function Keymap.unbound_key>>=
let unbound_key buffer _ = raise UnboundKey
@

<<function Keymap.create>>=
let create () =
  { char_map = Array.create 256 Unbound;
    complex_bindings = [];
    interactives = [];
  } 
@

<<function Keymap.print_key>>=
let print_key (map,keysym) =
  let prefix =
    match map with
      NormalMap -> ""
    | ControlMap -> "C-"
    | MetaMap -> "M-"
    | ControlMetaMap -> "CM-"
  in
  let kname =
    try
      List.assoc keysym XK.keysym_to_name
    with
      Not_found -> "?"
  in
  prefix^kname
@

<<function Keymap.print_key_list>>=
let rec print_key_list key_list =
  match key_list with
    key :: tail ->
      Printf.sprintf "%s %s" (print_key key) (print_key_list tail)
  | _ -> ""
@

<<function Keymap.print>>=
let print map =
  Printf.printf "MAP:\n";
  List.iter (fun (key, binding) ->
    (match binding with
      Prefix _ -> print_string "Prefix "; 
    | Function _ -> print_string "Function"
    | Unbound -> print_string "Unbound"
          );
    print_string (print_key key);
    print_newline ()
      ) map.complex_bindings
@

<<function Keymap.get_binding>>=
let rec get_binding map keylist =
  match keylist with
    [] -> Unbound
  | [key] ->
      begin
        match key with
          (NormalMap,key) when key >= 0 && key < 256 -> 
            map.char_map.(key)
        | _ -> 
            try
              List.assoc key map.complex_bindings
            with
              Not_found -> Unbound
      end
  | key :: tail ->
      match
        match key with
          (NormalMap,key) when key >= 0 && key < 256 -> 
            map.char_map.(key)
        | _ -> 
            try
              List.assoc key map.complex_bindings
            with
              Not_found -> Unbound
      with
        Prefix map -> get_binding map tail
      | _ -> Unbound
@

<<function Keymap.set_binding>>=
let set_binding map key binding =
  match key with
    (NormalMap,key) when key >= 0 && key < 256 -> 
      map.char_map.(key) <- binding
  | _ -> 
      map.complex_bindings <- (key,binding) :: map.complex_bindings
@

<<function Keymap.add_binding>>=
let rec add_binding map key_list binding =
  match key_list with
    [] -> failwith "ERROR add_complex_binding: empty key list"
  | [key] -> set_binding map key (Function binding)
  | key :: tail ->
      match
        match key with
          (NormalMap,key) when key >= 0 && key < 256 -> 
            map.char_map.(key)
        | _ -> 
            try
              List.assoc key map.complex_bindings
            with
              Not_found -> Unbound
      with
        Prefix map -> add_binding map tail binding
      | Unbound ->
          let newmap = create () in
          set_binding map key (Prefix newmap);
          add_binding newmap tail binding;
      | e -> 
          failwith "ERROR add_complex_binding: Unable to add prefix"
@

<<function Keymap.define_char_binding>>=
let define_char_binding map char (f : frame -> 'a) =
  add_binding map [NormalMap,Char.code char] f
@

<<constant Keymap.c_h>>=
let c_h = (ControlMap, Char.code 'h')
@

<<constant Keymap.c_x>>=
let c_x = (ControlMap, Char.code 'x')
@

<<constant Keymap.c_c>>=
let c_c = (ControlMap, Char.code 'c')
@

<<constant Keymap.n_5>>=
let n_5 = (NormalMap, Char.code '5')
@

<<function Keymap.all_bindings>>=
let all_bindings location =
  let s = ref "Default bindings:" in
  List.iter (fun (name,(_,binding)) ->
      match binding with
        None -> ()
      | Some key_list ->
          s := Printf.sprintf "%s\n%s : %s" !s 
            (print_key_list (List.rev key_list)) name
  ) location.loc_map.interactives;
  !s
@

<<function Keymap.interactive>>=
let interactive map keylist name f =
  map.interactives <- (name, (f, Some keylist)) :: map.interactives;
  add_binding map keylist f
@

<<function Keymap.add_interactive>>=
let add_interactive map name f =
    map.interactives <- (name, (f, None)) :: map.interactives
@

<<function Keymap.add_global_key>>=
let add_global_key location = interactive location.loc_map 
@

<<function Keymap.add_local_key>>=
let add_local_key buf = interactive buf.buf_map 
@

<<function Keymap.add_minor_key>>=
let add_minor_key minor = interactive minor.min_map 
@

<<function Keymap.add_major_key>>=
let add_major_key major = interactive major.maj_map 
@


%-------------------------------------------------------------

<<core/keymap.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

(*
La gestion des keymaps est inadapte'e a` la modification dynamique.
En effet, on aurait envie de pouvoir modifier les bindings selon divers
  crite`res, tels que le buffer (possible), le mode(pas possible).
*)


open Efuns

<<function Keymap.dummy_action>>
<<function Keymap.unbound_key>>

<<function Keymap.create>>

<<function Keymap.print_key>>
            
<<function Keymap.print_key_list>>

<<function Keymap.print>>
    
<<function Keymap.get_binding>>
          
          
<<function Keymap.set_binding>>

<<function Keymap.add_binding>>
          

<<function Keymap.define_char_binding>>
    
<<constant Keymap.c_h>>
<<constant Keymap.c_x>>
<<constant Keymap.c_c>>
<<constant Keymap.n_5>>

<<function Keymap.all_bindings>>
  
<<function Keymap.interactive>>

<<function Keymap.add_interactive>>

<<function Keymap.add_global_key>>
<<function Keymap.add_local_key>>
<<function Keymap.add_minor_key>>
<<function Keymap.add_major_key>>
  
@


\subsection*{[[core/minibuffer.ml]]}

<<constant Minibuffer.charreprs>>=
let charreprs = Array.init 256 (fun i ->   String.make 1 (Char.chr i))
@

<<toplevel Minibuffer._1>>=
let _ =
@

<<function Minibuffer.buf_create>>=
let buf_create location text local_map =
  let buf =
    { 
      buf_modified = 0;
      buf_text = text;
      buf_name = "*Minibuffer*";
      buf_filename = None;
      buf_last_saved = version text;
      buf_history = [];
      buf_charreprs = charreprs;
      buf_map = local_map;
      buf_map_partial = true;
      buf_point = Text.add_point text;
      buf_sync = false;
      buf_mark = None;
      buf_start = Text.add_point text;
      buf_shared = 0;
      buf_syntax_table = Ebuffer.default_syntax_table;
      buf_finalizers = [];
      buf_major_mode = fondamental_mode;
      buf_minor_modes = [];
      buf_vars = Local.vars ();
      buf_location = location;
    } in
  buf
@

<<function Minibuffer.kill>>=
let kill mini_frame old_frame =
  let window = mini_frame.frm_window in
  let top_window = Window.top window in
  let location = top_window.top_location in
  clear_message top_window;
  top_window.top_mini_buffers <- List.tl top_window.top_mini_buffers;
  if old_frame.frm_killed then
    Frame.unkill window old_frame;
  top_window.top_active_frame <- old_frame;
  Frame.kill mini_frame
@

<<function Minibuffer.return>>=
let return action old_frame mini_frame =
  let repstr = Text.to_string mini_frame.frm_buffer.buf_text in
  kill mini_frame old_frame;
  action old_frame repstr
@

<<function Minibuffer.create>>=
let create frame local_map request =
  let window = frame.frm_window in
  let top_window = Window.top window in
  let location = top_window.top_location in
  let mini_text = Text.create "" in
  let qlen = String.length request in
  let request = if qlen < 50 then request else
      (String.sub request 0 47 ^ "...") in
  let mini_buf = buf_create location mini_text local_map in
  let mini_window = Window.create true (TopWindow top_window) 
    qlen (top_window.top_height - 1)
    (top_window.top_width - qlen) 1 in
  let mini_frame = Frame.create mini_window (Some request) mini_buf
  in    
  mini_frame.frm_cutline <- max_int;
  mini_frame.frm_has_status_line <- 0;
  top_window.top_mini_buffers <- mini_frame :: top_window.top_mini_buffers;
  Keymap.add_binding local_map [ControlMap, Char.code 'g']
    (fun mini_frame -> 
      kill mini_frame frame);
  mini_frame
@

<<function Minibuffer.create_return>>=
let create_return frame local_map request default action =
  let mini_frame = create frame local_map request in
  insert_string mini_frame default;
  Keymap.add_binding local_map [NormalMap, XK.xk_Return] 
    (return action frame);
  mini_frame
@

<<function Minibuffer.update_request>>=
let update_request frame request =
  let qlen = String.length request in
  let window = frame.frm_window in
  let top_window = Window.top window in
  let mini_window = Window.create true window.win_up
      qlen window.win_ypos
      (top_window.top_width - qlen) 1
  in
  frame.frm_width <- top_window.top_width - qlen;
  frame.frm_xpos <- qlen;
  frame.frm_mini_buffer <- Some request;
  frame.frm_redraw <- true
@


%-------------------------------------------------------------

<<core/minibuffer.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Text
open Efuns
open Frame
open Ebuffer
open Top_window
open Simple


<<constant Minibuffer.charreprs>>
<<toplevel Minibuffer._1>>
  charreprs.(9) <- String.make !tab_size ' '

<<function Minibuffer.buf_create>>


<<function Minibuffer.kill>>

<<function Minibuffer.return>>

<<function Minibuffer.create>>

<<function Minibuffer.create_return>>

<<function Minibuffer.update_request>>
  
@


\subsection*{[[core/window.ml]]}

<<function Window.create_at_top>>=
let create_at_top xpos ypos width height =
  let rec window = {
    win_xpos = xpos;
    win_ypos = ypos;
    win_width = width;
    win_height = height;
    win_down = NoFrame (); 
    win_up = Window window;
    win_mini = false;
  } in
  window
@

<<function Window.create>>=
let create mini up_window xpos ypos width height =
  {
  win_xpos = xpos;
  win_ypos = ypos;
  win_width = width;
  win_height = height;
  win_down = NoFrame (); 
  win_up = up_window;
  win_mini = mini;
  }
@

<<function Window.top>>=
let top window = 
  let rec iter window =
    match window.win_up with
      TopWindow top_window -> top_window
    | Window window -> iter window
  in
  iter window
@

<<function Window.iter>>=
let iter f window = 
  let rec iter1 window =
    match window.win_down with
    | HComb (w1,w2) -> iter1 w1; iter1 w2       
    | VComb (w1,w2) -> iter1 w1; iter1 w2
    | WFrame frame -> f frame
    | NoFrame _ -> ()
  in
    iter1 window
@

<<function Window.first>>=
let rec first f window =
  match window.win_down with
    WFrame frame -> f frame
  | HComb (w1,w2) -> first f w1
  | VComb (w1,w2) -> first f w1
  | NoFrame _ -> ()
@

<<function Window.last>>=
let rec last f window =
  match window.win_down with
    WFrame frame -> f frame
  | HComb (w1,w2) -> last f w2
  | VComb (w1,w2) -> last f w2
  | NoFrame _ -> ()
@

<<function Window.next>>=
let rec next f window =
  match window.win_up with
    TopWindow top_window -> first f top_window.top_windows
  | Window win ->
      match win.win_down with
        HComb (w1,w2) ->
          if w2 == window then
            next f win
          else
            first f w2
      | VComb (w1,w2) ->
          if w2 == window then
            next f win
          else
            first f w2
      | _ -> ()
@

<<function Window.prev>>=
let rec prev f window =
  match window.win_up with
    TopWindow top_window -> 
      if window == top_window.top_windows then ()
      else 
        last f top_window.top_windows
  | Window win ->
      match win.win_down with
        HComb (w1,w2) ->
          if w1 == window then
            prev f win
          else
            last f w1
      | VComb (w1,w2) ->
          if w1 == window then
            prev f win
          else
            last f w1
      | _ -> ()
@

<<function Window.xterm>>=
let xterm top_window =
  match top_window.top_xterm with
    None -> raise Not_found
  | Some xterm -> xterm 
@

<<function Window.display>>=
let display top_window =
  match top_window.top_display with
    None -> raise Not_found
  | Some display -> display
@

<<function Window.get_font>>=
let get_font location font_name =
  try
    Hashtbl.find location.loc_fonts font_name
  with
    Not_found ->
      if location.loc_fonts_n = 256 then
        raise Not_found
      else
        let n = location.loc_fonts_n in
        location.loc_fonts_n <- n + 1;
        location.loc_fonts_names.(n) <- font_name;
        Hashtbl.add location.loc_fonts font_name n;
        n
@

<<function Window.get_color>>=
let get_color location color_name =
  try
    Hashtbl.find location.loc_colors color_name
  with
    Not_found ->
      if location.loc_colors_n = 256 then
        raise Not_found
      else
        let n = location.loc_colors_n in
        location.loc_colors_n <- n + 1;
        location.loc_colors_names.(n) <- color_name;
        Hashtbl.add location.loc_colors color_name n;
        n
@


%-------------------------------------------------------------

<<core/window.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Efuns

<<function Window.create_at_top>>

<<function Window.create>>

<<function Window.top>>

<<function Window.iter>>

<<function Window.first>>

<<function Window.last>>

<<function Window.next>>
      
<<function Window.prev>>

<<function Window.xterm>>

<<function Window.display>>

<<function Window.get_font>>
        
<<function Window.get_color>>
        
@


\subsection*{[[core/frame.ml]]}

<<constant Frame.status_format>>=
let status_format = ref [
    StatModified , (1, 2);
    StatName, (5, 20);
    StatMode, (30,30);
    StatLine, (65, 5);
    StatCol, (70 , 5);
    StatFile, (35,15);
  ]
@

<<function Frame.status_print>>=
let status_print status str stat_type =
  status.status_modified <- true;
  try
    let (pos,maxlen) = List.assoc stat_type status.status_format in
    let len = min (String.length str) maxlen in
    String.blit str 0 status.status_string pos len;
    String.fill status.status_string (pos + len) (maxlen - len) ' '
  with
    Not_found -> ()
@

<<function Frame.status_modified>>=
let status_modified frame modified =
  let status = frame.frm_status in
  if status.stat_modified <> modified then
    begin
      status_print status (if modified then "**" else "--") StatModified;
      status.stat_modified <- modified
    end
@

<<function Frame.status_col>>=
let status_col frame col =
  let status = frame.frm_status in
  if status.stat_col <> col then
    begin
      status.stat_col <- col;
      status_print status (Printf.sprintf "C%d" (col+1)) StatCol
    end
@

<<function Frame.print_list>>=
let rec print_list list =
  match list with
    [] -> ""
  | [ele] -> ele
  | ele :: ( (_ :: _) as tail) ->
      ele ^ " " ^ (print_list tail)
@

<<function Frame.status_major_mode>>=
let status_major_mode frame  =
  let buf = frame.frm_buffer in
  let status = frame.frm_status in
  if not (status.stat_modes == buf.buf_minor_modes &&
      status.stat_mode == buf.buf_major_mode
    ) then
    begin
      status.stat_modes <- buf.buf_minor_modes;
      status.stat_mode <- buf.buf_major_mode;
      status_print status (Printf.sprintf "(%s)" 
          (print_list
            (buf.buf_major_mode.maj_name ::
            (List.map (fun m -> m.min_name) status.stat_modes))))
      StatMode;
    end
@

<<function Frame.status_line>>=
let status_line frame line =
  let status = frame.frm_status in
  if status.stat_line <> line then
    begin
      status.stat_line <- line;
      status_print status (Printf.sprintf "L%d" (line+1)) StatLine
    end
@

<<function Frame.status_name>>=
let status_name frame name =
  let status = frame.frm_status in
  if status.stat_name <> name then
    begin
      status.stat_name <- name;
      status_print status name StatName
    end
@

<<function Frame.status_file>>=
let status_file frame name =
  let status = frame.frm_status in
  if status.stat_file <> name then
    begin
      status.stat_file <- name;
      status_print status name StatFile
    end
@

<<function Frame.kill>>=
let kill frame = 
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  frame.frm_killed <- true;
  buf.buf_shared <- buf.buf_shared - 1;
  Text.remove_point text buf.buf_point;
  Text.remove_point text buf.buf_start;
  buf.buf_point <- frame.frm_point;
  buf.buf_start <- frame.frm_start
@

<<function Frame.kill_all>>=
let kill_all window =
  Window.iter kill window
@

<<function Frame.install>>=
let install window frame =
  if window.win_mini = (frame.frm_mini_buffer = None) then
    (kill frame; failwith "Cannot install in minibuffer");
  Window.iter (fun f -> if not(f == frame) then kill f) window;
  window.win_down <- WFrame frame;
  frame.frm_xpos <- window.win_xpos;
  frame.frm_ypos <- window.win_ypos;
  frame.frm_width <- window.win_width;
  frame.frm_height <- window.win_height;
  frame.frm_window <- window;
  if frame.frm_cutline < max_int then
    frame.frm_cutline <- window.win_width - 1;
  frame.frm_table <- 
    (Array.init window.win_height (fun i -> 
        {
          repr_line = dummy_line;
          repr_y = 0;
          repr_x = 0;
          repr_prev_reprs = [];
          repr_prev_offset = 0;
          repr_offset = 0;
          repr_reprs = [];
        } ));
  frame.frm_redraw <- true
@

<<function Frame.resize>>=
let resize frame =
  let window = frame.frm_window in
  install window frame
@

<<constant Frame.editname>>=
let editname = "Efuns:"
@

<<constant Frame.dummy_mode>>=
let dummy_mode = Ebuffer.new_major_mode "" []
@

<<function Frame.create_without_top>>=
let create_without_top location window mini buf =
  let width = window.win_width in
  let height = window.win_height in
  let frm_start = Text.dup_point buf.buf_text buf.buf_start in
  let frm_end = Text.dup_point buf.buf_text buf.buf_start in
  let point = Text.dup_point buf.buf_text buf.buf_point in
  buf.buf_shared <- buf.buf_shared + 1;
  let status = {
      status_string = String.make 256 '-';
      status_modified = true;
      status_format = !status_format;
      stat_col = -1;
      stat_name = "";
      stat_file = "";
      stat_line = -1;
      stat_modified = (buf.buf_last_saved = version buf.buf_text);
      stat_modes = [];
      stat_mode = dummy_mode;
    } in
  String.blit editname 0 status.status_string 5 (String.length editname);
  let rec frame =
    { frm_buffer = buf;
      frm_location = location;
      frm_window = window;
      frm_last_text_updated = 0;
      frm_last_buf_updated = 0;
      
      frm_prefix = [];
      
      frm_repeat_action = 0;
      frm_last_action = Keymap.dummy_action;
      
      frm_start = frm_start;
      frm_end = frm_end;
      frm_y_offset = 0;
      frm_point = point;
      frm_cursor_x = 0;
      frm_cursor_y = 0;
      frm_cursor = String.make 1 ' ';
      frm_cursor_attr = Text.direct_attr;
      
      frm_force_point = true;
      frm_force_start = false;
      frm_force_cursor = false;
      
      frm_x_offset = 0;
      frm_cutline = width - 1;
      
      frm_has_scrollbar = 0;
      frm_has_status_line = 1;
      frm_status = status;
      
      frm_xpos = window.win_xpos;
      frm_ypos = window.win_ypos;
      frm_width = width;
      frm_height = height;
      frm_table = [||];
      frm_killed = false;
      frm_mini_buffer = mini;
      frm_redraw = true;
    } 
  in
  status_name frame buf.buf_name;
  status_major_mode frame;
  install window frame;
  frame
@

<<function Frame.active>>=
let active frame =
  let top_window = Window.top frame.frm_window in
  top_window.top_active_frame <- frame;
  match frame.frm_buffer.buf_filename with
    None -> ()
  | Some filename -> 
      frame.frm_location.loc_dirname <- Filename.dirname filename
@

<<function Frame.create>>=
let create window mini buf =
  let top_window = Window.top window in
  let frame = create_without_top top_window.top_location window mini buf in
  top_window.top_active_frame <- frame;
  frame
@

<<function Frame.create_inactive>>=
let create_inactive window buf =
  let top_window = Window.top window in
  let frame = create_without_top top_window.top_location window None buf in
  frame
@

<<function Frame.point_to_cursor>>=
let point_to_cursor buf point =
  let text = buf.buf_text in
  let line = Ebuffer.compute_representation buf (point_line text point) in
  let xpos = point_col text point in
  let rec iter reprs =
    match reprs with
      [] -> 0
    | repr :: tail ->
        if repr.repr_line_pos > xpos then
          iter tail
        else
          repr.repr_pos + repr.repr_charsize * (xpos - repr.repr_line_pos)
  in
  iter line.representation
@

<<function Frame.cursor_to_point>>=
let cursor_to_point frame x y =
  if (y < 0) || (x<0) ||
    (y >= frame.frm_height-1) || (x>frame.frm_cutline) then 
    raise Not_found
  else
  let line_repr = frame.frm_table.(y) in
  let y = line_repr.repr_y in
  let rec iter x reprs default =
    match reprs with
      [] -> default
    | repr :: tail -> 
        if repr.repr_size > x then
          repr.repr_line_pos + x / repr.repr_charsize
        else
          iter (x - repr.repr_size) tail 
            (repr.repr_line_pos + repr.repr_line_len)
  in
  let x = iter (x+frame.frm_x_offset+line_repr.repr_offset) 
    line_repr.repr_reprs 0 in
  x , y
@

<<function Frame.update_line>>=
let update_line top_window frame repr_string y = 
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let line_repr = frame.frm_table.(y) in
  let xterm = match top_window.top_xterm with
      None -> raise Not_found
    | Some xterm -> xterm 
  in
  let rec iter x offset reprs =
    if frame.frm_width > x then
      match reprs with
        [] -> 
          WX_xterm.clear_eol xterm 
            (x+frame.frm_xpos) (y+frame.frm_ypos)
          (frame.frm_width - x)
      | repr :: tail ->
          let len = min (frame.frm_width-x) (repr.repr_size - offset)
          in
          WX_xterm.draw_string xterm
            (x+frame.frm_xpos) (y+frame.frm_ypos)
          repr_string (repr.repr_pos+offset) len
            repr.repr_attr;
          iter (x+len) 0 tail
    else
      WX_xterm.draw_string xterm
        (frame.frm_width+frame.frm_xpos-1) (y+frame.frm_ypos)
      "/" 0 1 Text.direct_attr
  in
  iter 0 (line_repr.repr_offset+frame.frm_x_offset) line_repr.repr_reprs
@

<<function Frame.set_cursor>>=
let set_cursor frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let x = point_to_cursor buf point in
  let line = Ebuffer.compute_representation buf (point_line text point) in
  
  try
    for i = 0 to frame.frm_height - 1 do
      let line_repr = frame.frm_table.(i) in
      if line_repr.repr_line == line then
        let x,y =
          if x = 0 then 0,i
          else
            ((x-1) mod frame.frm_cutline) + 1, i + (x-1) / frame.frm_cutline
        in
        frame.frm_cursor_x <- x;
        frame.frm_cursor_y <- y;
        raise Exit
    done;      
    (* insert cursor is not on frame *)
    frame.frm_cursor.[0] <- '\000'
    
  with
    Exit -> 
      let rec iter reprs =
        match reprs with
          [] -> 
            frame.frm_cursor.[0] <- ' '
        | repr :: tail ->
            let point_x = point_col text point in
            if repr.repr_line_pos <= point_x &&
              repr.repr_line_pos + repr.repr_line_len > point_x then
              let pos =
                repr.repr_pos + repr.repr_charsize * 
                (point_x - repr.repr_line_pos)
              in
              frame.frm_cursor.[0] <- line.repr_string.[pos];
              frame.frm_cursor_attr <- repr.repr_attr;
            else
              iter tail
      in
      let repr_line = frame.frm_table.(frame.frm_cursor_y)
      in
      iter repr_line.repr_reprs
@

<<function Frame.update_table>>=
let update_table top_window frame =
  let buf =  frame.frm_buffer in
  let text = buf.buf_text in
  let start = frame.frm_start in
  let point = frame.frm_point in
  let width = frame.frm_width - frame.frm_has_scrollbar in
  let height = frame.frm_height - frame.frm_has_status_line in
(* assert frame.frm_y_offset >= 0 *)
  let current_n = ref (point_line text start) in
  let current_line = ref (compute_representation buf !current_n) in
  while frame.frm_y_offset < 0 && !current_n > 0 do
    current_n := !current_n - 1;
    current_line := compute_representation buf !current_n;
    let lines = !current_line.repr_len / frame.frm_cutline in
    frame.frm_y_offset <- frame.frm_y_offset + lines + 1;
  done;
  if !current_n = 0 && frame.frm_y_offset <0 then
    frame.frm_y_offset <- 0;
(* assert current_line is the first line *)
  while frame.frm_y_offset > !current_line.repr_len / frame.frm_cutline
      && !current_n < nbre_lines text
  do
    frame.frm_y_offset <- frame.frm_y_offset - 
    (!current_line.repr_len / frame.frm_cutline) - 1;
    current_n := !current_n + 1;
    current_line := compute_representation buf !current_n;
  done;
  if !current_n = nbre_lines text && 
    frame.frm_y_offset > !current_line.repr_len / frame.frm_cutline
  then
    frame.frm_y_offset <- !current_line.repr_len / frame.frm_cutline;
(* update frame.frm_start *)
  goto_line text start !current_n; 
(* update frame representation *)
  let rec iter_line y n line =
    if y < height then
      let reprs = List.rev line.representation in
      if y >= 0 then
        begin
          let line_repr = frame.frm_table.(y) in
          line_repr.repr_line <- line;
          line_repr.repr_y <- n;
          line_repr.repr_x <- 0;
          line_repr.repr_offset <- 0;
          line_repr.repr_reprs <- reprs;
        end;
      iter_repr frame.frm_cutline (y+1) n line reprs
    else
      goto_line text frame.frm_end (n-1)
  
  and iter_repr x y n line reprs =
    if x < line.repr_len then
      match reprs with
      | repr :: tail ->
          if repr.repr_pos <= x && 
            repr.repr_pos + repr.repr_size > x then
            if y = height then
              goto_line text frame.frm_end n 
            else
              begin
                if y>= 0 then
                  begin
                    let line_repr = frame.frm_table.(y) in
                    line_repr.repr_line <- line;
                    line_repr.repr_y <- n;
                    line_repr.repr_x <- repr.repr_pos;
                    line_repr.repr_offset <- x - repr.repr_pos;
                    line_repr.repr_reprs <- reprs;
                  end;
                iter_repr (x+frame.frm_cutline) (y+1) n line reprs
              end
          else
            iter_repr x y n line tail
      | _ -> 
          let line = compute_representation buf (n + 1) in
          iter_line (y+1) (n+1) line
    else  
    let line = compute_representation buf (n + 1) in
    iter_line y (n+1) line
  in
  iter_line (- frame.frm_y_offset) !current_n !current_line
@

<<function Frame.update>>=
let update top_window frame =
  let buf =  frame.frm_buffer in
  let text = buf.buf_text in
  let start = frame.frm_start in
  let point = frame.frm_point in
  let width = frame.frm_width - frame.frm_has_scrollbar in
  let height = frame.frm_height - frame.frm_has_status_line in
  if  buf.buf_sync && buf.buf_modified <> frame.frm_last_buf_updated then
    Text.set_position text point (Text.size text); 
  if
    (frame.frm_end < point)  || 
    (start > point) ||
    (version text <> frame.frm_last_text_updated) ||
    (buf.buf_modified <> frame.frm_last_buf_updated) ||
    frame.frm_redraw
  then
    begin
      let start_c = point_to_cursor buf start in
      if start_c > 0 then
        begin
          frame.frm_y_offset <- 
            frame.frm_y_offset - start_c / frame.frm_cutline;
          let _ = Text.bmove text start start_c in
          ()
        end;
      let point_c = point_to_cursor buf point in
      if point_c < frame.frm_x_offset then
        begin
          frame.frm_x_offset <- max (point_c - width / 2) 0;
          frame.frm_redraw <- true;
        end
      else
      if frame.frm_cutline = max_int && (point_c mod frame.frm_cutline >= frame.frm_x_offset + width - 3)  then
        begin
          frame.frm_x_offset <- point_c - (width / 2);
          frame.frm_redraw <- true;
        end;
      update_table top_window frame;
      begin
        if (frame.frm_end < point)  || (start > point)
        then
          begin
            if frame.frm_force_start then
              let x,y = 
                cursor_to_point frame frame.frm_cursor_x frame.frm_cursor_y
              in
              goto_line text frame.frm_point y;
              let _ = Text.fmove text frame.frm_point x in
              ()
            else
              begin
                goto_point text start point;
                frame.frm_y_offset <- - height / 2;
                let start_c = point_to_cursor buf start in
                if start_c > 0 then
                  begin
                    frame.frm_y_offset <- 
                      frame.frm_y_offset - start_c / frame.frm_cutline;
                    let _ = Text.bmove text start start_c in
                    ()
                  end;
                update_table top_window frame;
              end;
          end
      end;
      if frame == top_window.top_active_frame then
        begin
          frame.frm_force_start <- true; (* AVOID CYCLING IN SCROLLBAR *)
          let pos_start = get_position text frame.frm_start in
          let pos_end = get_position text frame.frm_end in
          top_window.top_scrollbar#set_params pos_start (pos_end - pos_start)
          (size text);
        end;
      frame.frm_last_text_updated <- version text;
      frame.frm_last_buf_updated <- buf.buf_modified;
      frame.frm_force_start <- false;
      for y = 0 to height - 1 do
        let line = frame.frm_table.(y) in
        if not ((line.repr_prev_reprs == line.repr_reprs) &&
            (line.repr_prev_offset == line.repr_offset)) 
          || frame.frm_redraw
        then
          begin
            line.repr_prev_reprs <- line.repr_reprs;
            line.repr_prev_offset <- line.repr_offset;
            update_line top_window frame line.repr_line.repr_string y;
          end;
      done;
      frame.frm_redraw <- false
    end;
  let xterm = match top_window.top_xterm with
      None -> raise Not_found
    | Some xterm -> xterm 
  in
  match frame.frm_mini_buffer with
    None -> 
      let status = frame.frm_status in
      status_line frame (point_line text frame.frm_point);
      status_col frame (point_col text frame.frm_point);
      status_modified frame (version text <> buf.buf_last_saved);
      status_name frame buf.buf_name;
      status_major_mode frame;
      if status.status_modified then
        WX_xterm.draw_string xterm frame.frm_xpos
          (frame.frm_ypos + frame.frm_height - 1) 
        status.status_string 0 width Text.inverse_attr
  | Some request ->
      WX_xterm.draw_string xterm 0 (top_window.top_height-1) 
      request 0 (String.length request) Text.direct_attr
@

<<exception Frame.BufferKilled>>=
exception BufferKilled
@

<<function Frame.unkill>>=
let unkill window frame =
  let buf = frame.frm_buffer  in
  if buf.buf_shared < 0 then raise BufferKilled;
  let text = buf.buf_text in
  install window frame;
  frame.frm_start <- Text.dup_point text buf.buf_start;
  frame.frm_end <- Text.dup_point text buf.buf_start;
  frame.frm_point <- Text.dup_point text buf.buf_point;
  frame.frm_y_offset <- 0;
  buf.buf_shared <- buf.buf_shared + 1;
  frame.frm_killed <- false
@

<<function Frame.move_point>>=
let move_point frame point x y =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let x, y = cursor_to_point frame (x - frame.frm_xpos) (y - frame.frm_ypos) in
  goto_line text point y;
  let _ = fmove text point x in
  ()
@

<<function Frame.current_dir>>=
let current_dir frame =
  let buf = frame.frm_buffer in
  match buf.buf_filename with
    Some filename -> Filename.dirname filename ^ "/"
  | None -> buf.buf_location.loc_dirname ^ "/"
@

<<exception Frame.FoundFrame>>=
exception FoundFrame of frame
@

<<function Frame.find_buffer_frame>>=
let find_buffer_frame location buf =
  try
    List.iter (fun top_window ->
        Window.iter (fun frame -> 
            if frame.frm_buffer == buf then raise (FoundFrame frame))
        top_window.top_windows
    ) location.loc_windows;
    raise Not_found
  with
    FoundFrame frame -> frame
@

<<constant Frame.change_buffer_hooks>>=
let change_buffer_hooks = define_option ["change_buffer_hooks"] "" 
    (list_option string_option)
  [ "check_file" ]
@

<<function Frame.exec_named_hooks>>=
let rec exec_named_hooks hooks frame =
  match hooks with
    [] -> ()
  | action :: hooks ->
      exec_named_hooks hooks frame;
      try execute_action action frame with _ -> ()
@

<<function Frame.exec_named_hooks_with_abort>>=
let rec exec_named_hooks_with_abort hooks frame =
  match hooks with
    [] -> ()
  | action :: hooks ->
      exec_named_hooks_with_abort hooks frame;
      execute_action action frame
@

<<function Frame.load_file>>=
let load_file window filename =
  let top_window = Window.top window in
  let location = top_window.top_location in
  let buf = Ebuffer.read location filename (Keymap.create ()) in
  let frame = create window None buf 
  in
  exec_named_hooks !!change_buffer_hooks frame;
  status_name frame buf.buf_name;
  frame
@

<<function Frame.change_buffer>>=
let change_buffer window name = 
  let top_window = Window.top window in
  let location = top_window.top_location in
  try
    let buf = Hashtbl.find location.loc_buffers name in
    let frame = create window None  buf 
    in
    exec_named_hooks !!change_buffer_hooks frame;
    status_name frame buf.buf_name
  with
    Not_found -> ()
@

<<function Frame.save_buffer>>=
let save_buffer frame =
  Ebuffer.save frame.frm_buffer
@

<<function Frame.bindings_help>>=
let bindings_help frame =
  let window = frame.frm_window in
  change_buffer window "*bindings*"
@


%-------------------------------------------------------------

<<core/frame.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Options
open Text
open Efuns
open Ebuffer

<<constant Frame.status_format>>

<<function Frame.status_print>>


<<function Frame.status_modified>>

<<function Frame.status_col>>

<<function Frame.print_list>>

<<function Frame.status_major_mode>>

<<function Frame.status_line>>

<<function Frame.status_name>>

<<function Frame.status_file>>

<<function Frame.kill>>

<<function Frame.kill_all>>

<<function Frame.install>>

<<function Frame.resize>>

<<constant Frame.editname>>
<<constant Frame.dummy_mode>>
  
<<function Frame.create_without_top>>

<<function Frame.active>>
      
      
<<function Frame.create>>

<<function Frame.create_inactive>>


<<function Frame.point_to_cursor>>

<<function Frame.cursor_to_point>>


<<function Frame.update_line>>

<<function Frame.set_cursor>>

<<function Frame.update_table>>


<<function Frame.update>>

<<exception Frame.BufferKilled>>
<<function Frame.unkill>>

<<function Frame.move_point>>

<<function Frame.current_dir>>


<<exception Frame.FoundFrame>>

<<function Frame.find_buffer_frame>>

<<constant Frame.change_buffer_hooks>>

<<function Frame.exec_named_hooks>>

<<function Frame.exec_named_hooks_with_abort>>

<<function Frame.load_file>>

  
<<function Frame.change_buffer>>

<<function Frame.save_buffer>>

<<function Frame.bindings_help>>
  
@


\section{[[features/]]}

\subsection*{[[features/simple.ml]]}

<<function Simple.string_to_modifier>>=
let string_to_modifier s =  
  let mask = ref 0 in
  for i = 0 to String.length s - 1 do
    mask := !mask lor (match s.[i] with
      | 'C' -> controlMask
      | 'A' -> mod1Mask
      | 'M' -> mod1Mask
      | '1' -> mod1Mask
      | _ -> 0
    )
  done;
  !mask
@

<<function Simple.modifier_to_string>>=
let modifier_to_string mask = 
  let s = if mask land shiftMask = 0 then "" else "S" in
  let s = if mask land controlMask = 0 then s else "C" ^ s in
  let s = if mask land mod1Mask = 0 then s else "M" ^ s in
  let s = if mask land mod2Mask = 0 then s else "2" ^ s in
  let s = if mask land mod3Mask = 0 then s else "3" ^ s in
  let s = if mask land mod4Mask = 0 then s else "4" ^ s in
  let s = if mask land mod5Mask = 0 then s else "5" ^ s in
  s
@

<<constant Simple.name_to_keysym>>=
let name_to_keysym = 
  ("Button1", XK.xk_Pointer_Button1) ::
  ("Button2", XK.xk_Pointer_Button2) ::
  ("Button3", XK.xk_Pointer_Button3) ::
  ("Button4", XK.xk_Pointer_Button4) ::
  ("Button5", XK.xk_Pointer_Button5) ::
  XK.name_to_keysym
@

<<function Simple.value_to_keysym>>=
let value_to_keysym v =
  match v with
    Value v -> List.assoc v name_to_keysym
  | _ -> raise Not_found
@

<<function Simple.keysym_to_value>>=
let keysym_to_value k =
  Value (List.assoc k XK.keysym_to_name)
@

<<function Simple.value_to_key>>=
let value_to_key v =
  match v with 
    Value s -> 
      let key, mods = 
        try
          let index = String.index s '-' in
          let mods = String.sub s 0 index in
          let key = String.sub s (index+1) (String.length s - index - 1) in
          key, mods
        with _ -> s, ""
      in
      let key = List.assoc key name_to_keysym in
      let mods = string_to_modifier mods in
      let map = 
        if mods land (controlMask lor mod1Mask) = (controlMask lor mod1Mask)
        then ControlMetaMap else
        if mods land controlMask <> 0 then ControlMap else
        if mods land mod1Mask <> 0 then MetaMap else NormalMap
      in
      map, key
      
  | _ -> raise Not_found
@

<<function Simple.key_to_value>>=
let key_to_value k = Value (Keymap.print_key k)
@

<<constant Simple.key_option>>=
let key_option = define_option_class "Key" value_to_key key_to_value
@

<<constant Simple.binding_option>>=
let binding_option = tuple2_option (smalllist_option key_option, string_option)
@

<<function Simple.insert_string>>=
let insert_string frame str =
  let text = frame.frm_buffer.buf_text in
  let point = frame.frm_point in
  let _ = Text.insert text point str in
  let _ = Text.fmove text point (String.length str) in ()
@

<<constant Simple.single_char>>=
let single_char = String.make 1 ' '
@

<<function Simple.insert_char>>=
let insert_char frame char =
  let text = frame.frm_buffer.buf_text in
  let point = frame.frm_point in
  single_char.[0] <- char;
  let _ = Text.insert text point single_char in
  let _ = Text.fmove text point 1 in () 
@

<<function Simple.insert_return>>=
let insert_return frame =
  insert_char frame '\n'
@

<<function Simple.previous_char>>=
let previous_char frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  if bmove_res text point 1 = 0 then raise Not_found;
  let c = get_char text point in
  let _ = fmove text point 1 in
  c
@

<<function Simple.unset_attr>>=
let unset_attr frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  Text.unset_attr text
@

<<function Simple.insert_at_place>>=
let insert_at_place frame char =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let c = get_char text point in
  if c = '\n' then
    insert_char frame char
  else
  let session = start_session text in
  let _ = Text.delete text point 1 in
  single_char.[0] <- char;    
  let _ = Text.insert text point single_char in
  let _ = fmove text point 1 in ()
@

<<constant Simple.overwrite_mode>>=
let overwrite_mode = Ebuffer.new_minor_mode "Over" []
@

<<function Simple.self_insert_command>>=
let self_insert_command frame =
  let char = Char.chr !keypressed in
  let buf = frame.frm_buffer in
  if Ebuffer.modep buf overwrite_mode then 
    insert_at_place frame char
  else
    insert_char frame char
@

<<function Simple.char_insert_command>>=
let char_insert_command char frame =
  let buf = frame.frm_buffer in
  if Ebuffer.modep buf overwrite_mode then 
    insert_at_place frame char
  else
    insert_char frame char
@

<<function Simple.move_backward>>=
let move_backward frame delta =
  let text = frame.frm_buffer.buf_text in
  Text.bmove text frame.frm_point delta
@

<<function Simple.move_forward>>=
let move_forward frame delta =
  let text = frame.frm_buffer.buf_text in
  Text.fmove text frame.frm_point delta
@

<<function Simple.begin_to_point>>=
let begin_to_point frame =
  let text = frame.frm_buffer.buf_text in
  let point = frame.frm_point in
  Text.point_to_bol text point
@

<<function Simple.point_to_end>>=
let point_to_end frame =
  let text = frame.frm_buffer.buf_text in
  let point = frame.frm_point in
  Text.point_to_eol text point
@

<<function Simple.line_size>>=
let line_size frame =
  (point_to_end frame) + (point_to_end frame)
@

<<function Simple.beginning_of_line>>=
let beginning_of_line frame =
  let _ = move_backward frame (begin_to_point frame) in ()
@

<<function Simple.end_of_line>>=
let end_of_line frame =
  let eol = point_to_end frame in
  let _ = move_forward frame eol in ()
@

<<function Simple.forward_line>>=
let forward_line frame =
  let text = frame.frm_buffer.buf_text in
  let point = frame.frm_point in
  if point_line text point < nbre_lines text then
    if point_to_end frame = 0 then
      begin
        let _ = move_forward frame 1 in
        end_of_line frame; ()
      end
    else
    let old_x = begin_to_point frame in
    end_of_line frame;
    let _ = move_forward frame 1 in
    let _ = move_forward frame (min old_x (point_to_end frame)) in ()
@

<<function Simple.backward_line>>=
let backward_line frame =
  let text = frame.frm_buffer.buf_text in
  let point = frame.frm_point in
  if point_line text point > 0 then
    let old_x = begin_to_point frame in
    beginning_of_line frame;
    let _ = move_backward frame 1 in
    beginning_of_line frame;
    let _ = move_forward  frame (min old_x (point_to_end frame)) in ()
@

<<constant Simple.kill_size>>=
let kill_size = ref 0
@

<<constant Simple.kill_max>>=
let kill_max = 10
@

<<constant Simple.kill_ring>>=
let kill_ring = Array.create kill_max ""
@

<<constant Simple.last_kill>>=
let last_kill = ref None
@

<<constant Simple.last_insert>>=
let last_insert = ref None
@

<<function Simple.kill_string>>=
let kill_string str =
  Array.blit kill_ring 0 kill_ring 1 (kill_max - 1);
  incr kill_size;
@

<<function Simple.kill_text>>=
let kill_text text point len =
  let point,str = Text.delete_res text point len in
  match !last_kill with
  | Some (oldtext,oldpoint) when
    oldpoint = point && oldtext == text ->
      kill_ring.(0) <- kill_ring.(0)^str
  | _ ->
      last_kill := Some (text,point);
      kill_string str
@

<<function Simple.kill_end_of_line>>=
let kill_end_of_line frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let eol = point_to_end frame in
  let len =
    if eol = 0 then 1 else eol
  in
  kill_text text frame.frm_point len
@

<<function Simple.kill_eol>>=
let kill_eol buf point =
  let text = buf.buf_text in
  let eol = point_to_eol text point in
  let len =
    if eol = 0 then 1 else eol
  in
  kill_text text point len
@

<<function Simple.kill_bol>>=
let kill_bol buf point =
  let text = buf.buf_text in
  let len = point_to_bol text point in
  if len > 0 then
    ( bmove text point len;
      kill_text text point len)
@

<<function Simple.insert_killed>>=
let insert_killed frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let pos, len =  Text.insert_res text point kill_ring.(0) in
  fmove text point len; 
  last_insert := Some(frame,pos,0,len)
@

<<function Simple.insert_next_killed>>=
let insert_next_killed frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  match !last_insert with
  |  Some (oldframe,oldpoint,n,len) when 
    oldframe == frame && oldpoint + len = get_position text point ->
      let n = if n = (min !kill_size kill_max) - 1 then 0 else n+1 in
      bmove text point len;
      let _ = Text.delete text point len in
      let pos, len =  Text.insert_res text point kill_ring.(n) in
      fmove text point len;
      last_insert := Some(frame,pos,n,len)
  | _ -> ()
@

<<function Simple.format_to>>=
let format_to frame =
  let point = frame.frm_point in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  Format.set_formatter_output_functions 
    (fun str pos len ->
      let s = String.sub str pos len in
      let _ = Text.insert text point s in
      Text.fmove text point len)
  (fun () -> ())
@

<<function Simple.format_to_string>>=
let format_to_string () =
  let string = ref "" in
  Format.set_formatter_output_functions 
    (fun str pos len ->
      let s = String.sub str pos len in
      string := !string ^ s)
  (fun () -> ());
  string
@

<<function Simple.in_next_word>>=
let in_next_word text mark syntax =
  while (not syntax.(Char.code (get_char text mark))) &&
    fmove_res text mark 1 = 1 do () done
@

<<function Simple.in_prev_word>>=
let in_prev_word text mark syntax =
  while bmove_res text mark 1 = 1 &&
    (not syntax.(Char.code (get_char text mark)))
  do () done
@

<<function Simple.to_begin_of_word>>=
let to_begin_of_word text mark syntax =
  if bmove_res text mark 1 = 1 then
    begin
      while syntax.(Char.code (Text.get_char text mark)) &&
        (bmove_res text mark 1) <> 0 do ()
      done;
      if not syntax.(Char.code (Text.get_char text mark)) then
        (fmove text mark 1)
    end
@

<<function Simple.to_end_of_word>>=
let to_end_of_word text mark syntax =
  while syntax.(Char.code (get_char text mark)) &&
    (fmove_res text mark 1) <> 0 do ()
  done
@

<<function Simple.to_frame>>=
let to_frame f frame =
  f frame.frm_buffer frame.frm_point
@

<<function Simple.backward_word>>=
let backward_word buf point =
  let text = buf.buf_text in
  let syntax = buf.buf_syntax_table in
  in_prev_word text point syntax;
  to_begin_of_word text point syntax
@

<<function Simple.forward_word>>=
let forward_word buf point =
  let text = buf.buf_text in
  let syntax = buf.buf_syntax_table in
  in_next_word text point syntax;
  to_end_of_word text point syntax
@

<<function Simple.beginning_of_word>>=
let beginning_of_word buf point =
  let text = buf.buf_text in
  let syntax = buf.buf_syntax_table in
  let mark = dup_point text point in
  to_begin_of_word text mark syntax;
  let s = Text.region text mark point in
  Text.remove_point text mark;
  s
@

<<function Simple.end_of_word>>=
let end_of_word  buf point =
  let text = buf.buf_text in
  let syntax = buf.buf_syntax_table in
  let mark = dup_point text point in
  to_end_of_word text mark syntax;
  let s = Text.region text point mark in
  Text.remove_point text mark;
  s
@

<<function Simple.current_word>>=
let current_word buf point =
  let text = buf.buf_text in
  let syntax = buf.buf_syntax_table in
  let start = dup_point text point in
  to_begin_of_word text start syntax;
  let term = dup_point text point in
  to_end_of_word text term syntax;
  let word = Text.region text start term in
  remove_point text start;
  remove_point text term;
  word
@

<<function Simple.current_word (features/simple.ml)>>=
let current_word buf point =
  (beginning_of_word buf point) ^ (end_of_word buf point)
@

<<function Simple.dirname>>=
let dirname frame filename =
  let filename =
    if Filename.is_relative filename then
      Filename.concat (Frame.current_dir frame) filename
    else
      filename
  in
  Filename.dirname filename
@

<<function Simple.buffer_list>>=
let buffer_list frame =
  let top_window = Window.top frame.frm_window in
  let location = top_window.top_location in
  let list = ref [] in
  Hashtbl.iter (fun name _ -> list := name :: !list) location.loc_buffers;
  !list
@

<<function Simple.delete_char>>=
let delete_char frame =
  let text = frame.frm_buffer.buf_text in
  let _ = Text.delete text frame.frm_point 1 in
  ()
@

<<function Simple.delete_backspace_char>>=
let delete_backspace_char frame =
  let text = frame.frm_buffer.buf_text in
  if Text.bmove_res text frame.frm_point 1 <> 0 then
    let _ = Text.delete text frame.frm_point 1 in
      ()
@

<<function Simple.hungry_char>>=
let hungry_char c = 
  c = ' ' || c = '\n' || c = '\t'
@

<<function Simple.hungry_electric_delete>>=
let hungry_electric_delete frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let session = start_session text in
  let c1 = previous_char frame in
  delete_backspace_char frame;
  let c2 = previous_char frame in
  begin
    if hungry_char c1 && hungry_char c2 then
      try
        delete_backspace_char frame;
        while 
          let c = previous_char frame in
          hungry_char c        
        do
          delete_backspace_char frame
        done;
        insert_char frame ' '
      with
        Not_found -> ()
  end;
  commit_session text session
@

<<function Simple.forward_screen>>=
(*
     let move_backward frame =
   Functions.move_backward frame 1; ()

let move_forward frame = 
  Functions.move_forward frame 1; () 
*) 

let forward_screen frame =
  frame.frm_force_start <- true;
  frame.frm_redraw <- true;
  frame.frm_y_offset <- frame.frm_y_offset + frame.frm_height - 2
@

<<function Simple.backward_screen>>=
let backward_screen frame =
  frame.frm_force_start <- true;
  frame.frm_redraw <- true;
  frame.frm_y_offset <- frame.frm_y_offset - frame.frm_height + 2
@

<<function Simple.scroll_line>>=
let scroll_line frame n =
  frame.frm_force_start <- true;
  frame.frm_redraw <- true;
  frame.frm_y_offset <- frame.frm_y_offset + n
@

<<function Simple.recenter>>=
let recenter frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  frame.frm_force_start <- true;
  frame.frm_redraw <- true;
  goto_point text frame.frm_start frame.frm_point;
  frame.frm_y_offset <- - frame.frm_height/2
@

<<function Simple.end_of_file>>=
let end_of_file frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  Text.set_position text frame.frm_point (Text.size text)
@

<<function Simple.begin_of_file>>=
let begin_of_file frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  Text.set_position text frame.frm_point 0
@

<<function Simple.delete_backward_word>>=
let delete_backward_word buf point =
  let text = buf.buf_text in
  let old_point = dup_point text point in
  backward_word buf point;
  let _ = Text.delete text point (Text.distance text point old_point) in
  remove_point text old_point;
  ()
@

<<function Simple.delete_forward_word>>=
let delete_forward_word buf point =
  let text = buf.buf_text in
  let old_point = dup_point text point in
  forward_word buf point;
  let len = Text.distance text old_point point in
  remove_point text old_point;
  Text.bmove text point len;
  let _ = Text.delete text point len in
  ()
@

<<function Simple.undo>>=
let undo frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in  
  let point = frame.frm_point in
  let action, at_point, len = Text.undo text in
  frame.frm_last_text_updated <- version text - 1;
  Text.set_position text point at_point;
  Text.fmove text point len; ()
@

<<function Simple.kill_region>>=
let kill_region frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let mark =
    match buf.buf_mark with
      None -> failwith "No mark set"
    | Some mark -> mark
  in
  let (start,term) = 
    if mark > point then (point,mark) else (mark,point)
  in
  let _,region = Text.delete_res text start (distance text start term) in
  kill_string region
@

<<function Simple.mouse_set_frame>>=
let mouse_set_frame frame =
  let top_window = Window.top frame.frm_window in
  let frame = mouse_set_active top_window in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let mark = Ebuffer.get_mark buf point in
  goto_point text mark point;
  ()
@

<<constant Simple.highlighted>>=
(* hightlighting of regions *)  
let highlighted = ref None
@

<<constant Simple.highlight_bit>>=
let highlight_bit = 1 lsl 24
@

<<function Simple.unhightlight_region>>=
let unhightlight_region buf debut fin =
  let text = buf.buf_text in
  let curseur = add_point text in
  let final = add_point text in
  set_position text curseur debut;
  set_position text final fin;
  let unhigh = lnot (1 lsl 24) in
  while curseur < final do
    let attr = get_attr text curseur in
    set_char_attr text curseur (attr land unhigh);
    fmove text curseur 1;
  done;
  remove_point text curseur;
  remove_point text final;
  buf.buf_modified <- buf.buf_modified + 1
@

<<function Simple.hightlight_region>>=
let hightlight_region buf debut fin =
  let text = buf.buf_text in
  let curseur = add_point text in
  let final = add_point text in
  set_position text curseur debut;
  set_position text final fin;
  let high = 1 lsl 24 in
  while curseur < final do
    let attr = get_attr text curseur in
    set_char_attr text curseur (attr lor high);
    fmove text curseur 1
  done;
  remove_point text curseur;
  remove_point text final;
  buf.buf_modified <- buf.buf_modified + 1
@

<<constant Simple.highlighted_chars>>=
let highlighted_chars = ref []
@

<<function Simple.unhightlight>>=
let unhightlight location =
  List.iter (fun (buf,curseur,attr) ->
      let text = buf.buf_text in
      set_char_attr text curseur attr;
      buf.buf_modified <- buf.buf_modified + 1;
      remove_point text curseur
  ) !highlighted_chars;
  highlighted_chars := [];
    match !highlighted with
      None -> ()
    | Some (frame,debut,fin) -> 
        if !keypressed <> XK.xk_Pointer_Drag1 then
          let top_window = Window.top frame.frm_window in
          let xterm = Window.xterm top_window in
          highlighted := None;
          
          let buf = frame.frm_buffer in
          let text = buf.buf_text in
          let curseur = add_point text in
          let final = add_point text in
          set_position text curseur debut;
          set_position text final fin;
          let str = Text.region text curseur final in
          remove_point text curseur;
          remove_point text final;
          kill_string str;
          WX_xterm.set_cutbuffer xterm str;
          unhightlight_region buf debut fin
@

<<function Simple.highlight>>=
let highlight frame =
  let frame =
    match !highlighted with
      None -> frame
    | Some (frame,d,f) -> frame
  in    
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  let text = buf.buf_text in
  let mark = Ebuffer.get_mark buf point in
  let debut, fin =
    if point < mark then
      point,mark
    else
      mark,point
  in
  let pos1 = get_position text debut in
  let pos2 = get_position text fin in
  let debut,fin =
    match !highlighted with
      None -> pos1,pos2
    | Some (frame,d,f) ->
        if d < pos1 then    
          unhightlight_region buf d pos1; 
        if f > pos2 then
          unhightlight_region buf pos2 f;
        if pos1 < d then
          pos1,d
        else
        if pos2 > f then
          f, pos2
        else
          pos1,pos1
  in
  highlighted := Some (frame, pos1, pos2);
  hightlight_region buf debut fin
@

<<constant Simple.htmlp>>=
let htmlp = ref false
@

<<function Simple.is_paren_end>>=
let is_paren_end c = (c == '}') || (c == ']') || (c == ')')
  ||  (!htmlp && c == '>')
@

<<function Simple.is_paren_begin>>=
let is_paren_begin c = (c == '{') || (c == '[') || (c == '(')
  ||  (!htmlp && c == '<')
@

<<function Simple.highlight_paren>>=
let highlight_paren frame =
  htmlp := (!keypressed = Char.code '>');
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let curseur = dup_point text point in
  if bmove_res text curseur 1 = 0 then remove_point text curseur
  else
  let c = get_char text curseur in
  if not(is_paren_end c) then remove_point text curseur 
  else
  let rec iter stack =
    if bmove_res text curseur 1 = 0 then
      begin
        remove_point text curseur;
        Top_window.mini_message frame "No matching parenthesis"
      end
    else
    let d = get_char text curseur in
    if is_paren_end d then
      begin
        iter (d :: stack)
      end
    else
    if is_paren_begin d then
      match stack with
        [] -> (* found matching par *)
          let attr = get_attr text curseur in
          highlighted_chars := (buf,curseur,attr) :: !highlighted_chars;
          set_char_attr text curseur (attr lor (1 lsl 24));
          buf.buf_modified <- buf.buf_modified + 1
      | _ :: stack -> (* don't try to match *)
          iter stack
    else
      iter stack
  in
  iter []
@

<<function Simple.mouse_drag_region>>=
let mouse_drag_region frame =
  let top_window = Window.top frame.frm_window in
  let point = frame.frm_point in
  begin
    try
      move_point frame point !mouse_x !mouse_y
    with
      Not_found ->
        let buf = frame.frm_buffer in
        let text = buf.buf_text in
        let y = !mouse_y - frame.frm_ypos in
        if y < 0 then
          ( scroll_line frame (y-1);
            goto_point text point frame.frm_start;
            bmove text point 1; ())
        else
        if y >= frame.frm_height - 1 then
          (
            scroll_line frame (y - frame.frm_height + 2);
            goto_point text point frame.frm_end;
            fmove text point 1; ())
  end;
  highlight frame;
  let top_window = Window.top frame.frm_window in
  let xterm = top_window.top_term in
  Selection.setSelection xterm#display xterm#window XA.xa_primary
    (fun target ->
      if target = XA.xa_string then 
        match !highlighted with
          None -> raise Not_found
        | Some (frame,debut,fin) -> 
            let buf = frame.frm_buffer in
            let text = buf.buf_text in
            let curseur = add_point text in
            let final = add_point text in
            set_position text curseur debut;
            set_position text final fin;
            let str = Text.region text curseur final in
            remove_point text curseur;
            remove_point text final;
            
            1, str
      else raise Not_found
  ) !Eloop.event_time
@

<<function Simple.mouse_yank_at_click>>=
let  mouse_yank_at_click frame =
  let top_window = Window.top frame.frm_window in
  let frame = mouse_set_active top_window in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let xterm = Window.xterm top_window in
  let str = WX_xterm.get_cutbuffer xterm in
  let _ = Text.insert text point str in
  Text.fmove text point (String.length str)
@

<<function Simple.mouse_save_then_kill>>=
let mouse_save_then_kill frame =
  let top_window = Window.top frame.frm_window in
  let frame = Top_window.find_selected_frame top_window in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let mark = Ebuffer.get_mark buf point in
  let new_point = add_point text in
  Frame.move_point frame new_point !mouse_x !mouse_y;
  if point = new_point then
    begin
      remove_point text new_point;
      let (start,term) =
        if point < mark then (point,mark) else (mark,point) 
      in
      let _ = Text.delete text start (Text.distance text start term) in
      ()
    end
  else
  let xterm = Window.xterm top_window in
  goto_point text mark point;
  goto_point text point new_point;
  remove_point text new_point;
  let str = Text.region text mark point in
  kill_string str;
  WX_xterm.set_cutbuffer xterm str;
  highlight frame
@

<<function Simple.next_buffer>>=
let next_buffer location buf =
  let buf_list = Utils.list_of_hash location.loc_buffers in
  let rec iter list =
    match list with
      [] -> raise Not_found 
    | (name,b) :: tail ->
        if b == buf then 
          match tail with
            [] -> snd (List.hd buf_list)
          | (_,b)::_ -> b
        else
          iter tail
  in
  iter buf_list
@

<<function Simple.kill_buffer>>=
let kill_buffer frame =
  let window = frame.frm_window in
  let top_window = Window.top window in
  let location = top_window.top_location in
  let buf = frame.frm_buffer in
  let new_buf = next_buffer location buf in
  let new_frame = Frame.create window None new_buf in
  if buf.buf_shared = 0 then Ebuffer.kill location buf
@

<<function Simple.color>>=
let color buf regexp strict attr =
  let text = buf.buf_text in
  let point = Text.add_point text in
  try
    while true do
      let len = Text.search_forward text regexp point in
      let before =
        if Text.bmove_res text point 1 = 1 then
          (let c = Text.get_char text point in
            Text.fmove text point (len+1);c)
        else
          (let c = Text.get_char text point in
            Text.fmove text point (len+1); c)
      in
      let after = Text.get_char text point in
      if not (strict && (buf.buf_syntax_table.(Char.code before) ||
            buf.buf_syntax_table.(Char.code after))) then
        begin
          bmove text point len;
          Text.set_attr text point len attr;
          fmove text point len;
          ()
        end
    done
  with
    Not_found -> 
      Text.remove_point text point;
      buf.buf_modified <- buf.buf_modified + 1
@

<<function Simple.point_at_mark>>=
let point_at_mark frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let mark = Ebuffer.get_mark buf point in
  let point_pos = get_position text point in
  goto_point text point mark;
  set_position text mark point_pos
@

<<function Simple.on_word>>=
let on_word buf point f =
  let text = buf.buf_text in
  let session = start_session text in
  let syntax = buf.buf_syntax_table in
  to_begin_of_word text point syntax;
  let pos1 = dup_point text point in
  to_end_of_word text point syntax;
  let _,word1 = Text.delete_res text pos1 (distance text pos1 point) in
  let w = f word1 in
  let _ = Text.insert text pos1 w in
  fmove text point (String.length w);
  commit_session text session;
  remove_point text pos1
@

<<function Simple.transpose_words>>=
let transpose_words buf point =
  let text = buf.buf_text in
  let session = start_session text in
  let syntax = buf.buf_syntax_table in
  in_prev_word text point syntax;
  to_begin_of_word text point syntax;
  let pos1 = dup_point text point in
  to_end_of_word text point syntax;
  let _,word1 = Text.delete_res text pos1 (distance text pos1 point) in
  goto_point text point pos1;
  in_next_word text point syntax;
  let pos2 = dup_point text point in
  to_end_of_word text point syntax;
  let _,word2 = Text.delete_res text pos2 (distance text pos2 point) in    
  let _ = Text.insert text pos1 word2 in
  let _ = Text.insert text pos2 word1 in
  fmove text point (String.length word1);
  commit_session text session;
  remove_point text pos1;
  remove_point text pos2
@

<<function Simple.transpose_chars>>=
let transpose_chars buf point =
  let text = buf.buf_text in
  let session = start_session text in
  bmove text point 1;
  let pos,c1 = Text.delete_res text point 1 in
  fmove text point 1;
  let _ = Text.insert text point c1 in
  commit_session text session;
  fmove text point 1;
  ()
@

<<function Simple.backward_paragraph>>=
let backward_paragraph buf point =
  let text = buf.buf_text in
  while bmove_res text point 1 = 1 && 
    (let c = get_char text point
      in
      c = '\n' || c = ' ') 
  do () done;
  try
    let _ = Text.search_backward text (Str.regexp "\n *\n") point in
    fmove text point 1; ()
  with
    Not_found ->
      set_position text point 0
@

<<function Simple.forward_paragraph>>=
let forward_paragraph buf point =
  let text = buf.buf_text in
  while
    (let c = get_char text point
      in
      c = '\n' || c = ' ') 
    && fmove_res text point 1 = 1 do () done;
  try
    let _ = Text.search_forward text (Str.regexp "\n *\n") point in
    fmove text point 1; ()
  with
    Not_found -> 
      set_position text point (Text.size text)
@

<<function Simple.electric_insert_space>>=
let electric_insert_space frame =
  self_insert_command frame;
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let line_len = point_to_bol text point in
  if line_len > 75 then
    let mark = dup_point text point in
    (try
        while (backward_word buf mark;
            point_to_bol text mark > 75) do () done;
        forward_word buf mark; backward_word buf mark;
        let _ = Text.insert text mark "\n" in ()
      with
        Not_found -> ());
    remove_point text mark
@

<<function Simple.simplify>>=
let simplify text start point =
  let start = dup_point text start in
  let rec iter last_c =
    if start < point then
      let c = get_char text start in
      if c = ' ' || c = '\n' || c = '\t' then
        ( let _ = delete text start 1 in
          iter ' ')
      else
      if last_c = ' ' then
        ( let _ = insert text start " " in
          fmove text start 2;
          iter 'a')
      else
        ( fmove text start 1;
          iter 'a')
  in
  iter 'a';
  remove_point text start
@

<<constant Simple.line_comment>>=
let line_comment = Local.create_abstr "Fill_mode.line_comment"
@

<<function Simple.fill_paragraph>>=
(* We will have to modify this to handle line_comment soon !! *)
let fill_paragraph frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let start = dup_point text point in
  let session = start_session text in
  let syntax = buf.buf_syntax_table in
  backward_paragraph buf start;
  let fin = dup_point text start in
  forward_paragraph buf fin;
  simplify text start fin;
  let _ = insert text start "\n" in
  let rec iter count last_space =
    if compare text start fin < 0 then
    if fmove_res text start 1 = 1 then 
      let c = get_char text start in  
        if c = ' ' then (* good, a new space *)
          iter (count+1) 0
      else
      if count > 75 && count <> last_space then 
          begin
          bmove text start (last_space+1);
          delete text start 1;
          insert text start "\n";
          fmove text start 1;
          iter 0 0
          end
        else
          iter (count+1) (last_space+1)
  in
  iter 0 0;  
  let _ = insert text fin "\n" in
  remove_point text start;
  remove_point text fin;
  commit_session text session
@

<<function Simple.set_indent>>=
(* modify the indentation of (point) line. Does not modify point *)
let set_indent text point offset = 
  let curseur = dup_point text point in
  bmove text curseur (point_to_bol text curseur);
  let rec iter offset =
    let c = get_char text curseur in
    if offset > 0 then
      if c = ' ' then
        (fmove text curseur 1; iter (offset - 1))
      else
      if c = '\t' then
        (let _ = delete text curseur 1 in iter offset)
      else
        (Text.insert text curseur (String.make offset ' '); ())
    else
    if c = ' ' || c='\t' then
      (Text.delete text curseur 1;
        iter 0)
  in
  iter offset;
  remove_point text curseur
@

<<function Simple.insert_special_char>>=
let insert_special_char frame =
  let key = !keypressed in
  let char = Char.chr key in
  if char >= 'a' && char <= 'z' then
    insert_char frame (Char.chr (key - 97))
  else
    insert_char frame (Char.chr (key - 65))
@

<<function Simple.next_hole>>=
(* a hole is two consecutive '^' chars *)
let next_hole frame = 
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  let text = buf.buf_text in
  let curseur = dup_point text point in
  while 
    not ((get_char text curseur = '^') && (fmove_res text curseur 1 = 1) &&
      (get_char text curseur = '^')) && (fmove_res text curseur 1 = 1) do () done;
  if get_char text curseur = '^' then
    (bmove text curseur 1;
      delete text curseur 2;
      goto_point text point curseur);
  remove_point text curseur
@

<<function Simple.insert_structure>>=
let insert_structure s frame =
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  let text = buf.buf_text in
  insert text point s;
  next_hole frame
@

<<function Simple.install_structures>>=
let install_structures buf list =
  List.iter (
    fun (key, s) ->
      Keymap.add_binding buf.buf_map key (insert_structure s)
  ) list
@

<<type Simple.parameter>>=
type parameter =   (string * ((string -> Obj.t) * (Obj.t -> string) * 
      Obj.t option_record))
@

<<constant Simple.parameters_var>>=
let parameters_var = Local.create_abstr "parameters"
@

<<function Simple.add_parameter>>=
let add_parameter location (name : string) (input : string -> 'a) 
  (print : 'a -> string) (param : 'a option_record) =
  let (input : string -> Obj.t) = Obj.magic input in
  let (print : Obj.t -> string) = Obj.magic print in
  let (param : Obj.t option_record) = Obj.magic param in
  set_global location parameters_var (
    (name, (input, print, param)) :: 
    (try get_global location parameters_var with _ -> []))
@

<<function Simple.add_option_parameter>>=
let add_option_parameter location option =
  add_parameter location (shortname option)
  (fun s -> from_value (get_class option) (Value s))
  (fun v -> 
      match to_value (get_class option) v with
        Value s -> s
      | _ -> failwith "Unable to print option") option
@

<<constant Simple.all_params>>=
let all_params = ref None
@

<<function Simple.all_parameters>>=
let all_parameters frame _ =
  let parameters = try get_global frame.frm_location parameters_var with _ -> []
  in
  match !all_params with
    Some (f,l) when f == parameters -> l
  | _ ->
      let list = List.map fst parameters in
      all_params := Some (parameters, list);
      list
@

<<toplevel Simple._1>>=
let _ =
  define_buffer_action "overwrite_mode" 
    (fun buf -> 
      let mode = overwrite_mode in
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode);

  Efuns.add_start_hook (fun location ->
      let gmap = location.loc_map in
      (* unhightlight region *)
      add_hook location Top_window.handle_key_start_hook unhightlight;      
      (* standard chars *)
      for key = 32 to 127 do
        Keymap.add_binding gmap [NormalMap, key] self_insert_command
      done;
      (* special for AZERTY keyboards *)
      Array.iter (fun (key, char) ->
          Keymap.add_binding gmap [NormalMap, key] (char_insert_command char)
      ) [| 
        (XK.xk_eacute, '');
        (XK.xk_egrave, '');
        (XK.xk_ccedilla, '');
        (XK.xk_agrave, '');
        (XK.xk_ugrave, '');
        (XK.xk_mu, ''); 
        (XK.xk_sterling, '');
        (XK.xk_section, '');
        (XK.xk_degree,  '');
        |];
      let c_q = (ControlMap, Char.code 'q') in
      (* Keymap.add_prefix gmap [c_q]; *)
      for key = 65 to 65+25 do
        Keymap.add_binding gmap [c_q;ControlMap, key] insert_special_char;
      done;
      for key = 97 to 97+25 do
        Keymap.add_binding gmap [c_q;ControlMap, key] insert_special_char;
      done;
      Keymap.add_binding gmap [NormalMap, XK.xk_Pointer_Drag1]
        mouse_drag_region;
      Keymap.add_interactive (location.loc_map) "fondamental-mode" 
        (fun frame -> Ebuffer.set_major_mode frame.frm_buffer 
            Ebuffer.fondamental_mode);
      set_global location line_comment ""
  )
@


%-------------------------------------------------------------

<<features/simple.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Options
open Xtypes
open Efuns
open Text
open Frame
open Top_window

<<function Simple.string_to_modifier>>
  
<<function Simple.modifier_to_string>>
      
<<constant Simple.name_to_keysym>>
  
<<function Simple.value_to_keysym>>
      
<<function Simple.keysym_to_value>>
  
  (* form: SC-Button1 *)
<<function Simple.value_to_key>>
  
<<function Simple.key_to_value>>
      
<<constant Simple.key_option>>

<<constant Simple.binding_option>>

<<function Simple.insert_string>>

  
<<constant Simple.single_char>>
<<function Simple.insert_char>>

<<function Simple.insert_return>>

<<function Simple.previous_char>>

<<function Simple.unset_attr>>
  
<<function Simple.insert_at_place>>


<<constant Simple.overwrite_mode>>
  
  
<<function Simple.self_insert_command>>
    
<<function Simple.char_insert_command>>

<<function Simple.move_backward>>

<<function Simple.move_forward>>

<<function Simple.begin_to_point>>

<<function Simple.point_to_end>>

<<function Simple.line_size>>

<<function Simple.beginning_of_line>>

<<function Simple.end_of_line>>

<<function Simple.forward_line>>

<<function Simple.backward_line>>


<<constant Simple.kill_size>>
<<constant Simple.kill_max>>
<<constant Simple.kill_ring>>
<<constant Simple.last_kill>>
<<constant Simple.last_insert>>

<<function Simple.kill_string>>
  kill_ring.(0) <- str


<<function Simple.kill_text>>

<<function Simple.kill_end_of_line>>

<<function Simple.kill_eol>>

<<function Simple.kill_bol>>

<<function Simple.insert_killed>>

<<function Simple.insert_next_killed>>

<<function Simple.format_to>>

<<function Simple.format_to_string>>


<<function Simple.in_next_word>>

<<function Simple.in_prev_word>>


<<function Simple.to_begin_of_word>>

<<function Simple.to_end_of_word>>

<<function Simple.to_frame>>

<<function Simple.backward_word>>

<<function Simple.forward_word>>

<<function Simple.beginning_of_word>>

<<function Simple.end_of_word>>

<<function Simple.current_word>>

<<function Simple.current_word (features/simple.ml)>>

  
  
<<function Simple.dirname>>

<<function Simple.buffer_list>>


<<function Simple.delete_char>>

<<function Simple.delete_backspace_char>>

<<function Simple.hungry_char>>

<<function Simple.hungry_electric_delete>>
  
<<function Simple.forward_screen>>

<<function Simple.backward_screen>>

<<function Simple.scroll_line>>

<<function Simple.recenter>>

<<function Simple.end_of_file>>

<<function Simple.begin_of_file>>

<<function Simple.delete_backward_word>>

<<function Simple.delete_forward_word>>

<<function Simple.undo>>

<<function Simple.kill_region>>


<<function Simple.mouse_set_frame>>
 
<<constant Simple.highlighted>>
<<constant Simple.highlight_bit>>

<<function Simple.unhightlight_region>>

<<function Simple.hightlight_region>>

<<constant Simple.highlighted_chars>>

<<function Simple.unhightlight>>
  
<<function Simple.highlight>>


<<constant Simple.htmlp>>
<<function Simple.is_paren_end>>
<<function Simple.is_paren_begin>>

<<function Simple.highlight_paren>>
  
  
  (* C'est tout simple. On arrive dans cette fonction quand on est en train
  de bouger la souris avec le bouton appuyer. La frame courante est donc 
  correcte. On peut utiliser la position de la souris pour trouver la 
  nouvelle position du curseur dans la frame. Si on en sort, on peut
  ou prendre la derniere position, ou la premiere.
  *)
<<function Simple.mouse_drag_region>>

<<function Simple.mouse_yank_at_click>>


<<function Simple.mouse_save_then_kill>>

<<function Simple.next_buffer>>

<<function Simple.kill_buffer>>

<<function Simple.color>>

<<function Simple.point_at_mark>>


<<function Simple.on_word>>
  
<<function Simple.transpose_words>>


<<function Simple.transpose_chars>>


<<function Simple.backward_paragraph>>

<<function Simple.forward_paragraph>>


<<function Simple.electric_insert_space>>

<<function Simple.simplify>>

<<constant Simple.line_comment>>

<<function Simple.fill_paragraph>>
  
<<function Simple.set_indent>>

<<function Simple.insert_special_char>>

<<function Simple.next_hole>>

<<function Simple.insert_structure>>

<<function Simple.install_structures>>
  
open Options

<<type Simple.parameter>>
  
<<constant Simple.parameters_var>>
  
<<function Simple.add_parameter>>

  (*
external id : 'a -> 'a = "%identity"
let add_string_parameter location name param = 
  add_parameter location name id id param
let add_int_parameter location name param = 
  add_parameter location name int_of_string string_of_int param
let add_float_parameter location name param = 
  add_parameter location name float_of_string string_of_float param
let add_bool_parameter location name param = 
  add_parameter location name bool_of_string string_of_bool param
    *)

<<function Simple.add_option_parameter>>
  
<<constant Simple.all_params>>
<<function Simple.all_parameters>>

  
<<toplevel Simple._1>>

  
@


\subsection*{[[features/complex.ml]]}

<<function Complex.save_buffers_and_action>>=
let rec save_buffers_and_action frame buffers action =
  match buffers with
    [] -> let () = action frame in ()
  | (_,buf) :: buffers ->
      let text = buf.buf_text in
      if buf.buf_last_saved = version text  ||
        buf.buf_name.[0] = '*'
      then
        save_buffers_and_action frame buffers action
      else
      let map = Keymap.create () in
      let request = Printf.sprintf "Save buffer %s ? (y,n,!,a)" buf.buf_name
      in
      let yes mini_frame =
        Minibuffer.kill mini_frame frame;
        Ebuffer.save buf;
        save_buffers_and_action frame buffers action
      in
      let no mini_frame =
        Minibuffer.kill mini_frame frame;
        save_buffers_and_action frame buffers action; ()
      in
      let action_immediately mini_frame = 
        Minibuffer.kill mini_frame frame;
        let () = action mini_frame in ()
      in
      let abort mini_frame =
        Minibuffer.kill mini_frame frame
      in
      Keymap.add_binding map [NormalMap, Char.code 'y'] yes;
      Keymap.add_binding map [NormalMap, Char.code 'Y'] yes;
      Keymap.add_binding map [NormalMap, Char.code 'n'] no;
      Keymap.add_binding map [NormalMap, Char.code 'N'] no;
      Keymap.add_binding map [NormalMap, Char.code '!'] action_immediately;
      Keymap.add_binding map [NormalMap, Char.code 'a'] abort;
      Keymap.add_binding map [NormalMap, Char.code 'A'] abort;
      Keymap.add_binding map [ControlMap, Char.code 'g'] abort;
      let _ = Minibuffer.create frame map request in ()
@

<<constant Complex.buf_mtime>>=
let buf_mtime = Local.create "buf_mtime" string_of_float float_of_string
@

<<function Complex.update_time>>=
let update_time buf =
  try
    match buf.buf_filename with
      None -> ()
    | Some file ->
        let st = Unix.lstat file in
        if st.st_kind = S_REG then begin
            set_local buf buf_mtime st.st_mtime;
          end
  with _ -> ()
@

<<function Complex.reload>>=
let reload frame = 
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  match buf.buf_filename with
    None -> ()
  | Some file ->
      let inc = open_in file in
      let s = read_string inc in
      close_in inc;
      let point = frame.frm_point in
      let pos = Text.get_position text point in
      Text.clear buf.buf_text;
      Text.insert_at_end text s;
      Text.set_position text point pos;
      List.iter (fun f -> f buf) buf.buf_major_mode.maj_hooks;
      List.iter (fun minor_mode -> List.iter
          (fun f -> f buf) minor_mode.min_hooks) buf.buf_minor_modes;
      Frame.status_modified frame false 
@

<<function Complex.check_file>>=
let check_file frame =
  try
    let buf = frame.frm_buffer in
    match buf.buf_filename with
      None -> ()
    | Some file ->
        let st = Unix.lstat file in
        if st.st_kind = S_REG then
          try
            let time = get_local buf buf_mtime in
            set_local buf buf_mtime st.st_mtime;
            if time <> st.st_mtime then
              ignore (select_yes_or_no frame 
                  (Printf.sprintf 
                    "%s changed on disk; reload (y/n) ?" 
                    buf.buf_name) (fun bool ->
                    if bool then reload frame else
                      Frame.status_modified frame true
                      ))
          with _ -> 
              set_local buf buf_mtime st.st_mtime
  with _ -> ()
@

<<function Complex.exit_efuns>>=
let exit_efuns frame =
  let top_window = Window.top frame.frm_window in
  let location = top_window.top_location in
  let buffers = list_of_hash location.loc_buffers in
  save_buffers_and_action frame buffers (fun _ -> exit 0)
@

<<function Complex.save_some_buffers>>=
let save_some_buffers frame =
  let top_window = Window.top frame.frm_window in
  let location = top_window.top_location in
  let buffers = list_of_hash location.loc_buffers in
  save_buffers_and_action frame buffers (fun _ -> ())
@

<<function Complex.load_buffer>>=
let load_buffer frame = 
  set_previous_frame frame;
  select_filename frame "Find file: " 
    (fun str -> 
      let _ = Frame.load_file frame.frm_window str in ())
@

<<function Complex.insert_file>>=
let insert_file frame =
  select_filename frame "Insert file: "
    (fun str ->
      let inc = open_in str in
      insert_string frame (Utils.read_string inc);
      close_in inc
  )
@

<<function Complex.write_buffer>>=
let write_buffer frame = 
  let buf = frame.frm_buffer in
  select_filename frame "Save file as: " 
    (fun str -> 
      let top_window = Window.top frame.frm_window in
      Ebuffer.change_name top_window.top_location buf str;
      Ebuffer.save buf)
@

<<function Complex.save_buffer>>=
let save_buffer frame =
  let buf = frame.frm_buffer in
  match buf.buf_filename with
    Some _ -> Ebuffer.save buf
  | None -> write_buffer frame
@

<<function Complex.window_load_buffer>>=
let window_load_buffer frame = 
  select_filename frame "Find file: " 
    (fun str -> 
      let top_window = Window.top frame.frm_window in
      let top_window = Top_window.create top_window.top_location
          (Window.display top_window)
      in
      let _ = Frame.load_file top_window.top_windows str in ())
@

<<function Complex.change_buffer>>=
let change_buffer frame =
  let default = get_previous_frame () in
  set_previous_frame frame;
  select_buffer frame " Switch to buffer: " default (fun str ->
      let window = frame.frm_window in
      change_buffer window str)
@

<<function Complex.window_change_buffer>>=
let window_change_buffer frame =
  select_buffer frame "Switch to buffer in new frame: " 
    (get_previous_frame ())
  (fun name ->
      let top_window = Window.top frame.frm_window in
      let top_window = Top_window.create 
          top_window.top_location (Window.display top_window) in
      Frame.change_buffer top_window.top_windows name
  )
@

<<function Complex.change_font>>=
let change_font frame =
  let _ = Minibuffer.create_return 
    frame (Keymap.create ()) "Find font: " "fixed"
    (fun old_frame name ->
      let window = frame.frm_window in
      let top_window = Window.top window in
      let xterm = Window.xterm top_window in
      WX_xterm.change_font xterm name
  ) in ()
@

<<function Complex.color>>=
let color buf regexp strict attr =
  let text = buf.buf_text in
  let point = Text.add_point text in
  try
    while true do
      let len = Text.search_forward text regexp point in
      let before =
        if Text.bmove_res text point 1 = 1 then
          (let c = Text.get_char text point in
            Text.fmove text point (len+1);c)
        else
          (let c = Text.get_char text point in
            Text.fmove text point (len+1); c)
      in
      let after = Text.get_char text point in
      if not (strict && (buf.buf_syntax_table.(Char.code before) ||
            buf.buf_syntax_table.(Char.code after))) then
        begin
          bmove text point len;
          Text.set_attr text point len attr;
          fmove text point len;
          ()
        end
    done
  with
    Not_found -> 
      Text.remove_point text point;
      buf.buf_modified <- buf.buf_modified + 1
@

<<constant Complex.display_hist>>=
let display_hist = ref []
@

<<function Complex.open_display>>=
let open_display frame =
  select frame "open_display :" display_hist ""
    (fun _ -> [])
  (fun s -> s)
  (fun name -> 
      let top_window = Window.top frame.frm_window in
      let location = top_window.top_location in
      let dpy_oo = new WX_display.t name in
      let root_oo = new WX_root.t dpy_oo 0 in
      let display = WX_xterm.create_display root_oo
          location.loc_colors_names location.loc_fonts_names
        in
      let _ = Top_window.create location display in
      ())
@

<<function Complex.goto_line>>=
let goto_line frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  simple_select frame "goto-line:" 
    (fun name ->
      let line = int_of_string name in
      Text.goto_line text point (line - 1))
@

<<function Complex.goto_char>>=
let goto_char frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  simple_select frame "goto-char:" 
    (fun name ->
      let char = int_of_string name in
      Text.set_position text point char)
@

<<function Complex.get_pos>>=
let get_pos frame =
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  let text = buf.buf_text in
  let top_window = Window.top frame.frm_window in
  Top_window.message top_window 
    (Printf.sprintf "Char position %d" 
      (get_position text point))
@

<<function Complex.mark_at_point>>=
let mark_at_point frame =
  let top_window = Window.top frame.frm_window in
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  Ebuffer.set_mark buf point;
  Top_window.message top_window "Mark set";
  ()
@

<<constant Complex.umask>>=
let umask = let old = Unix.umask 0 in 
  let _ = Unix.umask old in old
@

<<constant Complex.file_perm>>=
let file_perm = Local.create "file_perm" string_of_int int_of_string
@

<<function Complex.mkdir>>=
let mkdir frame =
  select_filename frame "Make directory: "
    (fun str -> 
      let file_perm = try get_var frame.frm_buffer file_perm with _ -> 
            0x1ff land (lnot umask) in
      Unix.mkdir str file_perm)
@

<<constant Complex.eval_history>>=
let eval_history = ref []
@

<<function Complex.eval>>=
let eval frame =
  select_string frame "Eval:" eval_history "" 
    (fun str ->
      let top_window = Window.top frame.frm_window in
      (* This is not enough: the paths also may have changed. *)
      Top_window.message top_window (Dyneval.eval 
          (let len = String.length str in
          if str.[len - 1] = ';' && str.[len -2 ] = ';' then str else
          str ^ " ;;")))
@

<<constant Complex.variable_hist>>=
let variable_hist = ref []
@

<<constant Complex.value_hist>>=
let value_hist = ref []
@

<<constant Complex.all_vars>>=
let all_vars = ref None
@

<<function Complex.all_variables>>=
let all_variables frame _ =
  let buf = frame.frm_buffer in
  let location = buf.buf_location in
  match !all_vars with
    Some (f,l) when f == frame -> l
  | _ ->
      let list = (Local.list buf.buf_vars) @ (Local.list location.loc_vars) in
      all_vars := Some (frame, list);
      list
@

<<function Complex.set_local_variable>>=
let set_local_variable frame = 
  Select.select frame "set-local-variable : " variable_hist
    "" (all_variables frame) (fun s -> s) (fun variable ->
      Select.select_string frame (Printf.sprintf "%s : " variable)
      value_hist "" (fun value ->
          Local.input frame.frm_buffer.buf_vars variable value))
@

<<function Complex.set_global_variable>>=
let set_global_variable frame =
  Select.select frame "set-global-variable : " variable_hist
    "" (all_variables frame) (fun s -> s) (fun variable ->
      Select.select_string frame (Printf.sprintf "%s : " variable)
      value_hist "" (fun value ->
          Local.input frame.frm_location.loc_vars variable value))
@

<<function Complex.get_variable>>=
let get_variable frame = 
  Select.select frame "get-variable : " variable_hist
    "" (all_variables frame) (fun s -> s) (fun variable ->
      Top_window.mini_message frame 
        (Printf.sprintf "%s : %s" variable (
          let buf = frame.frm_buffer in
          try
            Local.print buf.buf_vars variable
          with _ ->
              Local.print buf.buf_location.loc_vars variable)))
@

<<constant Complex.parameters_hist>>=
let parameters_hist = ref []
@

<<function Complex.set_parameter>>=
let set_parameter frame = 
  let parameters = get_global frame.frm_location parameters_var in
  Select.select frame "set-parameter : " parameters_hist
    "" (all_parameters frame) (fun s -> s) (fun variable ->
      Select.select_string frame (Printf.sprintf "%s : " variable)
      value_hist "" (fun value ->
          let (input,print,param) = List.assoc variable parameters
          in
          param =:= input value))
@

<<function Complex.get_parameter>>=
let get_parameter frame =
  let parameters = get_global frame.frm_location parameters_var in  
  Select.select frame "get-parameter : " parameters_hist
    "" (all_parameters frame) (fun s -> s) (fun variable ->
      Top_window.mini_message frame 
        (Printf.sprintf "%s : %s" variable (
          let (input,print,param) = List.assoc variable parameters
          in
          print !!param)))
@

<<constant Complex.up_buffer>>=
let up_buffer = ref ""
@

<<function Complex.down_buffer>>=
let down_buffer frame = up_buffer := frame.frm_buffer.buf_name
@

<<function Complex.up_buffer>>=
let up_buffer frame =
  if !up_buffer = "" then raise Not_found;
  set_previous_frame frame;
  Frame.change_buffer frame.frm_window !up_buffer
@

<<function Complex.left_buffer>>=
let left_buffer frame =
  set_previous_frame frame;
  Frame.change_buffer frame.frm_window (
    match !prev_buffers with
      name :: buffer :: tail ->
        prev_buffers := tail @ [name]; 
        buffer
    | _ -> raise Not_found)
@

<<function Complex.right_buffer>>=
let right_buffer frame =
  set_previous_frame frame;
  Frame.change_buffer frame.frm_window (match !prev_buffers with
      name :: tail ->
        begin
          match List.rev tail with
            buffer :: tail ->
              prev_buffers := name :: (List.rev tail);
              buffer
          | _ -> raise Not_found
        end
    | _ -> raise Not_found)
@

<<toplevel Complex._1>>=
let _ =
  Efuns.add_start_hook (fun location ->
      Keymap.add_interactive location.loc_map "make-directory" mkdir;
      Keymap.add_interactive location.loc_map "set-local-variable" 
        set_local_variable;
      Keymap.add_interactive location.loc_map "set-global-variable" 
        set_global_variable;
      Keymap.add_interactive location.loc_map "get-variable" get_variable;
      Keymap.add_interactive location.loc_map "set-parameter" set_parameter;
      Keymap.add_interactive location.loc_map "get-parameter" get_parameter;
      
  )
@


%-------------------------------------------------------------

<<features/complex.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Unix
open Utils
open Efuns
open Text
open Frame
open Simple
open Select
open Interactive

<<function Complex.save_buffers_and_action>>

<<constant Complex.buf_mtime>>

<<function Complex.update_time>>
      
<<function Complex.reload>>
      
<<function Complex.check_file>>
    
<<function Complex.exit_efuns>>

<<function Complex.save_some_buffers>>

<<function Complex.load_buffer>>

<<function Complex.insert_file>>

<<function Complex.write_buffer>>

<<function Complex.save_buffer>>

<<function Complex.window_load_buffer>>

<<function Complex.change_buffer>>

<<function Complex.window_change_buffer>>

<<function Complex.change_font>>

<<function Complex.color>>

<<constant Complex.display_hist>>
<<function Complex.open_display>>

<<function Complex.goto_line>>

<<function Complex.goto_char>>


<<function Complex.get_pos>>

<<function Complex.mark_at_point>>

<<constant Complex.umask>>
  
<<constant Complex.file_perm>>
<<function Complex.mkdir>>

<<constant Complex.eval_history>>
<<function Complex.eval>>

<<constant Complex.variable_hist>>
<<constant Complex.value_hist>>
  
<<constant Complex.all_vars>>
<<function Complex.all_variables>>
  
<<function Complex.set_local_variable>>
  
<<function Complex.set_global_variable>>
  
<<function Complex.get_variable>>

open Options
  
<<constant Complex.parameters_hist>>
  
<<function Complex.set_parameter>>
  
<<function Complex.get_parameter>>

<<constant Complex.up_buffer>>
  
<<function Complex.down_buffer>>
<<function Complex.up_buffer>>
  
<<function Complex.left_buffer>>

<<function Complex.right_buffer>>
  
  
<<toplevel Complex._1>>
  
@


\subsection*{[[features/system.ml]]}

<<function System.open_process>>=
let open_process cmd =
  let (in_read, in_write) = pipe() in
  let (out_read, out_write) = pipe() in
  let inchan = in_channel_of_descr in_read in
  let outchan = out_channel_of_descr out_write in
  match fork() with
    0 ->
      if out_read <> stdin then begin
          dup2 out_read stdin; close out_read end;
      if in_write <> Unix.stdout ||  in_write <> Unix.stderr then begin
          if in_write <> Unix.stdout then dup2 in_write stdout;
          if in_write <> Unix.stderr then dup2 in_write stderr; 
          close in_write end;
      List.iter close [in_read;out_write];
      execv "/bin/sh" [| "/bin/sh"; "-c"; cmd |];
      exit 127
  | pid -> 
      Unix.close out_read;
      Unix.close in_write;
      (pid,inchan, outchan)
@

<<function System.system>>=
let system buf_name location cmd end_action =
  let (pid,inc,outc) = open_process cmd in
  let text = Text.create "" in
  let curseur = Text.add_point text in
  let buf = Ebuffer.create location buf_name None text (Keymap.create ()) in
  buf.buf_sync <- true;
  let ins = Unix.descr_of_in_channel inc in
  let tampon = String.create 1000 in
  let active = ref true in
  Thread.add_reader ins
    (function () ->
        let pos,str = Text.delete_res text curseur
            (Text.point_to_eof text curseur) in
        let len = input inc tampon 0 1000 in
        Mutex.lock location.loc_mutex;
        if len = 0 then
          let pid,status = waitpid [WNOHANG] pid in
          begin
            match status with 
              WEXITED s -> Text.insert_at_end text 
                  (Printf.sprintf "Exited with status %d\n" s); 
                close_in inc;
                close_out outc;
                (try end_action buf s with _ -> ())
            | _ -> Text.insert_at_end text "Broken pipe" 
          end;
          Text.set_position text curseur (Text.size text);
          active := false;
          (* redraw screen *)
          update_display location;
          WX_xterm.update_displays ();
          Mutex.unlock location.loc_mutex;
          Thread.remove_reader ins; (* Kill self *)
        else
          Text.insert_at_end text (String.sub tampon 0 len);
        Text.set_position text curseur (Text.size text);
        Text.insert text curseur str;
        buf.buf_modified <- buf.buf_modified +1;
        (* redraw screen *)
        update_display location;
        WX_xterm.update_displays ();
        Mutex.unlock location.loc_mutex
  );
  let lmap = buf.buf_map in
  Keymap.add_binding lmap [NormalMap, XK.xk_Return]
    (fun frame ->
      let point = frame.frm_point in
      Text.insert text point "\n";
      Text.fmove text point 1;
      if !active then (* to avoid a segmentation fault in Ocaml *)
        let str = Text.sub text curseur 
            (Text.point_to_eof text curseur) in
        Text.set_position text curseur (Text.size text);
          (* synchronize viewpoint *)
        output outc str 0 (String.length str);
        flush outc
  );
  buf.buf_finalizers <- 
    (fun () -> 
      (try 
          Unix.kill pid Sys.sigkill;
          let _,_ = waitpid [] pid in ()
        with _ -> ());
      Concur.Thread.remove_reader ins)
  :: buf.buf_finalizers;
  buf
@

<<function System.start_command>>=
let start_command buf_name window cmd =
  let top_window = Window.top window in
  let location = top_window.top_location in
  let buf = system buf_name location cmd (fun buf status -> ()) in
  let frame = Frame.create window None buf in
  frame
@

<<constant System.shell_hist>>=
let shell_hist = ref []
@

<<function System.shell_command>>=
let shell_command frame =
  select_string frame "Run command:" shell_hist ""
    (fun cmd -> let _ = start_command "*Command*" (cut_frame frame) cmd in ())
@


%-------------------------------------------------------------

<<features/system.ml>>=
open Efuns
open Unix
open Concur
open ThreadUnix
open Select
open Simple
open Top_window
open Multi_frames

<<function System.open_process>>

<<function System.system>>

<<function System.start_command>>

<<constant System.shell_hist>>
<<function System.shell_command>>
  
@


\subsection*{[[features/select.ml]]}

<<function Select.select_yes_or_no>>=
let select_yes_or_no frame request action =
  let top_window = Window.top frame.frm_window in
  let map = Keymap.create () in
  let yes_reply mini_frame = 
    Minibuffer.kill mini_frame frame;
    top_window.top_second_cursor <- None;
    action true
  in
  let no_reply  mini_frame = 
    Minibuffer.kill mini_frame frame;
    top_window.top_second_cursor <- None;
    action false
  in
  Keymap.add_binding map [NormalMap, Char.code 'y'] yes_reply;
  Keymap.add_binding map [NormalMap, Char.code 'Y'] yes_reply;
  Keymap.add_binding map [NormalMap, Char.code 'n'] no_reply;
  Keymap.add_binding map [NormalMap, Char.code 'N'] no_reply;
  let mini = Minibuffer.create frame map request in
  mini.frm_buffer.buf_map_partial <- false;
  mini
@

<<function Select.find_completion_frame>>=
let find_completion_frame frame =
  let location = frame.frm_buffer.buf_location in
  let buf = Ebuffer.default location "*Completions*" in
  Frame.find_buffer_frame location buf
@

<<function Select.display_completions>>=
let display_completions frame list =
  let top_window = Window.top frame.frm_window in
  if list = [] then
    Top_window.message top_window "No Completions"
  else
  let location = top_window.top_location in
  let rec iter list s =
    match list with
      [] -> s
    | [f] -> Printf.sprintf "%s\n%s" s f
    | f1::f2::tail  ->
        iter tail (Printf.sprintf "%s\n%-40s%s" s f1 f2)
  in
  let buf = Ebuffer.default location "*Completions*" in
  let text = buf.buf_text in
  Text.update text (iter list "Completions :");
  let frame =
    try
      Frame.find_buffer_frame location buf
    with
      Not_found ->
        Frame.create_inactive (cut_frame frame) buf
  in
  ()
@

<<function Select.remove_completions>>=
let remove_completions frame =
  try
    let frame = find_completion_frame frame in
    remove_frame frame
  with
    Not_found -> ()
@

<<function Select.set_history>>=
let set_history map string history =
  let current = ref 0 in
  Keymap.add_binding map [NormalMap, XK.xk_Up]
    (fun mini_frame ->
      if !current = List.length !history then
        mini_message mini_frame "No previous line in history"
      else
      let ele = list_nth !current !history in
      incr current;
      let buf = mini_frame.frm_buffer in
      let text = buf.buf_text in
      Text.clear text;
      string := ele;
      insert_string mini_frame ele; ()
  );      
  Keymap.add_binding map [NormalMap, XK.xk_Down]
    (fun mini_frame ->
      if !current < 1 then
        mini_message mini_frame "No other line in history"
      else
        begin
          decr current;
          let ele = list_nth !current !history in
          let buf = mini_frame.frm_buffer in
          let text = buf.buf_text in
          Text.clear text;
          string := ele;
          insert_string mini_frame ele; ()
        end
  )
@

<<function Select.incremental_mini_buffer>>=
let incremental_mini_buffer frame ismap request default
    incremental_action action =
  let top_window = Window.top frame.frm_window in
  let incremental mini_frame =
    incremental_action frame (Text.to_string mini_frame.frm_buffer.buf_text)
  in
  let incremental_insert mini_frame =
    self_insert_command mini_frame;
    incremental mini_frame
  in
  for key = 32 to 127 do
    Keymap.add_binding ismap [NormalMap, key] incremental_insert
  done;
  Keymap.add_binding ismap [NormalMap, XK.xk_BackSpace] 
    (fun mini_frame -> 
      delete_backspace_char mini_frame;
      incremental mini_frame);
  top_window.top_second_cursor <- Some frame;
  Minibuffer.create_return frame ismap request default
    (fun frame str -> 
      top_window.top_second_cursor <- None;
      action frame str
  )
@

<<function Select.select>>=
let select frame request history start completion_fun prefix_fun action =
  let map = Keymap.create () in
  let string = ref "" in
  Keymap.add_binding map [ControlMap, Char.code 'g']
    (fun mini_frame -> 
      remove_completions mini_frame;
      Minibuffer.kill mini_frame frame);
  let completion = ref "_*NoCompletion*_" in
  let completions = ref [] in
  Keymap.add_binding map [NormalMap, XK.xk_Tab]
    (fun mini_frame ->
      if not(!completion == !string) then
        let text = mini_frame.frm_buffer.buf_text in
        completions := completion_fun !string;
        let suffix, n  = common_suffix
            !completions
            (prefix_fun !string) 
        in
        completion := !string;
        Text.insert text mini_frame.frm_point suffix;
        Text.fmove text mini_frame.frm_point (String.length suffix);
        (if n>1 then
            display_completions frame
              (Utils.completion !completions (prefix_fun !string));
        )
      else
(* can be improved, by displaying another part of the completion buffer *)
        display_completions frame
          (Utils.completion !completions (prefix_fun !string))
  );
  set_history map string history;
  let _ = 
    incremental_mini_buffer frame map request start
    (fun frame str -> 
        string := str;
    )
    (fun old_frame str -> 
        (match !history with
            hd :: _ when hd = str -> ()
          | _ ->
              if str <> "" then
                history := str :: !history);
        remove_completions frame;
        action str
    ) in
  ()
@

<<constant Select.file_hist>>=
let file_hist = ref []
@

<<constant Select.dont_complete>>=
let dont_complete = define_option ["avoid_filenames"] ""
    (list_option string_option) 
  [ ".*\.o"; ".*\.cm.";".*\.cmxa";".*~";".*\.a";"core";"\..*"]
@

<<constant Select.dont_complete_regexps>>=
let dont_complete_regexps = ref ([],Str.regexp "")
@

<<function Select.dont_complete_regexp>>=
let dont_complete_regexp () =
  let (old,reg) = !dont_complete_regexps in
  if old == !!dont_complete then
    reg
  else
  let reg = Str2.regexp_from_list !!dont_complete in
  dont_complete_regexps := (!!dont_complete, reg);
  reg
@

<<function Select.avoid_completion>>=
let avoid_completion s =
  let bad_regexp = dont_complete_regexp () in
  not (Str.string_match bad_regexp s 0)
@

<<function Select.is_userdir>>=
let is_userdir string =
  let n = String.length string in
  (n > 1) && (string.[0] = '~') &&
  (try
      let _ = String.rindex string '/' in
      false
    with
      Not_found -> true)
@

<<function Select.complete_filename>>=
let complete_filename frame good_file filename =
  if is_userdir filename then Parse_file.users
  else
  let filename = Parse_file.string_to_filename filename in
  let dirname = dirname frame filename in
  let file_list = Utils.file_list dirname in
  match file_list with
    a::b::_ -> 
      begin
        match 
          List.fold_left (fun list ele ->
              if good_file ele then ele :: list else list
          ) [] file_list
        with
          [] -> file_list 
            (* if no completion is OK, return files that should have 
          been avoided *)
        | list -> list
      end
  | _ -> file_list
@

<<function Select.select_file>>=
let select_file frame request history start action =
  let map = Keymap.create () in
  let string = ref "" in
  Keymap.add_binding map [ControlMap, Char.code 'g']
    (fun mini_frame -> 
      remove_completions mini_frame;
      Minibuffer.kill mini_frame frame);
  let completion = ref "_*NoCompletion*_" in
  let completions = ref [] in
  Keymap.add_binding map [NormalMap, XK.xk_Tab]
    (fun mini_frame ->
      if not(!completion = !string) then
        let text = mini_frame.frm_buffer.buf_text in
        completions := complete_filename frame avoid_completion !string;
        let suffix, n  = Utils.common_suffix
            !completions
            (Filename.basename !string) 
        in
        let suffix = 
          let s = !string ^ suffix in
          let len = String.length s in
          if len>0 && s.[len - 1] <> '/' then
            try
              let filename = Parse_file.string_to_filename s in
              let dirname = dirname frame filename in
              let basename = Filename.basename filename in
              let stat = Unix.stat (Filename.concat dirname basename) in
              match stat.Unix.st_kind with
                Unix.S_DIR -> suffix ^ "/"
              | _ -> suffix
            with
              _ -> suffix
          else
            suffix
        in
        completion := !string;
        Text.insert text mini_frame.frm_point suffix;
        Text.fmove text mini_frame.frm_point (String.length suffix);
        string := Text.to_string text;
        (if n>1 then
            display_completions frame
              (Utils.completion !completions (Filename.basename !string)))
      else
(* can be improved, by displaying another part of the completion buffer *)
        display_completions frame
          (Utils.completion !completions (Filename.basename !string))
  );
  set_history map string history;
  let _ = incremental_mini_buffer frame map request start
    (fun frame str -> 
      string := str;
  )
  (fun old_frame str -> 
      history := str :: !history;
      remove_completions frame;
      let str = Parse_file.string_to_filename str in
      action str
  ) in
  Keymap.add_binding map [NormalMap, XK.xk_Prior]
    (fun frame ->
      let frame = find_completion_frame frame in
      backward_screen frame);
  Keymap.add_binding map [NormalMap, XK.xk_Next]
    (fun frame ->
      let frame = find_completion_frame frame in
      forward_screen frame);
  Keymap.add_binding map [NormalMap, Char.code '~']
    (fun frame ->
      let buf = frame.frm_buffer in
      let text = buf.buf_text in
      let point = frame.frm_point in
      kill_bol buf point;
      self_insert_command frame;      
      string := to_string text
  );
  Keymap.add_binding map [NormalMap, Char.code '/']
    (fun frame ->
      let buf = frame.frm_buffer in
      let text = buf.buf_text in
      let point = frame.frm_point in
      if bmove_res text point 1 = 1 then
        ( let c = get_char text point in
          fmove text point 1;
          if c = '/' then
            kill_bol buf point);
      self_insert_command frame;
      string := to_string text            
  );
  ()
@

<<function Select.select_filename>>=
let select_filename frame request action =
  let top_window = Window.top frame.frm_window in
  let location = top_window.top_location in
  let curdir = Frame.current_dir frame in
  select_file frame request file_hist (Utils.filename_to_string curdir) action
@

<<constant Select.prev_buffers>>=
let prev_buffers = ref []
@

<<constant Select.next_default>>=
let next_default = ref ""
@

<<function Select.set_previous_frame>>=
let set_previous_frame frame = 
  let name = frame.frm_buffer.buf_name in
  next_default := name;
  prev_buffers := name :: (Utils.list_removeq !prev_buffers name)
@

<<function Select.get_previous_frame>>=
let get_previous_frame () = !next_default
@

<<constant Select.buf_hist>>=
let buf_hist = ref []
@

<<function Select.select_buffer>>=
let select_buffer frame request default action =
  select frame (request^"(default :"^ default ^ ") ") buf_hist ""
    (fun _ -> buffer_list frame) (fun s ->s) 
  (fun str ->
      let str = 
        if str = "" then default else str in
      action str)
@

<<function Select.select_string>>=
let select_string frame request history default action =
  let map = Keymap.create () in
  let string = ref "" in
  set_history map string history;
  let _ = Minibuffer.create_return frame map request default
    (fun _ str -> 
      (match !history with
          hd :: _ when hd = str -> ()
        | _ -> if str <> "" then
              history := str :: !history);
      action str) in
  ()
@

<<function Select.simple_select>>=
let simple_select frame request action =
  let map = Keymap.create () in
  let _ = Minibuffer.create_return frame map request ""
    (fun _ str -> action str) in
  ()
@


%-------------------------------------------------------------

<<features/select.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Options
open Efuns
open Text
open Frame
open Simple
open Top_window
open Multi_frames
open Utils

<<function Select.select_yes_or_no>>

<<function Select.find_completion_frame>>

<<function Select.display_completions>>

<<function Select.remove_completions>>

<<function Select.set_history>>

<<function Select.incremental_mini_buffer>>

<<function Select.select>>
  
  (****************************************************
  
               Filename selection
  
  ****************************************************)

<<constant Select.file_hist>>

<<constant Select.dont_complete>>
  
<<constant Select.dont_complete_regexps>>
<<function Select.dont_complete_regexp>>

<<function Select.avoid_completion>>

<<function Select.is_userdir>>

<<function Select.complete_filename>>

<<function Select.select_file>>

<<function Select.select_filename>>


  (****************************************************
  
               Other selection
  
  ****************************************************)

<<constant Select.prev_buffers>>
<<constant Select.next_default>>
<<function Select.set_previous_frame>>
<<function Select.get_previous_frame>>

<<constant Select.buf_hist>>
<<function Select.select_buffer>>



<<function Select.select_string>>


<<function Select.simple_select>>
  
  
@


\subsection*{[[features/search.ml]]}

<<toplevel Search._1>>=
let _ = Time.init ()
@

<<constant Search.case_fold>>=
let case_fold = ref false
@

<<function Search.to_regexp>>=
let to_regexp flag str =
  match flag with
    Regexp ->
      (if !case_fold then
          Str.regexp_case_fold 
        else
          Str.regexp) str
  | RegexpString ->
      (if !case_fold then
          Str.regexp_string_case_fold
        else
          Str.regexp_string) str
@

<<type Search.query>>=
type query = NoQuery | Query of frame * string
@

<<function Search.replace>>=
let replace flag frame query str repl =
  let top_window = Window.top frame.frm_window in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let regexp = to_regexp flag str in
  let session = start_session text in
  let n = ref 0 in
  try
    let last_pos = ref (Text.get_position text point) in
    match flag,query with
      Regexp, NoQuery ->
        while not (check_abort frame) do
          let len = Text.search_forward text regexp point in
          let pos = Text.get_position text point in
          if pos = !last_pos then 
            (if Text.fmove_res text point 1 = 0 then raise Exit)
          else begin
              last_pos := pos;
              let result = Text.replace_matched text repl in
              let (_,matched) = delete_res text point len in
              insert text point result;
              fmove text point (String.length result);
              n := !n + 1
            end
        done
    | RegexpString, NoQuery ->
        let delta = String.length repl in
        while not (check_abort frame) do
          let len = Text.search_forward text regexp point in
          let pos = Text.get_position text point in
          if pos = !last_pos then 
            (if Text.fmove_res text point 1 = 0 then raise Exit)
          else begin
              last_pos := pos;
              delete text point len;
              insert text point repl;
              Text.fmove text point delta;
              n := !n + 1
            end
        done
    | Regexp, Query (frame,request) ->
        let top_window = Window.top frame.frm_window in
        let rec iter () =
          let len = Text.search_forward text regexp point in
          let pos = Text.get_position text point in
          if pos = !last_pos then begin
              (if Text.fmove_res text point 1 = 0 then raise Exit);
              iter ();
            end
          else begin
              last_pos := pos;
              top_window.top_second_cursor <- Some frame;
              let _ = select_yes_or_no frame request 
                  (fun yes ->
                    if yes then
                      begin
                        let result = Text.replace_matched text repl in
                        let (_,matched) = delete_res text point len in
                        insert text point result;
                        fmove text point (String.length result);
                        n := !n + 1
                      end;
                    iter ()) in
              ()
            end
        in
        iter ()
    | RegexpString, Query (frame,request) ->
        let delta = String.length repl in
        let top_window = Window.top frame.frm_window in
        let rec iter () =
          let len = Text.search_forward text regexp point in
          let pos = Text.get_position text point in
          if pos = !last_pos then begin
              (if Text.fmove_res text point 1 = 0 then raise Exit);
              iter ();
            end
          else begin
              last_pos := pos;
              top_window.top_second_cursor <- Some frame;
              let _ = select_yes_or_no frame request 
                  (fun yes ->
                    if yes then
                      begin
                        delete text point len;
                        insert text point repl;
                        Text.fmove text point delta;
                        n := !n + 1
                      end;
                    iter ()) 
              in
              ()
            end
        in
        iter ()
  with
    Not_found ->
      commit_session text session;
      Top_window.message top_window
        ("Replace "^(string_of_int !n)^" occurences")
  | _ ->
      commit_session text session
@

<<function Search.no_query>>=
let no_query f = f true
@

<<function Search.query>>=
let query frame request f =
  let top_window = Window.top frame.frm_window in
  top_window.top_second_cursor <- Some frame;
  let _ = select_yes_or_no frame request f in ()
@

<<constant Search.string_history>>=
let string_history = ref []
@

<<function Search.select_replace>>=
let select_replace frame request action =
  select_string frame request string_history "" action 
@

<<function Search.replace_string>>=
let replace_string frame =
  select_replace frame "Replace string: " 
    (fun str ->
      select_replace frame "with string: " 
        (replace RegexpString frame NoQuery str))
@

<<function Search.query_replace_string>>=
let query_replace_string frame =
  select_replace frame "Replace string: " 
    (fun str ->
      select_replace frame "with string: " 
        (replace RegexpString frame 
          (Query ( frame, "Replace string ? (y/n)"))
        str)
  )
@

<<function Search.replace_regexp>>=
let replace_regexp frame =
  select_replace frame "Replace Regexp: " 
    (fun str ->
      select_replace frame "with string: " 
        (replace Regexp frame NoQuery str))
@

<<function Search.query_replace_regexp>>=
let query_replace_regexp frame =
  select_replace frame "Replace regexp: " 
    (fun str ->
      select_replace frame "with string: " 
        (replace Regexp frame 
          (Query (frame, "Replace regexp ? (y/n)"))
        str))
@

<<constant Search.library_regexp>>=
let library_regexp = Str.regexp ".*\.cm[oa]"
@

<<function Search.library_file>>=
let library_file str =
  Str.string_match library_regexp str 0
@

<<function Search.select_lib_filename>>=
let select_lib_filename frame request action =
  let top_window = Window.top frame.frm_window in
  let location = top_window.top_location in
  select frame request file_hist (current_dir frame)
  (complete_filename frame library_file)
  Filename.basename action
@

<<constant Search.last_search>>=
let last_search = ref ""
@

<<function Search.isearch>>=
let isearch to_regexp sens frame =
  let top_window = Window.top frame.frm_window in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let spoint = Text.dup_point text point in
  let orig = Text.get_position text point in
  let sens = ref sens in
  let to_regexp = ref to_regexp in
  let ismap = Keymap.create () in
  let request () =
    "isearch-"^
      (match !sens with
        Backward -> "backward"
      | Forward -> "forward"
    )^
      (match !to_regexp with
        Regexp -> "-regexp :"
      | RegexpString -> " :"
    )
  in
  let string = ref "" in
  let isearch_s () =
    last_search := !string;
    let regexp, delta =       
      if !case_fold then
        match !to_regexp with
          Regexp -> Str.regexp_case_fold !string, 0
        | RegexpString -> Str.regexp_string_case_fold
              !string, String.length !string
      else
      match !to_regexp with
        Regexp -> Str.regexp !string, 0
      | RegexpString -> Str.regexp_string !string, String.length !string
    in  
    let point = frame.frm_point in
    let buf = frame.frm_buffer in
    let text = buf.buf_text in
    goto_point text point spoint;
    match !sens with
      Backward -> 
        let _ = Text.search_backward text regexp point in ()
    | Forward ->  
        let len = Text.search_forward text regexp point in
(*        Printf.printf  "Found at %d len %d" (Text.get_position text point) len;
        print_newline ();*)
        fmove text point len; ()
  in
  let set_last mini_frame =
    if !string = "" then
      let buf = mini_frame.frm_buffer in
      let text = buf.buf_text in
      let point = mini_frame.frm_point in
      Text.insert text point !last_search;
      Text.fmove text point (String.length !last_search);
      string := !last_search
  in
  Keymap.add_binding ismap [ControlMap, Char.code 's'] 
    (fun mini_frame ->
      set_last mini_frame;      
      Text.goto_point text spoint point;
      sens := Forward;
      isearch_s ();
      Minibuffer.update_request mini_frame (request ())
  );    
  Keymap.add_binding ismap [ControlMap, Char.code 'r']
    (fun mini_frame ->
      set_last mini_frame;      
      Text.goto_point text spoint point;
      sens := Backward;
      isearch_s ();
      Minibuffer.update_request mini_frame (request ())
  );  
  let mini_frame =
    incremental_mini_buffer frame ismap (request ()) !string
      (fun frame str -> 
        string := str;
        isearch_s ()
    )
    (fun frame str -> 
        last_search := str;
        Text.remove_point text spoint
    )
  in
  let kill_and f mini_frame =
    last_search := Text.to_string mini_frame.frm_buffer.buf_text;
    Minibuffer.kill mini_frame frame;
    f frame
  in
  Keymap.add_binding ismap [ControlMap, Char.code 'g']
    (fun mini_frame  ->
      Minibuffer.kill mini_frame frame;
      Text.set_position frame.frm_buffer.buf_text frame.frm_point orig
  );
  Keymap.add_binding ismap [NormalMap, XK.xk_Left]
    (fun mini_frame  ->
      Minibuffer.kill mini_frame frame;
      let _ = move_backward frame 1 in ());  
  Keymap.add_binding ismap [NormalMap, XK.xk_Right]
    (fun mini_frame  ->
      Minibuffer.kill mini_frame frame;
      let _ = move_forward frame 1 in ());  
  Keymap.add_binding ismap [NormalMap, XK.xk_Down] (kill_and forward_line);
  Keymap.add_binding ismap [NormalMap, XK.xk_Up] (kill_and backward_line);
  Keymap.add_binding ismap [ControlMap, Char.code 'a'] 
    (kill_and beginning_of_line);
  Keymap.add_binding ismap [ControlMap, Char.code 'e'] 
    (kill_and end_of_line)
@

<<constant Search.isearch_forward_regexp>>=
let isearch_forward_regexp = isearch Regexp Forward
@

<<constant Search.isearch_forward>>=
let isearch_forward = isearch RegexpString Forward
@

<<constant Search.isearch_backward>>=
let isearch_backward = isearch RegexpString Backward
@

<<constant Search.isearch_backward_regexp>>=
let isearch_backward_regexp = isearch Regexp Backward 
@


%-------------------------------------------------------------

<<features/search.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Top_window
open Efuns
open Text
open Frame
open Simple
open Select
    
<<toplevel Search._1>>

<<constant Search.case_fold>>
<<function Search.to_regexp>>

<<type Search.query>>

<<function Search.replace>>


<<function Search.no_query>>
<<function Search.query>>

<<constant Search.string_history>>
<<function Search.select_replace>>

<<function Search.replace_string>>

<<function Search.query_replace_string>>

<<function Search.replace_regexp>>

<<function Search.query_replace_regexp>>

<<constant Search.library_regexp>>
<<function Search.library_file>>

<<function Search.select_lib_filename>>

<<constant Search.last_search>>
<<function Search.isearch>>




<<constant Search.isearch_forward_regexp>>
<<constant Search.isearch_forward>>
<<constant Search.isearch_backward>>
<<constant Search.isearch_backward_regexp>>
  
@


\subsection*{[[features/interactive.ml]]}

<<function Interactive.create_bindings>>=
let create_bindings location =
  let actives = location.loc_map.interactives in
  let s = ref "Default bindings:" in
  List.iter (fun (name,(_,binding)) ->
    match binding with
      None -> ()
    | Some key_list ->
        s := Printf.sprintf "%s\n%20s : %s" !s 
             (Keymap.print_key_list key_list) name
             ) actives;
  let text = Text.create !s in
  Ebuffer.create location "*bindings*" None text (Keymap.create ())
@

<<constant Interactive.meta_hist>>=
let meta_hist = ref []
@

<<function Interactive.buf_interactives>>=
let buf_interactives buf =
  let interactives = 
    buf.buf_major_mode.maj_map.interactives @
      buf.buf_location.loc_map.interactives in
  List.fold_left (fun list minor ->
      minor.min_map.interactives @ list) interactives buf.buf_minor_modes 
@

<<function Interactive.exec_interactive>>=
let exec_interactive interactives frame name =
  try
    let f, key = List.assoc name interactives in
    begin
      match key with
        None -> ()
      | Some key_list ->
          let top_window = Window.top frame.frm_window in
          Top_window.message top_window
            ("you can run "^name^" by typing "^
              (Keymap.print_key_list (List.rev key_list)))
    end;
    f frame
  with
    Not_found -> 
      let top_window = Window.top frame.frm_window in
      Top_window.message top_window ("No interactive command "^name)
@

<<function Interactive.call_interactive>>=
let call_interactive frame =
  let buf = frame.frm_buffer in
  let interactives = buf_interactives buf in
  select frame "M-x " meta_hist ""
    (fun _ -> List.map fst interactives)
  (fun s -> s) (exec_interactive interactives frame)
@


%-------------------------------------------------------------

<<features/interactive.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Efuns
open Text
open Frame
open Simple
open Select
open Keymap

  
<<function Interactive.create_bindings>>

<<constant Interactive.meta_hist>>
<<function Interactive.buf_interactives>>
  

  
<<function Interactive.exec_interactive>>
      
<<function Interactive.call_interactive>>
@


\subsection*{[[features/abbrevs.ml]]}

<<function Abbrevs.escaped>>=
let escaped s =
  let n = ref 0 in
  let len = String.length s in
  for i = 0 to len - 1 do
    let c = String.unsafe_get s i in
    match c with
      '\\' | '[' | ']' | '^' -> incr n
    | _ -> ()
  done;
  if !n = 0 then s else
  let ss = String.create (len + !n) in
  let p = ref 0 in
  for i = 0 to len - 1 do
    let c = String.unsafe_get s i in
    (match c with
        '\\' | '[' | ']' | '^' -> 
          String.unsafe_set ss !p '\\';
          incr p
      | _ -> ());
    String.unsafe_set ss !p c;
    incr p    
  done;
  ss
@

<<constant Abbrevs.dabbrev_buf>>=
let dabbrev_buf = ref None
@

<<function Abbrevs.dabbrev_expand>>=
let dabbrev_expand frame = 
  let top_window = Window.top frame.frm_window in
  let location = top_window.top_location in
  let buf = frame.frm_buffer in
  let syntax = buf.buf_syntax_table in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let loop = ref false in
  let s, buf, pos, history =
    match !dabbrev_buf with
      Some (s, for_frame, for_position, for_len,buf, pos, history) 
      when frame == for_frame && for_position = get_position text point ->
        bmove text point for_len;
        Text.delete text point for_len;
        s, buf, pos, history
    | _ -> 
        let str = beginning_of_word buf point in
        str , buf, 
        get_position text point - String.length str, []
  in
  let truelen = String.length s in
  let s = escaped s in
  bmove text point truelen;
  let regexp = Str.regexp s in
  let rec iter curr_buf pos =
    let curr_text = curr_buf.buf_text in
    let mark = add_point curr_text in
    set_position curr_text mark pos;
    try
      let rec restart () =
        let len = Text.search_backward curr_text regexp mark in
        if curr_text == text && mark = point then
          raise Exit
        else
          if bmove_res curr_text mark 1 <> 0 then
            if syntax.(Char.code (get_char curr_text mark)) then
              (fmove curr_text mark 1; restart ())
            else
              (fmove curr_text mark 1; ())
          else
            ()
      in
      let rec first () =
        restart ();
        fmove curr_text mark truelen;
        let m = end_of_word curr_buf mark in
        if List.mem m history then
          (bmove curr_text mark truelen; first ())
        else
          begin
            fmove text point truelen;
            let _,len = Text.insert_res text point m in
            fmove text point len;
            dabbrev_buf := Some (s, frame, get_position text point, len, 
              curr_buf, get_position curr_text mark, m :: history);
            remove_point curr_text mark
          end
      in
      first ()
    with
      Not_found ->
        remove_point curr_text mark;
        let curr_buf = next_buffer location curr_buf in
        if curr_buf == buf then
          if !loop then raise Not_found
          else
            loop := true; (* to avoid infinite loop *)
        iter curr_buf (Text.size curr_buf.buf_text) 
    | Exit ->
        remove_point curr_text mark;
        fmove text point truelen;
        dabbrev_buf := None;
        raise Not_found
  in
  iter buf pos; ()
@

<<constant Abbrevs.abbrev_table>>=
let abbrev_table = Local.create "abbrev_table" 
    (fun table ->
      let s = ref "" in 
      Hashtbl.iter (fun s1 s2 ->
          s := Printf.sprintf "%s%s --> %s\n" !s s1 s2
      ) table;
      !s
  )
  Local.no_input
@

<<function Abbrevs.expand_sabbrev>>=
let expand_sabbrev frame =
  try
    let point = frame.frm_point in
    let buf = frame.frm_buffer in
    let text = buf.buf_text in
    let abbrevs = get_local buf abbrev_table in
    let mark = dup_point text point in
    to_begin_of_word text point buf.buf_syntax_table;
    let str = Text.region text point mark in
    Text.remove_point text mark;
    let len = String.length str in
    try
      let repl = Hashtbl.find abbrevs str in
      Text.delete text point len;
      Text.insert text point repl;
      fmove text point (String.length repl); ()
    with
      Not_found -> fmove text point len; ()
  with
    _ -> ()
@

<<toplevel Abbrevs._1>>=
let _ =
  define_action "char_expand_abbrev" (fun frame ->
      expand_sabbrev frame; self_insert_command frame);
  define_action "dabbrev_expand" dabbrev_expand;
  ()
@


%-------------------------------------------------------------

<<features/abbrevs.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

(*
Expansion des abbreviations: 
deux fonctions principales: 
- "dabbrev_expand": expansion des mots a partir de mots trouves dans les
     buffers (binding normap "M-/").
- "expand_sabbrev": expansion des mots a partir d'abbreviations trouvees
    dans des tables associees au buffer (variable "abbrev_table") 
    (binding normal: un caractere de fin de mot (espace,newline,..))
*)

open Efuns
open Text
open Frame
open Simple
open Interactive

<<function Abbrevs.escaped>>
  
<<constant Abbrevs.dabbrev_buf>>
<<function Abbrevs.dabbrev_expand>>

<<constant Abbrevs.abbrev_table>>
  
<<function Abbrevs.expand_sabbrev>>

<<toplevel Abbrevs._1>>
  
@


\subsection*{[[features/multi_frames.ml]]}

<<function Multi_frames.cut_frame>>=
let cut_frame frame =
  let window = frame.frm_window in
  if window.win_height > 3 then
    let h = window.win_height / 2 in
    let w1 = Window.create false
        (Window window) window.win_xpos window.win_ypos
        window.win_width h in
    let w2 = Window.create false (Window window) window.win_xpos 
        (window.win_ypos + h) 
      window.win_width (window.win_height - h) in
    window.win_down <- VComb (w1,w2);
    Frame.install w1 frame;
    w2 
  else
    window
@

<<function Multi_frames.remove_frame>>=
let remove_frame frame =
  if frame.frm_mini_buffer = None then
    let window = frame.frm_window in
    match window.win_up with
      TopWindow _ -> ()
    | Window upwin ->
        Window.prev (Frame.install upwin) window
@

<<function Multi_frames.v_cut_frame>>=
let v_cut_frame frame =
  if frame.frm_mini_buffer = None then
    let _ = Frame.create (cut_frame frame) None frame.frm_buffer in ()
@

<<function Multi_frames.h_cut_frame>>=
let h_cut_frame frame =
  if frame.frm_mini_buffer = None then
    let window = frame.frm_window in
    if window.win_width > 10 then
      let wi = window.win_width / 2 in
      let w1 = Window.create false
          (Window window) window.win_xpos window.win_ypos
          wi window.win_height in
      let w2 = Window.create false (Window window) (window.win_xpos + wi) 
        window.win_ypos
          (window.win_width - wi) window.win_height in
      window.win_down <- HComb (w1,w2);
      Frame.install w1 frame;
      let _ = Frame.create w2 None frame.frm_buffer in ()
@

<<function Multi_frames.delete_frame>>=
let delete_frame frame =
  if frame.frm_mini_buffer = None then
    let window = frame.frm_window in
    match window.win_up with
      TopWindow _ -> ()
    | Window upwin ->
        Frame.install upwin frame;
        Frame.active frame
@

<<function Multi_frames.one_frame>>=
let one_frame frame =
  if frame.frm_mini_buffer = None then
    let window = frame.frm_window in
    let top_window = Window.top window in
    if not (top_window.top_windows == window) then
      begin
        Frame.install top_window.top_windows frame;
        Frame.active frame
      end
@

<<function Multi_frames.next_frame>>=
let next_frame frame =
  let window = frame.frm_window in
  Window.next Frame.active window
@


%-------------------------------------------------------------

<<features/multi_frames.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)


open Efuns
open Text
open Frame
open Top_window
  

<<function Multi_frames.cut_frame>>

<<function Multi_frames.remove_frame>>

<<function Multi_frames.v_cut_frame>>

<<function Multi_frames.h_cut_frame>>

<<function Multi_frames.delete_frame>>

<<function Multi_frames.one_frame>>
      
      
<<function Multi_frames.next_frame>>
@


\subsection*{[[features/compil.ml]]}

<<constant Compil.compilation_frame>>=
let compilation_frame = ref None
@

<<type Compil.error>>=
type error = {
(* error location *)    
    err_filename : string;
    err_line : int;
    err_begin : int;
    err_end : int;
(* error message *)
    err_msg : int;
  }
@

<<constant Compil.c_error_regexp>>=
let c_error_regexp = define_option ["compil"; "error_regexp"] "" regexp_option
  (string_to_regex "^\\([^:\n]+\\):\\([0-9]+\\):.*$")
@
%$

<<function Compil.c_find_error>>=
let c_find_error text error_point =
  let groups = 
    Text.search_forward_groups text (snd !!c_error_regexp)
      error_point 2 in
  let error =
    {  
      err_msg = Text.get_position text error_point;
      err_filename = groups.(0);
      err_line = (int_of_string groups.(1)) - 1;
      err_begin = 0;
      err_end = 0;
    } in
  Text.fmove text error_point 1;
  error
@

<<constant Compil.find_error>>=
let find_error = Local.create_abstr "find_error"
@

<<constant Compil.default_error>>=
let default_error = ref c_find_error
@

<<function Compil.next_error>>=
let next_error top_frame =
  let top_window = Window.top top_frame.frm_window in
  let location = top_window.top_location in
  match !compilation_frame with
    None -> Top_window.message top_window "No compilation started"
  | Some (frame, error_point, cdir) ->      
      if frame.frm_killed then unkill (cut_frame top_frame) frame;
      let buf = frame.frm_buffer in
      let find_error = try
          get_local buf find_error
        with Failure _ -> !default_error
      in
      let text = buf.buf_text in
      let point = frame.frm_point in
      try
        let error = find_error text error_point in
        Text.set_position text frame.frm_start error.err_msg;
        Text.set_position text point error.err_msg;
        frame.frm_force_start <- true;
        frame.frm_redraw <- true;
        if error.err_filename <> "" then
          let filename = Filename.concat cdir error.err_filename in
          let buf = Ebuffer.read location filename (Keymap.create ()) in
(* new frame for error buffer *)
          let frame = 
            try find_buffer_frame location buf with Not_found ->
                if frame == top_frame then
                  let display = Window.display top_window in
                  let new_window = 
                    Top_window.create top_window.top_location 
                      display 
                  in
                  Frame.create new_window.top_windows None buf
                else
                  Frame.create top_frame.frm_window None buf
          in
          let text = buf.buf_text in
          let point = frame.frm_point in
          Text.point_to_line text point error.err_line;
          Text.fmove text point error.err_begin;
          Frame.active frame
      with
        Not_found ->
          Top_window.message top_window "No more errors"
@

<<constant Compil.compile_find_makefile>>=
let compile_find_makefile = define_option ["compil";"find_makefile"] ""
    bool_option true
@

<<constant Compil.make_command>>=
let make_command = define_option ["compil";"make_command"] ""
    string_option "make -k"
@

<<constant Compil.make_hist>>=
let make_hist = ref [!!make_command]
@

<<function Compil.compile>>=
let compile find_error_fun frame =
  let default = List.hd !make_hist in
  select_string frame ("Compile command: (default :"^ default^") " )
  make_hist ""
    (fun cmd -> 
      let cmd = 
        if cmd = "" then default else
          cmd 
      in
      let cdir = Frame.current_dir frame in
      let cdir = 
        if !!compile_find_makefile then
          if String.sub cmd 0 4 = "make" || String.sub cmd 1 4 = "make" then
          (* try to find a Makefile in the directory *)
            let rec iter dir =
              let m = Filename.concat dir "Makefile" in
              if Sys.file_exists m then dir else
              let m = Filename.concat dir "makefile" in
              if Sys.file_exists m then dir else                
              let m = Filename.concat dir "GNUmakefile" in
              if Sys.file_exists m then dir else 
              let newdir = Filename.dirname dir in
              if newdir = dir then cdir else iter newdir
            in
            iter cdir
          else
            cdir
        else cdir
      in
      let top_window = Window.top frame.frm_window in
      let location = top_window.top_location in
      let comp_window =
        match !compilation_frame with
          None -> cut_frame frame 
        | Some (new_frame,error_point, _) ->
            Text.remove_point new_frame.frm_buffer.buf_text error_point;
            Ebuffer.kill location new_frame.frm_buffer;
            if new_frame.frm_killed then cut_frame frame
            else new_frame.frm_window 
      in
      Unix.chdir cdir;
      let comp_frame = System.start_command "*Compile*" comp_window cmd in
      Frame.active frame;
      let buf = comp_frame.frm_buffer in
      let error_point = Text.add_point buf.buf_text in
      compilation_frame := Some (comp_frame, error_point, cdir);
      set_local buf find_error find_error_fun
  )
@

<<function Compil.set_compilation_buffer>>=
let set_compilation_buffer frame comp_buf cdir =
  let error_point = add_point comp_buf.buf_text in
  let window =
    match !compilation_frame with
      None -> 
        cut_frame frame
    | Some (frame,point, _) ->
        remove_point frame.frm_buffer.buf_text point;  
        if frame.frm_killed then cut_frame frame 
        else
          frame.frm_window
  in
  let error_point = add_point comp_buf.buf_text in
  let comp_frame = Frame.create window None comp_buf in
  compilation_frame := Some (comp_frame, error_point, cdir)
@

<<constant Compil.grep_command>>=
let grep_command = define_option ["compil"; "grep_command"] "" string_option
    "grep -n"
@

<<constant Compil.grep_hist>>=
let grep_hist = ref [""]
@

<<function Compil.grep>>=
let grep frame =
  let default = List.hd !grep_hist in
  select_string frame (Printf.sprintf "Grep command: %s (default: %s) " !!grep_command default)
  grep_hist ""
    (fun cmd -> 
      let cmd = if cmd = "" then default else cmd in
      let cmd = !!grep_command ^ " " ^ cmd in
      let cdir = Frame.current_dir frame in
      let top_window = Window.top frame.frm_window in
      let location = top_window.top_location in
      let comp_window =
        match !compilation_frame with
          None -> cut_frame frame 
        | Some (new_frame,error_point, _) ->
            Text.remove_point new_frame.frm_buffer.buf_text error_point;
            Ebuffer.kill location new_frame.frm_buffer;
            if new_frame.frm_killed then cut_frame frame
            else new_frame.frm_window 
      in
      Unix.chdir cdir;
      let comp_frame = System.start_command "*Grep*" comp_window cmd in
      Frame.active frame;
      let buf = comp_frame.frm_buffer in
      let error_point = Text.add_point buf.buf_text in
      compilation_frame := Some (comp_frame, error_point, cdir);
      set_local buf find_error c_find_error
  )
@


%-------------------------------------------------------------

<<features/compil.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Options
open Efuns
open Text
open Frame
open Simple
open Select
open Multi_frames  

<<constant Compil.compilation_frame>>

<<type Compil.error>>

<<constant Compil.c_error_regexp>>

<<function Compil.c_find_error>>

<<constant Compil.find_error>>
<<constant Compil.default_error>>
  
<<function Compil.next_error>>

<<constant Compil.compile_find_makefile>>
  
<<constant Compil.make_command>>
  
<<constant Compil.make_hist>>
<<function Compil.compile>>

<<function Compil.set_compilation_buffer>>
  
<<constant Compil.grep_command>>
  
<<constant Compil.grep_hist>>
<<function Compil.grep>>
@


\section{[[server/]]}

\subsection*{[[server/server.ml]]}

<<constant Server.efuns_property>>=
let efuns_property = "_EFUNS_SERVER"  
@

<<constant Server.user>>=
let user = try Sys.getenv "USER" with _ -> "noname"
@

<<constant Server.socket_name>>=
let socket_name = (Printf.sprintf "/tmp/efuns-server.%s.%s:0" user !displayname)
@

<<constant Server.started>>=
let started = ref false
@

<<type Server.proto>>=
type proto =
  LoadFile of string * int * string
@

<<function Server.read_command>>=
let read_command fd frame =
  let inc = in_channel_of_descr fd in
  try
    let cmd = input_value inc in
    match cmd with
      LoadFile (name,pos,str) ->
        let window = frame.frm_window in
        let top_window = Window.top window in
        wrap top_window (fun top_window ->
            let frame = Frame.load_file window name in
            if pos <> 0 then
              let buf = frame.frm_buffer in
              let text = buf.buf_text in
              let point = frame.frm_point in
              try
                if str = "" then raise Not_found else                  
                let regexp = Str.regexp_string str in
                let len = Text.search_forward text regexp point in
                ()
              with
                Not_found -> 
                  Text.set_position text point pos
        ) ()
  with
    _ -> Concur.Thread.remove_reader fd 
@

<<function Server.module_accept>>=
let module_accept s frame = 
  let fd,_ = accept s in
  Unix.set_close_on_exec fd;
  Concur.Thread.add_reader fd (fun _ -> read_command fd frame)
@

<<function Server.start>>=
let start frame =
  if not !started then
  let top_window = Window.top frame.frm_window in
  Utils.catchexn "Efuns server:" (fun _ ->
      let s = Unix.socket PF_UNIX SOCK_STREAM 0 in
      if Sys.file_exists socket_name then Unix.unlink socket_name;
      Unix.bind s (ADDR_UNIX socket_name);
      Unix.listen s 254;
      Unix.set_nonblock s;
      Unix.set_close_on_exec s;
      let display = top_window.top_root#display  in
        Concur.Thread.add_reader s (fun _ -> 
            started := true;
            module_accept s frame);
      let atom = X.internAtom display efuns_property false in
      X.changeProperty display top_window.top_root#window 
        PropModeReplace atom XA.xa_string 1 socket_name;
  )  
@


%-------------------------------------------------------------

<<server/server.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                             ____                                    *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Efuns
open Xtypes
open Unix  
open Top_window
  
<<constant Server.efuns_property>>
<<constant Server.user>>
<<constant Server.socket_name>>

<<constant Server.started>>
  
<<type Server.proto>>
  
<<function Server.read_command>>
  
<<function Server.module_accept>>

  
<<function Server.start>>
  

@


\section{[[client/]]}

\subsection*{[[client/efuns_client.ml]]}

<<constant Efuns_client.pos>>=
let pos = ref 0
@

<<constant Efuns_client.string>>=
let string = ref ""
@

<<constant Efuns_client.filename>>=
let filename = ref None
@

<<toplevel Efuns_client._1>>=
let _ = Arg.parse [
    "-pos", Arg.Int (fun i -> pos := i)," <int>: set position";
    "-str", Arg.String (fun s -> string := s)," <string>: search string";
  ] (fun name -> filename := Some name)
  "efuns_server: connect to efuns"
@

<<constant Efuns_client.pos (client/efuns_client.ml)>>=
let pos = !pos    
@

<<constant Efuns_client.filename (client/efuns_client.ml)>>=
let filename = match !filename with
    None -> failwith "efuns_server: filename missing"
  | Some s -> s
@

<<constant Efuns_client.string (client/efuns_client.ml)>>=
let string = !string
@

<<constant Efuns_client.filename (client/efuns_client.ml)2>>=
let filename = if is_relative filename then 
    concat (getcwd ()) filename else filename
@

<<constant Efuns_client.efuns_property>>=
let efuns_property = "_EFUNS_SERVER"  
@

<<constant Efuns_client.display>>=
let display = Xlib.openDisplay ""
@

<<constant Efuns_client.root>>=
let root = display.dpy_roots.(0).scr_root
@

<<constant Efuns_client.atom>>=
let atom = X.internAtom display efuns_property false
@

<<constant Efuns_client.socket_name>>=
let socket_name = (Xlib.getWholeProperty display root atom).gp_value
@

<<toplevel Efuns_client._2>>=
let _ =  if not (Sys.file_exists socket_name) then raise Not_found
@

<<toplevel Efuns_client._3>>=
let _ =  
  output_value outc (LoadFile (filename,pos,string)); flush outc
@


%-------------------------------------------------------------

<<client/efuns_client.ml>>=
open Server  
open Xtypes
open Unix
open Sys
open Filename
  
<<constant Efuns_client.pos>>
<<constant Efuns_client.string>>
<<constant Efuns_client.filename>>
  
<<toplevel Efuns_client._1>>
  
<<constant Efuns_client.pos (client/efuns_client.ml)>>
<<constant Efuns_client.filename (client/efuns_client.ml)>>
<<constant Efuns_client.string (client/efuns_client.ml)>>
    
<<constant Efuns_client.filename (client/efuns_client.ml)2>>
    
<<constant Efuns_client.efuns_property>>

<<constant Efuns_client.display>>
<<constant Efuns_client.root>>
<<constant Efuns_client.atom>>
<<constant Efuns_client.socket_name>>
<<toplevel Efuns_client._2>>
let (inc,outc) = open_connection (ADDR_UNIX socket_name)
<<toplevel Efuns_client._3>>
  
@


\section{[[dynamic/]]}

\subsection*{[[dynamic/eval.ml]]}

<<function Eval.try_load>>=
let try_load top_window f =
  try
    f (); 
    Efuns.init top_window.top_location
  with
    Dynlink.Error error ->
      Top_window.message top_window (Dynlink.error_message error)
  | e -> 
      Top_window.message top_window
        (Printf.sprintf "Exception %s" (Printexc.to_string e))
@

<<function Eval.load>>=
let load top_window mod_name =
  try_load top_window (fun () -> load_module mod_name)
@

<<function Eval.load_library>>=
let load_library frame =
  select_lib_filename frame "Load library: " 
    (fun str ->
      let top_window = Window.top frame.frm_window in
      try_load top_window (fun () -> load_file str))
@

<<function Eval.eval_buffer>>=
let eval_buffer frame =
  let top_window = Window.top frame.frm_window in
  let location = top_window.top_location in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let filename = Filename.temp_file "buffer" ".ml" in
  let outc = open_out filename in
  Text.save buf.buf_text outc;
  close_out outc;
  let cmd = "ocamlc -c -I " ^ Version.efuns_lib ^ " " ^ filename in 
  let end_action buf status =
    match status with
      0 -> try_load top_window 
          (fun _ -> 
            let fl =  ((Filename.chop_suffix filename ".ml") ^ ".cmo") 
            in 
            load_file fl;
            Efuns.init top_window.top_location)
    | _ -> 
        set_compilation_buffer frame buf (Filename.dirname filename);
        Top_window.message top_window "Error while compiling buffer"
  in
  let _ = System.system "*Eval*" location cmd end_action in ()
@


%-------------------------------------------------------------

<<dynamic/eval.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)


open Efuns
open Text
open Frame
open Simple
open Select
open Search
open Compil

  (*
let rec load_module mod_name =
  let filename = (String.uncapitalize mod_name) ^ ".cmo" in
  try
    let filename = Utils.find_in_path !Efuns.load_path filename in
    load_file filename
  with
    Not_found -> failwith ("Can't find file "^filename)

and load_file filename =
  try
    Dynlink.loadfile filename
  with
    Dynlink.Error (Dynlink.Unavailable_unit mod_name) -> 
      load_interface mod_name;
      load_file filename
  | Dynlink.Error (
    Dynlink.Linking_error (_, Dynlink.Undefined_global mod_name)) ->
      load_module mod_name;
      load_file filename

and load_interface mod_name =
  try
    Dynlink.add_interfaces [mod_name] !Efuns.load_path; ()
  with
    Not_found ->
      failwith (Printf.sprintf "No interface for %s" mod_name)
      *)

open Dyneval

<<function Eval.try_load>>

<<function Eval.load>>

<<function Eval.load_library>>

  
<<function Eval.eval_buffer>>
@


\section{[[graphics/]]}

\subsection*{[[graphics/top_window.ml]]}

<<function Top_window.message>>=
let message top_window msg =
  let xterm = Window.xterm top_window  in
  let len = String.length msg in
  WX_xterm.draw_string xterm 0 (top_window.top_height - 1)
    msg 0 len Text.direct_attr;
  WX_xterm.clear_eol xterm len (top_window.top_height - 1)
    (top_window.top_width - len);
  match top_window.top_mini_buffers with
    [] -> (* No mini-buffer ... *) ()
  | mini_buffer :: _ -> (* one mini-buffer is active *)
      match top_window.top_display with
        None -> ()
      | Some display ->
          WX_xterm.update_displays ();
          let _ = Unix.select [] [] [] 0.2 in
          mini_buffer.frm_redraw <- true
@

<<function Top_window.clear_message>>=
let clear_message top_window =
  match top_window.top_mini_buffers with
    [] -> 
      let xterm = Window.xterm top_window in
      WX_xterm.clear_eol xterm 0 
        (top_window.top_height - 1) top_window.top_width; 
  | _ -> ()
@

<<function Top_window.dummy_action>>=
let dummy_action frame = ()
@

<<function Top_window.try_map>>=
let try_map frame key =
  let prefix = frame.frm_prefix in
  let keylist = prefix @ [key] in
  match Ebuffer.get_binding frame.frm_buffer keylist with
    Unbound -> raise UnboundKey
  | Prefix map ->
      frame.frm_prefix <- keylist;
      let top_window = top frame.frm_window in
      message top_window (Keymap.print_key_list frame.frm_prefix);
  | Function f ->
      frame.frm_repeat_action <- 
      if (f == frame.frm_last_action) then
        frame.frm_repeat_action + 1
      else 0;
      frame.frm_prefix <- [];
      f frame;
      frame.frm_last_action <- f
@

<<function Top_window.set_cursor_on>>=
let set_cursor_on top_window frame = 
  Frame.set_cursor frame;
  if frame.frm_cursor.[0] <> '\000' then
    let xterm = xterm top_window in
    WX_xterm.draw_string xterm 
      (frame.frm_xpos + frame.frm_cursor_x-frame.frm_x_offset) 
    (frame.frm_ypos + frame.frm_cursor_y) 
    frame.frm_cursor 0 1 Text.inverse_attr
@

<<function Top_window.set_cursor_off>>=
let set_cursor_off top_window frame =
  if frame.frm_cursor.[0] <> '\000' then
    let xterm = xterm top_window in
    WX_xterm.draw_string xterm 
      (frame.frm_xpos + frame.frm_cursor_x) 
    (frame.frm_ypos + frame.frm_cursor_y) 
    frame.frm_cursor 0 1 frame.frm_cursor_attr
@

<<function Top_window.cursor_on>>=
let cursor_on top_window =
  let frame = top_window.top_active_frame in
  let name = frame.frm_buffer.buf_name in
  if not (name == top_window.top_name) then
    begin
      top_window.top_appli#setWM_NAME name;
      top_window.top_name <- name
    end;
  set_cursor_on top_window frame;
  match top_window.top_second_cursor with
    None -> ()
  | Some frame -> set_cursor_on top_window frame
@

<<function Top_window.cursor_off>>=
let cursor_off top_window =
  let frame = top_window.top_active_frame in
  set_cursor_off top_window frame;
  match top_window.top_second_cursor with
    None -> ()
  | Some frame -> set_cursor_off top_window frame
@

<<function Top_window.update_display>>=
let update_display location =
  List.iter (fun top_window -> 
      iter (Frame.update top_window) top_window.top_windows;
      (match top_window.top_mini_buffers with
          [] -> ()
        | frame :: _ ->
            Frame.update top_window frame);
      cursor_on top_window;
  ) location.loc_windows
@

<<function Top_window.clean_display>>=
let clean_display location =
  List.iter (fun top_window -> 
      cursor_off top_window
  ) location.loc_windows
@

<<function Top_window.resize_window>>=
let rec resize_window window xpos ypos width height =
  let old_width = window.win_width in
  let old_height = window.win_height in
  window.win_xpos <- xpos;
  window.win_ypos <- ypos;
  window.win_width <- width;
  window.win_height <- height;
  match window.win_down with
    WFrame frame -> Frame.install window frame
  | NoFrame () -> assert false
  | HComb (w1,w2) ->
      let wi1 = w1.win_width * width / old_width in
      resize_window w1 xpos ypos wi1 height;
      resize_window w2 (xpos + wi1) ypos (width - wi1) height
  | VComb (w1,w2) ->
      let he1 = w1.win_height * height / old_height in
      resize_window w1 xpos ypos width he1;
      resize_window w2 xpos (ypos + he1) width (height - he1)
@

<<function Top_window.find_frame>>=
let rec find_frame window x y =
  match window.win_down with
    NoFrame () -> assert false
  | WFrame frame -> frame
  | HComb (w1,w2) -> 
      if w2.win_xpos > x then find_frame w1 x y
      else find_frame w2 x y
  | VComb (w1,w2) ->
      if w2.win_ypos > y then find_frame w1 x y
      else find_frame w2 x y
@

<<constant Top_window.keypressed>>=
let keypressed = ref 0
@

<<constant Top_window.mouse_x>>=
let mouse_x = ref 0
@

<<constant Top_window.mouse_y>>=
let mouse_y = ref 0
@

<<function Top_window.find_selected_frame>>=
let find_selected_frame top_window =
  let x = !mouse_x in
  let y = !mouse_y in
  let frame = 
    if y > top_window.top_height - 2 then
      match top_window.top_mini_buffers with
        [] -> raise Not_found
      | mini_frame :: _ -> mini_frame
    else
      find_frame top_window.top_windows x y
  in
  Frame.active frame;
  frame
@

<<function Top_window.mouse_set_active>>=
let mouse_set_active top_window =
  let x = !mouse_x in
  let y = !mouse_y in
  let frame = find_selected_frame top_window in
  Frame.move_point frame frame.frm_point x y;
  frame
@

<<function Top_window.mini_message>>=
let mini_message frame msg =
  let top_window = Window.top frame.frm_window in
  message top_window msg
@

<<constant Top_window.handle_key_start_hook>>=
let handle_key_start_hook = Local.create_abstr "handle_key_start_hook"
@

<<constant Top_window.handle_key_end_hook>>=
let handle_key_end_hook = Local.create_abstr "handle_key_end_hook"
@

<<constant Top_window.meta>>=
let meta = ref Xtypes.mod1Mask
@

<<function Top_window.handle_key>>=
let handle_key top_window modifiers keysym =
  keypressed := keysym;
  let location = top_window.top_location in
  let frame = top_window.top_active_frame in
  clean_display location;
  clear_message top_window;
  exec_hooks (try get_global location handle_key_start_hook with _ -> []) location;
  begin
    let mods = 
      let mask = Xtypes.controlMask lor !meta in
      let diff = modifiers land mask in
      if diff = Xtypes.controlMask then ControlMap else
      if diff = !meta then MetaMap else
      if diff = 0 then NormalMap else ControlMetaMap in
    let key = (mods, keysym) in
    try
      try_map frame key
    with
      UnboundKey -> 
        message top_window
          (Printf.sprintf "Unbound key %s %s"
            (Keymap.print_key_list frame.frm_prefix)
          (Keymap.print_key key));
        frame.frm_prefix <- [];
    | Failure str -> message top_window str
    | e -> message top_window 
          (Printf.sprintf "Uncaught exception %s" (Utils.printexn e))
  end;
  exec_hooks (try get_global location handle_key_end_hook with _ -> []) location;
  update_display top_window.top_location
@

<<function Top_window.wrap>>=
let wrap top_window f () = 
  let location = top_window.top_location in
  Concur.Mutex.lock location.loc_mutex;  
  clean_display location;    
  clear_message top_window;
  keypressed := XK.xk_Menu;
  exec_hooks
    (try get_global location handle_key_start_hook with _ -> []) location;    
  begin
    try f top_window with e ->   
        message top_window 
          (Printf.sprintf "Uncaught exception %s" (Utils.printexn e))
  end;
  exec_hooks 
    (try get_global location handle_key_end_hook with _ -> []) location;    
  update_display top_window.top_location;
  WX_xterm.update_displays ();
  Concur.Mutex.unlock top_window.top_location.loc_mutex
@

<<function Top_window.wrap_item>>=
let wrap_item top_window (n,f) =
  n, wrap top_window (fun top_window -> f top_window.top_active_frame)
@

<<function Top_window.handler>>=
let handler top_window xterm event =
  let location = top_window.top_location in
  Concur.Mutex.lock location.loc_mutex;
  try
    begin
      match event with
        WX_xterm.XTKeyPress (modifiers, s, keysym) ->
          if (keysym < XK.xk_Shift_L || keysym > XK.xk_Hyper_R)
          then 
            handle_key top_window modifiers keysym
      
      | WX_xterm.XTButtonPress (modifiers,button,x,y) -> 
          mouse_x := x;
          mouse_y := y;
          handle_key top_window modifiers (XK.xk_Pointer_Button_Dflt + button)
      
      | WX_xterm.XTMouseMotion (modifiers,button,x,y) ->
          mouse_x := x;
          mouse_y := y;
          handle_key top_window modifiers (XK.xk_Pointer_Drag_Dflt + button)
      
      | WX_xterm.XTResize (new_width, new_height) ->
          resize_window top_window.top_windows 0 0 new_width (new_height - 1);
          List.iter
            (fun frame -> 
              let window = frame.frm_window in
              window.win_ypos <- new_height - 1;
              window.win_width <- new_width;
              Frame.install window frame) top_window.top_mini_buffers;
          top_window.top_width <- new_width;
          top_window.top_height <- new_height;
          clear_message top_window;
          update_display top_window.top_location
          
    end;
    Concur.Mutex.unlock top_window.top_location.loc_mutex;
  with
    e ->   
      Concur.Mutex.unlock top_window.top_location.loc_mutex;
      raise e
@

<<constant Top_window.buffers_menu>>=
let buffers_menu = ref (fun (top_window : top_window) (button : WX_button.t) ()
      -> ())
@

<<function Top_window.scroll_to_frame>>=
let scroll_to_frame ady top_window =
  let frame = top_window.top_active_frame in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let pos_start = Text.get_position text frame.frm_start in
  let pos_end = Text.get_position text frame.frm_end in
  let size = Text.size text in
  let y = ady#get_pos size in
  if abs (y - pos_start) > 80 then
  (* the position has changed *)
    begin
      frame.frm_force_start <- true;
      frame.frm_redraw <- true;
      Text.set_position text frame.frm_start y
    end
@

<<constant Top_window.menus>>=
(*
    Text.set_position text point y;
      let point = Text.add_point text in
      let curline = Text.point_line text frame.frm_start in
      let newline = Text.point_line text point in
      Text.remove_point text point;
    frame.frm_y_offset <- frame.frm_y_offset + (newline - curline);
  *)

let menus = define_option ["menus"] ""
    (list_option (tuple2_option (string_option, list_option string2_option)))
  []
@

<<constant Top_window.file_menu>>=
let file_menu = define_option ["file_menu"] ""
    (list_option string2_option) []
@

<<constant Top_window.edit_menu>>=
let edit_menu = define_option ["edit_menu"] ""
    (list_option string2_option) []
@

<<constant Top_window.help_menu>>=
let help_menu = ref [| |]
@

<<function Top_window.create>>=
let create location display =
  let buf = Ebuffer.default location "*help*" in
  let top = new WX_appli.t display.WX_xterm.root_oo [] in
  top#setWM_NAME "new_frame";
  top#setWM_CLASS "Efuns" "efuns";
  let hbar = new WX_bar.h top#container [] in
  top#container_add hbar#contained;
  let xterm = new WX_xterm.t 
      hbar#container display
      location.loc_width
      location.loc_height in
  let ady = new WX_adjust.t () in
  let scrollbar = new WX_scrollbar.v hbar#container ady [] in
  hbar#container_add_s [xterm#contained; scrollbar#contained];
  let window = Window.create_at_top  0 0 location.loc_width (location.loc_height - 1) in
  let frame = Frame.create_without_top location window None buf  in
  let top_window =
    { top_location = location;
      top_display = Some display;
      top_xterm = None;
      top_term = xterm;
      top_attrs = Array.create 256 None;
      top_windows = window;
      top_mini_buffers = [];
      top_width = location.loc_width;
      top_height = location.loc_height;
      top_name = "window";
      top_active_frame = frame;
      top_second_cursor = None;
      top_root=  display.WX_xterm.root_oo;
      top_appli = top;
      top_scrollbar = ady;
    } 
  in
  ady#add_subject (fun () ->
      let frame = top_window.top_active_frame in
      if not frame.frm_force_start then
        wrap top_window (scroll_to_frame ady) ()); 
  frame.frm_window.win_up <- TopWindow top_window;
  location.loc_windows <- top_window :: location.loc_windows;
  top#add_button "Buffers" (!buffers_menu top_window);
  top#add_menu "File" (Array.map (fun (name,action) ->
        wrap_item top_window (name, execute_action action)
    ) (Array.of_list !!file_menu));
  top#add_menu "Edit" (Array.map (fun (name,action) ->
        wrap_item top_window (name, execute_action action)
    ) (Array.of_list !!edit_menu));
  List.iter (fun (menu_name, items) ->
      top#add_menu menu_name 
        (Array.map (fun (name,action) ->
            wrap_item top_window (name, execute_action action)
        ) (Array.of_list items))
  ) !!menus;
  top#add_separator;
  top#add_menu "Help" (Array.map (wrap_item top_window) !help_menu);
  top#show;
  let xterm = xterm#xterm in
  top_window.top_xterm <- Some xterm;
  WX_xterm.install_handler display xterm (handler top_window xterm);
  top#configure [Bindings [Key (anyKey, anyModifier), (fun _ ->
          handler top_window xterm (WX_xterm.XTKeyPress (
              !WX_types.modifiers_event, !key_string, !key_sym));
          WX_xterm.update_displays ()
    )]];
  top_window
@

<<function Top_window.delete_window>>=
let delete_window frame =
  let top_window = Window.top frame.frm_window in
  let location = top_window.top_location in
  if List.length location.loc_windows > 1 then
    let xterm = Window.xterm top_window in
    top_window.top_appli#destroy;
    WX_xterm.destroy_window xterm;
    Frame.kill_all top_window.top_windows;
    location.loc_windows <- Utils.list_remove location.loc_windows
      top_window
@

<<constant Top_window.check_abort>>=
let check_abort = ref 0
@

<<constant Top_window.check_abort_delay>>=
let check_abort_delay = ref 100
@

<<function Top_window.check_abort>>=
let check_abort frame =
  incr check_abort; 
  if !check_abort mod !check_abort_delay = 0 then
    let top_window = Window.top frame.frm_window in
    let xterm = top_window.top_term in
    xterm#check_abort
  else false
@


%-------------------------------------------------------------

<<graphics/top_window.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Options
open Xtypes
open WX_types
open Efuns
open Window

  
<<function Top_window.message>>

<<function Top_window.clear_message>>



<<function Top_window.dummy_action>>

<<function Top_window.try_map>>

<<function Top_window.set_cursor_on>>

<<function Top_window.set_cursor_off>>

<<function Top_window.cursor_on>>

<<function Top_window.cursor_off>>


<<function Top_window.update_display>>

<<function Top_window.clean_display>>

<<function Top_window.resize_window>>

<<function Top_window.find_frame>>

<<constant Top_window.keypressed>>
<<constant Top_window.mouse_x>>
<<constant Top_window.mouse_y>>

<<function Top_window.find_selected_frame>>


<<function Top_window.mouse_set_active>>


<<function Top_window.mini_message>>

<<constant Top_window.handle_key_start_hook>>
<<constant Top_window.handle_key_end_hook>>
  
<<constant Top_window.meta>>
  
<<function Top_window.handle_key>>

  (* We can receive events from different sources. In particular, some of
  them can be received during the painting (scrollbar ...)
  *)
  
<<function Top_window.wrap>>

<<function Top_window.wrap_item>>
        
<<function Top_window.handler>>


<<constant Top_window.buffers_menu>>

<<function Top_window.scroll_to_frame>>
<<constant Top_window.menus>>
<<constant Top_window.file_menu>>
<<constant Top_window.edit_menu>>
<<constant Top_window.help_menu>>

  
  
<<function Top_window.create>>

<<function Top_window.delete_window>>
    
    

        
<<constant Top_window.check_abort>>
<<constant Top_window.check_abort_delay>>

  (* This function should be used in loops that could be interrupted by
  the user. It returns "true" if the user pressed C-g, and false
  in other cases. *)
  
<<function Top_window.check_abort>>
@


\section{[[./]]}

\subsection*{[[std_efunsrc.ml]]}

<<constant Std_efunsrc.grep_hist>>=
let grep_hist = ref ["grep -n "]
@

<<function Std_efunsrc.save_options>>=
let save_options frame = Options.save ()
@

<<function Std_efunsrc.fondamental_mode>>=
let fondamental_mode frame =
  Ebuffer.set_major_mode frame.frm_buffer Ebuffer.fondamental_mode
@

<<toplevel Std_efunsrc._1>>=
let _ =
  define_action "fill_paragraph" fill_paragraph;
  define_action "save_options" save_options;
  define_action "fondamental_mode" fondamental_mode;
  define_action "replace_string" replace_string;
  define_action "replace_regexp" replace_regexp;
  define_action "query_replace_string" query_replace_string;
  define_action "query_replace_regexp" query_replace_regexp;
  define_action "load_library" load_library;
  define_action "get_position" get_pos;
  define_action "open_display" open_display;
(*  define_action "compile" (compile c_find_error); *)
  define_action "grep" grep;
  define_action "goto_line" goto_line;
  define_action "goto_char" goto_char;
  define_action "unset_attr" unset_attr;
  define_action "eval" Complex.eval;  
  define_action "start_server" Server.start;  
  define_action "delete_before_point"  
    delete_backspace_char;
  define_action "insert_return"  insert_return;
  define_action "forward_line"  forward_line;  
  define_action "backward-line"  backward_line;
  define_action "backward_screen"  backward_screen;
  define_action "forward_screen"  forward_screen;
  
  define_action "backward_paragraph"  (to_frame backward_paragraph);
  define_action "kill_region"  kill_region;
  define_action "forward_paragraph"  (to_frame forward_paragraph);  
  define_action "beginning_of_line"  beginning_of_line;
  define_action "delete_at_point"  delete_char;
  define_action "move_backward"  (fun frame -> ignore (move_backward frame 1));
  define_action "move_forward"  
    (fun frame -> ignore (move_forward frame 1));
  define_action "end_of_line"  end_of_line;
  define_action "kill_end_of_line"  kill_end_of_line;
  define_action "isearch_forward"  isearch_forward    ;
  define_action "isearch_backward"  isearch_backward    ;
  define_action "undo"  undo;
  define_action "forward_word"  (to_frame forward_word);  
  define_action "backward_word"  (to_frame backward_word);
  define_action "end_of_file"  end_of_file;
  define_action "begin_of_file"  begin_of_file;
  define_action "insert_killed"  insert_killed;
  define_action "mark_at_point"  mark_at_point;
  define_action "recenter"  recenter;
  define_action "transpose_chars"  (to_frame transpose_chars);
  define_action "hungry_electric_delete"  hungry_electric_delete;

  define_action "isearch_forward_regexp"  isearch_forward_regexp;
  define_action "isearch_backward_regexp"  isearch_backward_regexp;
  define_action "delete_forward_word"  (to_frame delete_forward_word);
  define_action "delete_backward_word"  (to_frame delete_backward_word);
  define_action "call_interactive"  call_interactive;
  define_action "shell_command"  shell_command;
  define_action "insert_next_killed"  insert_next_killed;
  define_action "transpose_words"  
  (to_frame transpose_words);
  define_action "lowercase_word" 
    (fun frame ->
      let buf = frame.frm_buffer in
      let point = frame.frm_point in
      on_word buf point String.lowercase);
  define_action "uppercase_word" 
    (fun frame ->
      let buf = frame.frm_buffer in
      let point = frame.frm_point in
      on_word buf point String.uppercase);
  define_action "revert_buffer" reload;
  define_action "check_file" check_file;
  define_buffer_action "update_time" update_time;
(* C-x map *)
  define_action "load_buffer"  load_buffer;
  define_action "insert_file"  insert_file;
  define_action "exit"  exit_efuns; 
  define_action "change_buffer"  change_buffer;
  define_action "change_font"  change_font;
  define_action "vertical_cut_frame"  v_cut_frame;    
  define_action "horizontal_cut_frame"  h_cut_frame;    
  define_action "one_frame"  one_frame;
  define_action "delete_frame"  delete_frame;
  define_action "next_frame"  next_frame;
  define_action "kill_buffer"  kill_buffer;
  define_action "save_buffer"  save_buffer; 
  define_action "next_error"  next_error;
  define_action "write_file"  write_buffer; 
  define_action "save_some_buffers"  save_some_buffers;
  define_action "point_at_mark"  point_at_mark;
  
(* C-x 5 map *)
  define_action "window_load_buffer"  window_load_buffer;
  define_action "window_change_buffer"  window_change_buffer;
  define_action "delete_window"  Top_window.delete_window;

(* C-h map *)
  define_action "help_bindings"  Frame.bindings_help;

    (* C-M map *)
  define_action "left_buffer"  left_buffer;
  define_action "right_buffer"  right_buffer;
  define_action "down_buffer"  down_buffer;
  define_action "up_buffer"  up_buffer;
  define_action "next_hole" next_hole;
  
  ()
@

<<constant Std_efunsrc.global_map>>=
let global_map = define_option ["global_map"] "" 
    (list_option binding_option) 
  []
@

<<constant Std_efunsrc.interactives_map>>=
let interactives_map = define_option ["interactives_map"] ""
    (list_option string2_option) 
  []
@

<<constant Std_efunsrc.c_h>>=
let c_h = (ControlMap, Char.code 'h')
@

<<constant Std_efunsrc.c_x>>=
let c_x = (ControlMap, Char.code 'x') 
@

<<constant Std_efunsrc.c_c>>=
let c_c = (ControlMap, Char.code 'c') 
@

<<constant Std_efunsrc.n_5>>=
let n_5 = (NormalMap, Char.code '5') 
@

<<toplevel Std_efunsrc._2>>=
let _ = 
  if !!global_map = [] then begin
      global_map =:= [
        [MetaMap, XK.xk_q], "fill_paragraph";
        [NormalMap, XK.xk_BackSpace], "delete_before_point"; 
        [NormalMap, XK.xk_Delete], "delete_at_point"; 
        [NormalMap, XK.xk_Return], "insert_return"; 
        [NormalMap, XK.xk_Left], "move_backward"; 
        [NormalMap, XK.xk_Right], "move_forward"; 
        [NormalMap, XK.xk_Down], "forward_line"; 
        [NormalMap, XK.xk_Up], "backward-line"; 
        [NormalMap, XK.xk_Prior], "backward_screen"; 
        [NormalMap, XK.xk_Next], "forward_screen";
        [NormalMap, Char.code ' '], "char_expand_abbrev";
        [NormalMap, XK.xk_Insert], "overwrite_mode";

        [ControlMap, XK.xk_Up], "backward_paragraph";
        [ControlMap, Char.code 'w'], "kill_region";
        [ControlMap, XK.xk_Down], "forward_paragraph";  
        [ControlMap, Char.code 'a'], "beginning_of_line";
        [ControlMap, Char.code 'd'], "delete_at_point";
        [ControlMap, Char.code 'b'], "move_backward";
        [ControlMap, Char.code 'f'], "move_forward";
        [ControlMap, Char.code 'e'], "end_of_line";
        [ControlMap, Char.code 'k'], "kill_end_of_line";
        [ControlMap, Char.code 's'], "isearch_forward";
        [ControlMap, Char.code 'r'], "isearch_backward";
        [ControlMap, Char.code '_'], "undo";
        [ControlMap, XK.xk_Right ], "forward_word";  
        [ControlMap, XK.xk_Left ], "backward_word";
        [ControlMap, XK.xk_Next], "end_of_file";
        [ControlMap, XK.xk_Prior], "begin_of_file";
        [ControlMap, Char.code 'y'], "insert_killed";
        [ControlMap, Char.code ' '], "mark_at_point";
        [ControlMap, Char.code 'l'], "recenter";
        [ControlMap, Char.code 't'], "transpose_chars";
        [ControlMap, XK.xk_BackSpace], "hungry_electric_delete";

        
        [MetaMap, Char.code 's'], "isearch_forward_regexp";
        [MetaMap, Char.code 'r'], "isearch_backward_regexp";
        [MetaMap, XK.xk_Right ], "forward_word";
        [MetaMap, XK.xk_Left ], "backward_word";
        [MetaMap, Char.code 'd' ], "delete_forward_word";
        [MetaMap, XK.xk_BackSpace ], "delete_backward_word";
        [MetaMap, Char.code 'x'], "call_interactive";
        [MetaMap, Char.code '%'], "query_replace_string";
        [MetaMap, Char.code '!'], "shell_command";
        [MetaMap, Char.code 'y'], "insert_next_killed";
        [MetaMap, Char.code 't'], "transpose_words";
        [MetaMap, Char.code 'l'], "lowercase_word";
        [MetaMap, Char.code 'u'], "uppercase_word";
        [MetaMap, Char.code '/'], "dabbrev_expand";
        
        [c_x; ControlMap, Char.code 'f'], "load_buffer";
        [c_x; NormalMap, Char.code 'i'], "insert_file";
        [c_x; ControlMap, Char.code 'c'], "exit"; 
        [c_x; NormalMap, Char.code 'b'], "change_buffer";
        [c_x; NormalMap, Char.code 'F'], "change_font";
        [c_x; NormalMap, Char.code '2'], "vertical_cut_frame";    
        [c_x; NormalMap, Char.code '3'], "horizontal_cut_frame";    
        [c_x; NormalMap, Char.code '1'], "one_frame";
        [c_x; NormalMap, Char.code '0'], "delete_frame";
        [c_x; NormalMap, Char.code 'o'], "next_frame";
        [c_x; NormalMap, Char.code 'k'], "kill_buffer";
        [c_x; ControlMap, Char.code 's'], "save_buffer"; 
        [c_x;NormalMap, Char.code '`' ], "next_error";
        [c_x;ControlMap, Char.code 'w'], "write_file"; 
        [c_x; NormalMap, Char.code 's'], "save_some_buffers";
        [c_x; ControlMap, Char.code 'x'], "point_at_mark";
        [c_x; n_5; NormalMap, Char.code 'f'], "window_load_buffer";
        [c_x; n_5; NormalMap, Char.code 'b'], "window_change_buffer";
        [c_x; n_5; NormalMap, Char.code '0'], "delete_window";
        
        [c_h; NormalMap, Char.code 'K'], "help_bindings";

        [ ControlMap, Char.code 'c'; NormalMap, Char.code '-'], "next_hole";
        
        [ControlMetaMap, XK.xk_Left], "left_buffer";
        [ControlMetaMap, XK.xk_Right], "right_buffer";
        [ControlMetaMap, XK.xk_Down], "down_buffer";
        [ControlMetaMap, XK.xk_Up], "up_buffer";
      
      ]
    end;
  if !!interactives_map = [] then begin
      interactives_map =:= [
        "fondamental_mode", "fondamental_mode";
        "save_options", "save_options";
        "replace_string", "replace_string";
        "replace_regexp", "replace_regexp";
        "query_replace_string", "query_replace_string";
        "query_replace_regexp", "query_replace_regexp";
        "load_library", "load_library";
        "get_position", "get_position";
        "open_display", "open_display";
        "compile", "compile";
        "grep", "grep";
        "goto_line", "goto_line";
        "goto_char", "goto_char";
        "unset_attr", "unset_attr";
        "eval", "eval";  
        "start_server", "start_server";
        "makefile_mode", "makefile_mode";
        "ocaml_mode", "ocaml_mode";
        "tex_mode", "tex_mode";
        "c_mode", "c_mode";
        "accents_mode", "accents_mode";
        "paren_mode", "paren_mode";
        "abbrevs_mode", "abbrevs_mode";
        "ocaml_minor_mode", "ocaml_minor_mode";
        "fill_mode", "fill_mode";
        "ocaml_compiler_mode", "ocaml_compiler_mode";
        "tab_mode", "tab_mode";
        "overwrite_mode", "overwrite_mode";
      ]
    end    
@

<<function Std_efunsrc.init_global_map>>=
let init_global_map location = 
  
  List.iter (fun (keys, action) ->
      try
        Keymap.add_global_key location keys action (execute_action action)
      with e ->
          Log.printf "Error for action %s" action;
          Log.exn "%s\n" e;
  ) !!global_map;
  
  Keymap.add_global_key location [NormalMap, XK.xk_dead_circumflex]
    "circumflex" (char_insert_command '^');

        (* These keys depend on the next key pressed. In my case, I don't use
  the accents, so I prefer them to immediatly enter the good key.
let	xk_dead_grave					= 0xFE50
let	xk_dead_acute					= 0xFE51
let	xk_dead_circumflex				= 0xFE52
let	xk_dead_tilde					= 0xFE53
let	xk_dead_macron					= 0xFE54
let	xk_dead_breve					= 0xFE55
let	xk_dead_abovedot				= 0xFE56
let	xk_dead_diaeresis				= 0xFE57
let	xk_dead_abovering				= 0xFE58
let	xk_dead_doubleacute				= 0xFE59
let	xk_dead_caron					= 0xFE5A
let	xk_dead_cedilla					= 0xFE5B
let	xk_dead_ogonek					= 0xFE5C
let	xk_dead_iota					= 0xFE5D
let	xk_dead_voiced_sound				= 0xFE5E
let	xk_dead_semivoiced_sound			= 0xFE5F
let	xk_dead_belowdot				= 0xFE60
*)
  
  List.iter (fun (name, action) ->
      try
      add_interactive location.loc_map name (execute_action action)
      with e ->
          Log.printf "Error for action %s" action;
          Log.exn "%s\n" e;
  ) !!interactives_map;
    
  let gmap = location.loc_map in

(* standard keys *)

(* Mouse *)
  add_global_key location [NormalMap, XK.xk_Pointer_Button1]
    "set_active_frame" mouse_set_frame;
  add_global_key location [NormalMap, XK.xk_Pointer_Button2]
    "insert_at_point" mouse_yank_at_click;
  add_global_key location [NormalMap, XK.xk_Pointer_Button3]
  "mouse_save_then_kill" mouse_save_then_kill;
  ()
@

<<function Std_efunsrc.select_open_file>>=
let select_open_file frame =
  let window = frame.frm_window in
  let top_window = Window.top window in
  let cdir = Frame.current_dir frame in
  let info = {
      filter = Filename.concat cdir "*";
      current_selection = cdir;
      predicat = (fun _ -> true);
      action = (fun _ -> ());
      cancel = (fun _ -> ());
    } in
  let query = new WX_filesel.t top_window.top_root info [] in
  query#setWM_TRANSIENT_FOR (top_window.top_appli#top :> WX_types.container);
  info.action <- (fun name ->
      wrap top_window (fun top_window ->
          query#destroy;
          let _ = Frame.load_file window name in ()
      ) ());
  info.cancel <- (fun () ->
      wrap top_window (fun top_window ->
          query#destroy;
      ) ());        
  query#show
@

<<function Std_efunsrc.compile>>=
let compile frame =
  exec_interactive (buf_interactives frame.frm_buffer) frame "compile"
@

<<toplevel Std_efunsrc._3>>=
let _ =
  define_action "select_open_file" select_open_file;
  define_action "compile" compile;
  define_action "v_cut_frame" v_cut_frame;
  ()
@

<<toplevel Std_efunsrc._4>>=
let _ =
  if !!file_menu = [] then begin
      file_menu =:=    [
        "Open File", "select_open_file";
        "Save Buffer", "save_buffer";
        "Kill Buffer", "kill_buffer";
        "Compile", "compile";
        "", "";
        "Quit", "exit";
      ]
    end;
  if !!edit_menu = [] then begin
      edit_menu =:= [ 
        "Cut", "kill_region";
        "Paste",  "insert_killed";
        "Undo", "undo";
        "", "";
        "Cut Frame", "v_cut_frame";
        "One Frame", "one_frame";
        "Delete Frame", "delete_frame";
      ];
    end;
  help_menu := [|
    "Key Bindings", (fun frame ->
        Frame.change_buffer frame.frm_window "*bindings*"
    );
    "Changes", (fun frame ->
        let _ = Frame.load_file frame.frm_window (
            Version.efuns_lib ^"/Changes") in ());
    "About Efuns", (fun frame ->
(*
        let top_window = Window.top frame.frm_window in        
        let dialog = new WX_dialog.t top_window.top_root 
            "Efuns,\nVersion 015\nFabrice Le Fessant\nFabrice.Le_Fessant@inria.fr" [] in
        dialog#add_button "OK" (fun _ -> dialog#destroy);
        dialog#show;
    *)
        Frame.change_buffer frame.frm_window "*help*"
    );
  |];
  buffers_menu := (fun top_window button () ->
      let buffers = ref [] in
      let location = top_window.top_location in
      Hashtbl.iter (fun name buf -> buffers:=name :: !buffers) 
      location.loc_buffers;
      let desc = Array.map (fun name -> 
            (name, wrap top_window (fun top_window ->
                  let frame = top_window.top_active_frame in
                  let window = frame.frm_window in
                  Frame.change_buffer window name
              )))
        (Array.of_list !buffers) in
      let menu = new WX_popup.t top_window.top_root desc in
      let (x,y) = button#root_coordinates in
      menu#popup_once x (y + button#height) (Some !WX_types.button_event)
      )
@

<<toplevel Std_efunsrc._5>>=
let _ =
  Efuns.add_start_hook (fun location ->
      add_option_parameter location compile_find_makefile;
      add_option_parameter location Text.add_amount;
      init_global_map location)
@


%-------------------------------------------------------------

<<std_efunsrc.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)



open Options
open Utils
open Interactive
open Efuns
open Keymap
open Simple
open Select
open Search
open Eval
open Compil
open Abbrevs
open Complex
open System
open Multi_frames
open Top_window
  

<<constant Std_efunsrc.grep_hist>>

<<function Std_efunsrc.save_options>>
<<function Std_efunsrc.fondamental_mode>>
  
<<toplevel Std_efunsrc._1>>
  
  
<<constant Std_efunsrc.global_map>>

<<constant Std_efunsrc.interactives_map>>

<<constant Std_efunsrc.c_h>>
<<constant Std_efunsrc.c_x>>
<<constant Std_efunsrc.c_c>>
<<constant Std_efunsrc.n_5>>

<<toplevel Std_efunsrc._2>>
    
<<function Std_efunsrc.init_global_map>>
  
open WX_filesel

<<function Std_efunsrc.select_open_file>>

<<function Std_efunsrc.compile>>

<<toplevel Std_efunsrc._3>>
  
<<toplevel Std_efunsrc._4>>
  
<<toplevel Std_efunsrc._5>>
@


\subsection*{[[main.ml]]}

<<constant Main.location>>=
let location = {
    loc_map = Keymap.create ();
    loc_windows = [];
    loc_buffers = Hashtbl.create 13;
    loc_files = Hashtbl.create 13;
    loc_dirname = Sys.getcwd ();
    loc_width = !!width;
    loc_height = !!height;
    loc_fg = !!foreground;
    loc_bg = !!background;
    loc_font = !!font;
    loc_vars = Local.vars ();
    loc_counter = 0;
    
    loc_fonts = Hashtbl.create 37;
    loc_fonts_names = Array.create 256 "";
    loc_fonts_n = 0;
    loc_colors = Hashtbl.create 37;
    loc_colors_names = Array.create 256 "";
    loc_colors_n = 0;
    
    loc_mutex = Concur.Mutex.create ()
} 
@

<<exception Main.SigInt>>=
exception SigInt
@

<<toplevel Main._1>>=
let _ =
  Utils.register_exn (fun e ->
      match e with
        Unix.Unix_error (error,f,arg) ->
          Printf.sprintf "Unix error %s: %s %s" 
            f (Unix.error_message error) arg
      | _ -> raise e);

  Utils.set_signal Sys.sigint (Sys.Signal_handle (fun _ ->  
        (* Should auto-save all buffers, and then exit ... *)
        exit 1)); 
  Utils.set_signal Sys.sigterm (Sys.Signal_handle 
      (fun _ ->  
        (* Should auto-save all buffers, and then exit ... *)
        raise SigInt));
  Utils.set_signal Sys.sighup (Sys.Signal_handle (fun _ ->  raise SigInt))
@

<<constant Main.highlight_color>>=
let highlight_color = define_option ["highlight_color"] ""
    color_option "cyan"
@

<<toplevel Main._2>>=
let _ =
(* color 0 is foreground *)
  let _ = Window.get_color location !!foreground in
(* color 1 is background *)
  let _ = Window.get_color location !!background in
(* color 2 is highlight *)
  let _ = Window.get_color location !!highlight_color in
(* font 0 is initial font *)
  Window.get_font location !!font
@

<<toplevel Main._3>>=
let _ =
  Efuns.init location (* launch first hooks *)
@

<<constant Main.dpy_oo>>=
let dpy_oo = new WX_display.t !displayname
@

<<constant Main.root_oo>>=
let root_oo = new WX_root.t dpy_oo 0
@

<<constant Main.display>>=
let display = WX_xterm.create_display root_oo
  location.loc_colors_names location.loc_fonts_names 
@

<<constant Main.top_window>>=
let top_window = Top_window.create location display
@

<<toplevel Main._4>>=
let _ =
  WX_xterm.setHighlight display 2;
  Dyneval.init true;
  Eval.load top_window "Efunsrc";
  Efuns.init location; (* launch second hooks *)
  let _ = Interactive.create_bindings location in

(* open the fisrt buffers *)
  List.iter (fun name ->
    let _ = Frame.load_file top_window.top_windows name in ()) 
  !init_files;
  List.iter 
    (fun str -> let top_window = Top_window.create top_window.top_location
          (Window.display top_window) in
      let _ = Frame.load_file top_window.top_windows str in ()) !init_frames;
  Top_window.update_display location;

  
  if not (Sys.file_exists (Filename.concat Utils.homedir ".efunsrc")) then
    begin
      Printf.printf "Saving .efunsrc after install"; print_newline ();
      Options.save ();
    end;

  if !check then exit 0;  
  (* Main loop *)
  let rec loop () =
    try
      WX_types.loop ()
    with
      SigInt -> loop ()
  in
  loop ()
@


%-------------------------------------------------------------

<<main.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Options
open Obj

open Text
open Efuns
  
<<constant Main.location>>

<<exception Main.SigInt>>
<<toplevel Main._1>>

<<constant Main.highlight_color>>
  
<<toplevel Main._2>>

<<toplevel Main._3>>
  
  
<<constant Main.dpy_oo>>
<<constant Main.root_oo>>
<<constant Main.display>>
<<constant Main.top_window>>
  
<<toplevel Main._4>>

  



  
@


\section{[[major_modes/]]}

\subsection*{[[major_modes/dired.ml]]}

<<function Dired.update>>=
let update buf =
  let filename = match buf.buf_filename with
      None -> failwith "Not a directory"
    | Some filename -> filename in
  let s = Utils.load_directory filename in
  let text = buf.buf_text in
  Text.update text s;
  buf.buf_last_saved <- Text.version text
@

<<constant Dired.file_reg>>=
let file_reg = Str.regexp ".* \([^ ]+\)$"
@
%$

<<function Dired.get_file_line>>=
let get_file_line frame =
  (match frame.frm_buffer.buf_filename with
      None -> ()
    | Some filename -> 
        frame.frm_location.loc_dirname <- Filename.dirname filename);
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let start_point = Text.dup_point text point in
  let before = Text.point_to_bol text point in
  let after = Text.point_to_eol text point in
  Text.bmove text start_point before;
  let line = Text.sub text start_point (before + after) in
  Text.remove_point text start_point;
  line
@

<<function Dired.select_file>>=
let select_file line =
  if line.[0] = ' ' then
    if Str.string_match file_reg line 0 then
      Str.matched_group 1 line else
      String.sub line 60 (String.length line - 60)
  else
    failwith "Dired: not a file line"
@

<<function Dired.dirname>>=
let dirname frame =
  match frame.frm_buffer.buf_filename with
    None -> "."
  | Some dirname -> dirname 
@

<<function Dired.fullname>>=
let fullname frame filename = 
  Filename.concat (dirname frame) filename
@

<<function Dired.open_file>>=
let open_file frame =
  let filename = fullname frame (select_file (get_file_line frame)) in
  let location = frame.frm_location in
  let buf = Ebuffer.read location filename (Keymap.create ()) in
  let frame = Frame.create  frame.frm_window None buf in
  Frame.active frame
@

<<function Dired.remove>>=
let remove frame =
  let line = get_file_line frame in   
  let filename = select_file line in
  let _ = 
    Select.select_yes_or_no frame (Printf.sprintf "Remove %s ? (y/n)" filename)
    (fun b -> if b then
          if line.[1] = 'd' then Unix.rmdir filename else
          Unix.unlink filename;
        update frame.frm_buffer) in
  ()
@

<<constant Dired.view_list>>=
let view_list = ref []
@

<<constant Dired.old_view_list>>=
let old_view_list = ref []
@

<<constant Dired.compiled_view_list>>=
let compiled_view_list = ref []
@

<<function Dired.fast_view>>=
let fast_view frame filename =
  if not (!old_view_list == !view_list) then
    begin
      compiled_view_list := List.map 
        (fun (file_reg, appli) ->
          Str.regexp file_reg, appli) !view_list;
      old_view_list := !view_list
    end;
  try
    List.iter (fun (regexp, viewer) ->
        if Str.string_match regexp filename 0 then
          try
            Unix.chdir (dirname frame);
            viewer frame filename;
            raise Exit
          with
            _ -> raise Exit
    ) !compiled_view_list;
    let _ = 
      Select.select_yes_or_no frame (Printf.sprintf "Open %s ? (y/n)" filename)
      (fun b -> if b then
            open_file frame) in
      ()

  with
    Exit -> ()      
@

<<function Dired.open_view>>=
let open_view frame =
  let filename = select_file (get_file_line frame) in
  fast_view frame filename
@

<<function Dired.mkdir>>=
let mkdir frame =
  Select.select_filename frame "Make directory: "
    (fun str -> 
      let file_perm = try get_var frame.frm_buffer file_perm with _ -> 
            0x1ff land (lnot umask) in
      Unix.mkdir str file_perm;
      update frame.frm_buffer)
@

<<function Dired.install>>=
let install buf = 
  match buf.buf_filename with
    None -> 
      failwith "Dired: Not a directory"
  | Some filename ->
      if not (Utils.is_directory filename) then 
        failwith (Printf.sprintf "Dired: %s not a directory" filename);
      update buf
@

<<constant Dired.mode>>=
let mode = Ebuffer.new_major_mode "Dired" [install]
@

<<constant Dired.map>>=
let map = mode.maj_map
@

<<function Dired.viewer>>=
let viewer commande frame filename =
  let _ =  Sys.command (Printf.sprintf "(%s %s) &" commande filename) in ()
@

<<function Dired.commande>>=
let commande commande frame filename =
  let _ = Sys.command (Printf.sprintf commande filename) in
  failwith  (Printf.sprintf commande filename)
@

<<function Dired.unzip_and_view>>=
let unzip_and_view frame filename =
  let new_filename = Printf.sprintf "/tmp/efuns-view-%s" (
      Filename.chop_extension filename) in
  let res = Sys.command (
      Printf.sprintf "gzip -cd %s > %s" filename new_filename)
  in
  if res = 0 then fast_view frame new_filename
@

<<toplevel Dired._1>>=
let _ = 
  interactive map [NormalMap, XK.xk_Return] "dired-open-file" open_file;
  interactive map [NormalMap, Char.code 'g'] "dired-update" 
  (fun frame -> update frame.frm_buffer);  
  interactive map [NormalMap, Char.code 'v'] "dired-view-file" open_view;  
  interactive map [NormalMap, Char.code '+'] "dired-make-directory" 
    mkdir;  
  interactive map [NormalMap, Char.code '-'] "dired-remove-entry" 
    remove;  
  
  view_list := [
    ".*\(\.jpg\|\..gig\|\.xpm\|\.ppm\)",viewer "xv";
    ".*\(\.ps\|\.PS\)",viewer "gv";
    ".*\(\.dvi\)",viewer "xdvi";
    ".*\(\.gz\|\.Z\|\.z\)",unzip_and_view; 
    ".*\.tgz", commande "xterm -e sh -c \"tar zvtf %s | less\"";
    ".*\.tar", commande "xterm -e sh -c \"tar vtf %s | less\"";
    ".*\.tar", commande "xterm -e sh -c \"tar vtf %s | less\"";
    ];
  
  Efuns.add_start_hook (fun location ->
      add_interactive (location.loc_map) "dired-mode" 
        (fun frame -> 
          Ebuffer.set_major_mode frame.frm_buffer mode);
      set_global location Ebuffer.modes_alist ((".*/$",mode) :: 
        (get_global location Ebuffer.modes_alist));      
  )   
@
%$


%-------------------------------------------------------------

<<major_modes/dired.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                             ____                                    *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Text
open Keymap
open Efuns
open Simple
open Compil
open Complex
open Window

<<function Dired.update>>

<<constant Dired.file_reg>>
  
<<function Dired.get_file_line>>
    
<<function Dired.select_file>>

<<function Dired.dirname>>
      
<<function Dired.fullname>>
      
<<function Dired.open_file>>
  
<<function Dired.remove>>

<<constant Dired.view_list>>
<<constant Dired.old_view_list>>
<<constant Dired.compiled_view_list>>
  
<<function Dired.fast_view>>
  
<<function Dired.open_view>>
  
<<function Dired.mkdir>>
          
<<function Dired.install>>
      
<<constant Dired.mode>>

<<constant Dired.map>>
  

<<function Dired.viewer>>

<<function Dired.commande>>
  
<<function Dired.unzip_and_view>>
    
<<toplevel Dired._1>>
@


\section{[[minor_modes/]]}

\subsection*{[[minor_modes/minor_mode_sample.ml]]}

<<constant Minor_mode_sample.minor_mode_name>>=
let minor_mode_name = "my_minor_mode"
@

<<function Minor_mode_sample.install>>=
let install buf = ()
@

<<function Minor_mode_sample.minor_mode_fun>>=
let minor_mode_fun frame = ()
@

<<constant Minor_mode_sample.mode>>=
let mode = Ebuffer.new_minor_mode  minor_mode_name [install]
@

<<toplevel Minor_mode_sample._1>>=
let _ = 
  List.iter
    (fun key -> 
      Keymap.add_binding mode.min_map [NormalMap, Char.code key] 
      minor_mode_fun
  )
  [ ]
@

<<toplevel Minor_mode_sample._2>>=
let _ = 
  define_action (minor_mode_name ^ "_mode")
    (fun frame -> 
      let buf = frame.frm_buffer in
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode)
@


%-------------------------------------------------------------

<<minor_modes/minor_mode_sample.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Text
open Simple
open Efuns
open Top_window
          
<<constant Minor_mode_sample.minor_mode_name>>

<<function Minor_mode_sample.install>>

<<function Minor_mode_sample.minor_mode_fun>>
  
<<constant Minor_mode_sample.mode>>

<<toplevel Minor_mode_sample._1>>

<<toplevel Minor_mode_sample._2>>
    
    
@


\subsection*{[[minor_modes/abbrevs_mode.ml]]}

<<constant Abbrevs_mode.abbreviations>>=
let abbreviations = define_option ["abbrevs_mode"; "abbrevs"] ""
    (list_option string2_option) []
@

<<constant Abbrevs_mode.abbrevs>>=
let abbrevs = Hashtbl.create 11
@

<<toplevel Abbrevs_mode._1>>=
let _ =
  Utils.hash_add_assoc abbrevs !!abbreviations
@

<<function Abbrevs_mode.install>>=
let install buf =
  try
    ignore (get_local buf abbrev_table)
  with _ -> 
      set_local buf abbrev_table abbrevs
@

<<constant Abbrevs_mode.mode>>=
let mode = Ebuffer.new_minor_mode "abbrevs" [install]
@

<<constant Abbrevs_mode.abbrevs_chars>>=
let abbrevs_chars = define_option ["abbrevs_mode"; "abbrevs_chars"] ""
    string_option " "
@

<<function Abbrevs_mode.find_matching>>=
let find_matching  frame = self_insert_command frame; highlight_paren frame
@

<<function Abbrevs_mode.char_expand_abbrev>>=
let char_expand_abbrev frame =
  expand_sabbrev frame; self_insert_command frame
@

<<toplevel Abbrevs_mode._2>>=
let _ = 
  let chars = !!abbrevs_chars in
  for i = 0 to String.length chars - 1 do
    Keymap.add_binding mode.min_map [NormalMap, Char.code chars.[i]]
      char_expand_abbrev
  done
@

<<toplevel Abbrevs_mode._3>>=
let _ = 
  define_action "abbrevs_mode" 
    (fun frame -> 
      let buf = frame.frm_buffer in
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode)
@


%-------------------------------------------------------------

<<minor_modes/abbrevs_mode.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Options
open Abbrevs
open Text
open Simple
open Efuns
open Top_window

  
<<constant Abbrevs_mode.abbreviations>>
  
<<constant Abbrevs_mode.abbrevs>>
<<toplevel Abbrevs_mode._1>>
  
<<function Abbrevs_mode.install>>

<<constant Abbrevs_mode.mode>>

<<constant Abbrevs_mode.abbrevs_chars>>
  
<<function Abbrevs_mode.find_matching>>
<<function Abbrevs_mode.char_expand_abbrev>>
  
<<toplevel Abbrevs_mode._2>>

<<toplevel Abbrevs_mode._3>>
    
    
@


\subsection*{[[minor_modes/accents_mode.ml]]}

<<function Accents_mode.accent>>=
let accent frame =
  let key = !keypressed in
  let c = previous_char frame in
  try
    let key = 
      if key = XK.xk_grave then
        match c with
        | 'e' -> XK.xk_egrave
        | 'a' -> XK.xk_agrave
        | 'i' -> XK.xk_igrave 
        | 'o' -> XK.xk_ograve 
        | 'u' -> XK.xk_ugrave
        | 'A' -> XK.xk_Agrave
        | 'E' -> XK.xk_Egrave
        | 'I' -> XK.xk_Igrave
        | 'O' -> XK.xk_Ograve
        | 'U' -> XK.xk_Ugrave 
        | _ -> raise Not_found
      else 
      if key = XK.xk_apostrophe then
        match c with
        | 'e' -> XK.xk_eacute
        | 'E' -> XK.xk_Eacute
        
        | 'a' -> XK.xk_aacute
        | 'i' -> XK.xk_iacute
        | 'o' -> XK.xk_oacute
        | 'u' -> XK.xk_uacute
        | 'A' -> XK.xk_Aacute
        | 'I' -> XK.xk_Iacute
        | 'O' -> XK.xk_Oacute
        | 'U' -> XK.xk_Uacute
        
        | _ -> raise Not_found
      else
      if key = XK.xk_semicolon then
        match c with
          'c' -> XK.xk_ccedilla
        | _ -> raise Not_found
      else
      if key = XK.xk_asciicircum then
        match c with
        | 'e' -> XK.xk_ecircumflex
        | 'a' -> XK.xk_acircumflex 
        | 'i' -> XK.xk_icircumflex
        | 'o' -> XK.xk_ocircumflex
        | 'u' -> XK.xk_ucircumflex
        | 'A' -> XK.xk_Acircumflex
        | 'E' -> XK.xk_Ecircumflex
        | 'I' -> XK.xk_Icircumflex
        | 'O' -> XK.xk_Ocircumflex
        | 'U' -> XK.xk_Ucircumflex 
        | _ -> raise Not_found
      else              
      if key = XK.xk_quotedbl then
        match c with
        | 'e' -> XK.xk_ediaeresis
        | 'a' -> XK.xk_adiaeresis 
        | 'i' -> XK.xk_idiaeresis
        | 'o' -> XK.xk_odiaeresis
        | 'u' -> XK.xk_udiaeresis
        | 'A' -> XK.xk_Adiaeresis
        | 'E' -> XK.xk_Ediaeresis
        | 'I' -> XK.xk_Idiaeresis
        | 'O' -> XK.xk_Odiaeresis
        | 'U' -> XK.xk_Udiaeresis 
        | _ -> raise Not_found
      else              
      if key = XK.xk_asciitilde then
        match c with
        | 'n' -> XK.xk_ntilde
        | 'a' -> XK.xk_atilde
        | 'o' -> XK.xk_otilde
        | 'A' -> XK.xk_Atilde
        | 'N' -> XK.xk_Ntilde
        | 'O' -> XK.xk_Otilde 
        | _ -> raise Not_found
      else              
        raise Not_found
    in
    bmove frame.frm_buffer.buf_text frame.frm_point 1;
    insert_at_place frame (Char.chr key)
  with
    Not_found ->
      try
        let c = Char.code c in
        let c = 
          if key = XK.xk_grave then
            if c = XK.xk_egrave then 'e' else
            if c = XK.xk_agrave then 'a' else
            if c = XK.xk_igrave then 'i' else 
            if c = XK.xk_ograve then 'o' else 
            if c = XK.xk_ugrave then 'u' else
            if c = XK.xk_Agrave then 'A' else
            if c = XK.xk_Egrave then 'E' else
            if c = XK.xk_Igrave then 'I' else
            if c = XK.xk_Ograve then 'O' else
            if c = XK.xk_Ugrave then 'U' else 
              raise Not_found
          else 
          if key = XK.xk_apostrophe then
            if c = XK.xk_eacute then 'e' else
            if c = XK.xk_Eacute then 'E' else
            if c = XK.xk_aacute then 'a' else
            if c = XK.xk_iacute then 'i' else
            if c = XK.xk_oacute then 'o' else
            if c = XK.xk_uacute then 'u' else
            if c = XK.xk_Aacute then 'A' else
            if c = XK.xk_Iacute then 'I' else
            if c = XK.xk_Oacute then 'O' else
            if c = XK.xk_Uacute then 'U' else
              raise Not_found
          else
          if key = XK.xk_semicolon then
            if c = XK.xk_ccedilla then 'c' else
              raise Not_found
          else
          if key = XK.xk_asciicircum then
            if c = XK.xk_ecircumflex then 'e' else
            if c = XK.xk_acircumflex then 'a' else 
            if c = XK.xk_icircumflex then 'i' else
            if c = XK.xk_ocircumflex then 'o' else
            if c = XK.xk_ucircumflex then 'u' else
            if c = XK.xk_Acircumflex then 'A' else
            if c = XK.xk_Ecircumflex then 'E' else
            if c = XK.xk_Icircumflex then 'I' else
            if c = XK.xk_Ocircumflex then 'O' else
            if c = XK.xk_Ucircumflex then 'U' else 
              raise Not_found
          else              
          if key = XK.xk_quotedbl then
            if c = XK.xk_ediaeresis then 'e' else
            if c = XK.xk_adiaeresis then 'a' else 
            if c = XK.xk_idiaeresis then 'i' else
            if c = XK.xk_odiaeresis then 'o' else
            if c = XK.xk_udiaeresis then 'u' else
            if c = XK.xk_Adiaeresis then 'A' else
            if c = XK.xk_Ediaeresis then 'E' else
            if c = XK.xk_Idiaeresis then 'I' else
            if c = XK.xk_Odiaeresis then 'O' else
            if c = XK.xk_Udiaeresis then 'U' else 
              raise Not_found
          else              
          if key = XK.xk_asciitilde then
            if c = XK.xk_ntilde then 'n' else
            if c = XK.xk_atilde then 'a' else
            if c = XK.xk_otilde then 'o' else
            if c = XK.xk_Atilde then 'A' else
            if c = XK.xk_Ntilde then 'N' else
            if c = XK.xk_Otilde then 'O' else 
              raise Not_found
          else              
            raise Not_found
        in
        bmove frame.frm_buffer.buf_text frame.frm_point 1;
        insert_at_place frame c;
        insert_char frame (Char.chr key)
      with
        Not_found ->
          insert_char frame (Char.chr key)
@

<<function Accents_mode.install>>=
let install buf =
  List.iter (fun key ->
      buf.buf_syntax_table.(key) <- true)
  [ XK.xk_egrave; XK.xk_agrave; XK.xk_igrave; XK.xk_ograve; XK.xk_ugrave;
    XK.xk_Agrave; XK.xk_Egrave; XK.xk_Igrave; XK.xk_Ograve; XK.xk_Ugrave;
    XK.xk_eacute; XK.xk_aacute; XK.xk_iacute; XK.xk_oacute; XK.xk_uacute;
    XK.xk_Aacute; XK.xk_Eacute; XK.xk_Iacute; XK.xk_Oacute; XK.xk_Uacute;
    XK.xk_ccedilla;
    XK.xk_ecircumflex; XK.xk_acircumflex; XK.xk_icircumflex;
    XK.xk_ocircumflex; XK.xk_ucircumflex; XK.xk_Acircumflex;
    XK.xk_Ecircumflex; XK.xk_Icircumflex; XK.xk_Ocircumflex;
    XK.xk_Ucircumflex;
    XK.xk_ediaeresis; XK.xk_adiaeresis; XK.xk_idiaeresis; XK.xk_odiaeresis;
    XK.xk_udiaeresis; XK.xk_Adiaeresis; XK.xk_Ediaeresis; XK.xk_Idiaeresis;
    XK.xk_Odiaeresis; XK.xk_Udiaeresis;
    XK.xk_ntilde; XK.xk_atilde; XK.xk_otilde;
    XK.xk_Atilde; XK.xk_Ntilde; XK.xk_Otilde; ]
@

<<constant Accents_mode.mode>>=
let mode = Ebuffer.new_minor_mode  "accents" [install]
@

<<toplevel Accents_mode._1>>=
let _ = 
  List.iter
    (fun key -> 
      Keymap.add_binding mode.min_map [NormalMap, key] accent
  )
  [ XK.xk_apostrophe; XK.xk_grave; XK.xk_semicolon; XK.xk_asciicircum;
    XK.xk_quotedbl; XK.xk_asciitilde]
@

<<toplevel Accents_mode._2>>=
let _ = 
  define_buffer_action "accents_mode" 
    (fun buf -> 
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode)
@


%-------------------------------------------------------------

<<minor_modes/accents_mode.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Text
open Simple
open Efuns
open Top_window
  
  (* franc;ais strict *)
<<function Accents_mode.accent>>
          
          
<<function Accents_mode.install>>
  
<<constant Accents_mode.mode>>

<<toplevel Accents_mode._1>>

<<toplevel Accents_mode._2>>
    
    
@


\subsection*{[[minor_modes/fill_mode.ml]]}

<<constant Fill_mode.minor_mode_name>>=
let minor_mode_name = "fill"
@

<<function Fill_mode.install>>=
let install buf = ()
@

<<constant Fill_mode.fill_line_len>>=
let fill_line_len = define_option ["fill_line_len"] "" int_option 80
@

<<constant Fill_mode.mode>>=
let mode = Ebuffer.new_minor_mode minor_mode_name [install]
@

<<constant Fill_mode.fill_on_char>>=
let fill_on_char = define_option ["fill_on_char"] "" string_option " "
@

<<toplevel Fill_mode._1>>=
let _ =
  let fill_on_char = !!fill_on_char in
  for i = 0 to String.length fill_on_char - 1 do 
      Keymap.add_binding mode.min_map [NormalMap, Char.code fill_on_char.[i]] 
        electric_insert_space
  done
@

<<toplevel Fill_mode._2>>=
let _ = 
  define_buffer_action (minor_mode_name ^ "_mode")
    (fun buf -> 
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode);
@


%-------------------------------------------------------------

<<minor_modes/fill_mode.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)
open Options
open Text
open Simple
open Efuns
open Top_window
          
<<constant Fill_mode.minor_mode_name>>
  
<<function Fill_mode.install>>

<<constant Fill_mode.fill_line_len>>
  
<<constant Fill_mode.mode>>

<<constant Fill_mode.fill_on_char>>
  
<<toplevel Fill_mode._1>>
  
<<toplevel Fill_mode._2>>
    
    
@


\subsection*{[[minor_modes/paren_mode.ml]]}

<<constant Paren_mode.mode>>=
let mode = Ebuffer.new_minor_mode "paren" []
@

<<function Paren_mode.find_matching>>=
let find_matching  frame = self_insert_command frame; highlight_paren frame
@

<<toplevel Paren_mode._1>>=
let _ = 
  List.iter
    (fun key -> 
      Keymap.add_binding mode.min_map [NormalMap, Char.code key] find_matching
  ) [ ')'; '}'; ']' ]
@

<<toplevel Paren_mode._2>>=
let _ = 
  define_buffer_action "paren_mode" 
    (fun buf -> 
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode)
@


%-------------------------------------------------------------

<<minor_modes/paren_mode.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Text
open Simple
open Efuns
open Top_window

<<constant Paren_mode.mode>>

<<function Paren_mode.find_matching>>
  
<<toplevel Paren_mode._1>>

<<toplevel Paren_mode._2>>
    
    
@


\subsection*{[[minor_modes/tab_mode.ml]]}

<<constant Tab_mode.mode>>=
let mode = Ebuffer.new_minor_mode "tab" []
@

<<function Tab_mode.insert_tab>>=
let insert_tab frame = ignore (insert_string frame "\t")
@

<<toplevel Tab_mode._1>>=
let _ = 
  Keymap.add_binding mode.min_map [NormalMap, XK.xk_Tab] insert_tab
@

<<toplevel Tab_mode._2>>=
let _ = 
  define_buffer_action "tab_mode" 
    (fun buf -> 
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode);
  define_action "insert_tab" insert_tab
@


%-------------------------------------------------------------

<<minor_modes/tab_mode.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Text
open Simple
open Efuns
open Top_window

<<constant Tab_mode.mode>>
  
<<function Tab_mode.insert_tab>>
  
<<toplevel Tab_mode._1>>

<<toplevel Tab_mode._2>>
    
    
@


\section{[[misc/]]}

\subsection*{[[misc/efuns_filebrowser.ml]]}

<<constant Efuns_filebrowser.argv>>=
let argv = Array.to_list Sys.argv
@

<<constant Efuns_filebrowser.regexps>>=
let regexps = List.map (fun str -> str, 
      Str.regexp (Utils.glob_to_regexp str)) (
    match argv with
      program :: dirname :: strs -> strs
    | _ -> failwith "Usage: efuns_filebrowser dirname [regexps]")
@

<<constant Efuns_filebrowser.dirname>>=
let dirname = ref (if Filename.is_relative Sys.argv.(1) then
      Filename.concat (Sys.getcwd ()) Sys.argv.(1) else Sys.argv.(1))
@

<<constant Efuns_filebrowser.display>>=
let display = new WX_display.t ""
@

<<constant Efuns_filebrowser.root>>=
let root = new WX_root.t display 0
@

<<constant Efuns_filebrowser.top>>=
let top = new WX_appli.t root [MinWidth 10; MinHeight 10; MaxHeight (root#height - 200)]
@

<<constant Efuns_filebrowser.adx>>=
let adx = new WX_adjust.t ()
@

<<constant Efuns_filebrowser.ady>>=
let ady = new WX_adjust.t ()
@

<<constant Efuns_filebrowser.hbar>>=
let hbar = new WX_bar.h top#container []
@

<<constant Efuns_filebrowser.viewport>>=
let viewport = new WX_viewport.t hbar#container adx ady []
@

<<constant Efuns_filebrowser.scrollbar>>=
let scrollbar = new WX_scrollbar.v hbar#container ady []
@

<<constant Efuns_filebrowser.tree>>=
let tree = new WX_tree.t viewport#container []
@

<<function Efuns_filebrowser.load>>=
let load filename =
  let _ = Sys.command(Printf.sprintf "efuns_server %s &" filename)
  in ()
@

<<function Efuns_filebrowser.iter_load>>=
let rec iter_load closed dirname basename container =
  try
    let dirname = Filename.concat dirname basename in
    let filenames = Sort.list (<=) (Utils.list_dir dirname) in
    let subdirs = List.fold_left (fun files filename ->
          if filename <> "." && filename <> ".." then
            let fullname = Filename.concat dirname filename in
            let stats = lstat fullname in
            if stats.st_kind = S_DIR then filename::files else
              files
          else files
      ) [] filenames in
    let file_lists = List.fold_left (fun lists (name,regexp) ->
          let newlist = List.rev (List.fold_left (fun files filename ->
                if Str.string_match regexp filename 0 then filename :: files
                else files
              ) [] filenames) in
          let rec iter pos newlist addlist lists =
            match newlist with
            | ele :: tail -> 
                if pos mod 15 = 0 then
                  iter 1 tail [] (((
                        Printf.sprintf "%s[to %s]" name ele), (ele::addlist)) :: lists)
                else
                  iter (pos+1) tail (ele::addlist) lists
            |   [] -> match addlist with [] -> lists | _ -> 
                    (name,addlist) :: lists
          in
          let newlists = iter 1 newlist [] [] in
          match newlists with
            [] -> lists
          | _ -> (List.rev newlists) @ lists
      ) [] regexps in
    (List.map (fun subdir ->
          let label = new WX_label.t container subdir [] in
          let tree  = new WX_tree.t container [] in
          tree#set_desc (iter_load true dirname subdir tree#container);
          branch true label#contained tree#contained
      ) subdirs) @ (
      List.map (fun (name,files) -> 
          let label = new WX_label.t container name [] in
          let tree  = new WX_tree.t container [] in
          tree#set_desc (List.map (fun filename ->
                let label = new WX_button.with_label tree#container filename 
                  [IpadX 0; IpadY 0] 
                  in
                label#set_action (fun () -> 
                    load (Filename.concat dirname filename));                
                leaf 0 label#contained
            ) (List.rev files));
            branch true label#contained tree#contained         
      ) file_lists
    )
  with
    _ -> []
@

<<constant Efuns_filebrowser.file_menu>>=
let file_menu = [|
@

<<toplevel Efuns_filebrowser._1>>=
let _ =
  tree#set_desc (iter_load false (Filename.dirname Sys.argv.(1))
    (Filename.basename Sys.argv.(1))
    tree#container);
  top#container_add hbar#contained;
  hbar#container_add_s [viewport#contained; scrollbar#contained];
  viewport#container_add tree#contained;
  top#setWM_NAME (Printf.sprintf "File Browser: %s" Sys.argv.(1));
  top#add_menu "File" file_menu;
  top#show;
  loop ()
@


%-------------------------------------------------------------

<<misc/efuns_filebrowser.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                             ____                                    *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)



open Xtypes
open WX_types
open WX_tree
open Unix

<<constant Efuns_filebrowser.argv>>
<<constant Efuns_filebrowser.regexps>>

<<constant Efuns_filebrowser.dirname>>
  
<<constant Efuns_filebrowser.display>>
<<constant Efuns_filebrowser.root>>
<<constant Efuns_filebrowser.top>>
<<constant Efuns_filebrowser.adx>>
<<constant Efuns_filebrowser.ady>>
<<constant Efuns_filebrowser.hbar>>
<<constant Efuns_filebrowser.viewport>>
<<constant Efuns_filebrowser.scrollbar>>
<<constant Efuns_filebrowser.tree>>

<<function Efuns_filebrowser.load>>

<<function Efuns_filebrowser.iter_load>>

open WX_filesel
  
<<constant Efuns_filebrowser.file_menu>>
    "Open", (fun _ -> 
        let info = {
            filter = Filename.concat !dirname  "*";
            current_selection= !dirname;
            predicat = (fun _ -> true);
            action = (fun s -> 
                tree#destroy_desc;
                dirname := s;
                tree#set_desc (
                  iter_load false (Filename.dirname s) (Filename.basename s)
                  tree#container));
            cancel = (fun _ -> ());
          }    in
        let filesel = new WX_filesel.t root info [] in
        filesel#show
        );
    "Quit", (fun _ -> exit 0);
  |]
  
  
  
<<toplevel Efuns_filebrowser._1>>
@


\subsection*{[[misc/efuns_texbrowser.ml]]}

<<constant Efuns_texbrowser.display>>=
let display = new WX_display.t ""
@

<<constant Efuns_texbrowser.root>>=
let root = new WX_root.t display 0
@

<<constant Efuns_texbrowser.top>>=
let top = new WX_appli.t root [MinWidth 10; MinHeight 10]
@

<<constant Efuns_texbrowser.tree>>=
let tree = new WX_tree.t top#container []
@

<<constant Efuns_texbrowser.regexp>>=
let regexp = Str.regexp "\(\\input\|\\section\|\\subsection\|\\subsubsection\|\\chapter\)[*]?{\([^}]+\)}"
@

<<function Efuns_texbrowser.load>>=
let load filename pos all =
  let _ = Sys.command(Printf.sprintf "efuns_server %s -pos %d -str \"%s\" &" filename pos all)
  in ()
@

<<constant Efuns_texbrowser.filename>>=
let filename = ref (if Array.length Sys.argv = 2 then
      Sys.argv.(1) else 
      failwith "Usage: efuns_texbrowser filename")
@

<<constant Efuns_texbrowser.dirname>>=
let dirname = ref (Filename.dirname !filename)
@

<<constant Efuns_texbrowser.path>>=
let path = ref [ !dirname ]
@

<<function Efuns_texbrowser.iter_load>>=
let rec iter_load closed filename container =
  let label = new WX_button.with_label container filename [] in
  try
    let filename = try
        Utils.find_in_path !path filename
      with Not_found -> 
          Utils.find_in_path !path (filename^".tex")
    in
    label#set_action (fun () -> load filename 0 "");
    let inc = open_in filename in
    let s = Utils.read_string inc in
    close_in inc;
    let rec iter_search pos list = 
      try
        let newpos = Str.search_forward regexp s pos in
        let keyword = Str.matched_group 1 s in
        let all = Str.matched_group 0 s in
        iter_search (newpos+String.length keyword) (
          (all, keyword,Str.matched_group 2 s,newpos)::list)
      with
        _ -> List.rev list
    in
    let list =  iter_search 0 [] in
    if list = [] then leaf 0 label#contained else
    let tree2 = new WX_tree.t container [] in
    tree2#set_desc (List.map (
        fun (all,keyword,name,pos) -> 
          match keyword with
            "input" -> iter_load true name tree2#container
          | _ ->
              let (offset,prefix) =
                match keyword with
                  "section" -> 0, "s:"
                | "subsection" -> 10, "ss:"
                | "subsubsection" -> 20, "sss:"
                | _ -> 30,""
              in
              leaf offset (
                  let button = new WX_button.with_label tree2#container (
                      prefix^name) [] 
                  in
                  button#set_action (fun () -> load filename pos all);
                  button#contained
                  )
      ) list);
    branch closed label#contained tree2#contained
  with
    _ -> 
      leaf 0 label#contained
@

<<constant Efuns_texbrowser.file_menu>>=
let file_menu = [|
@

<<toplevel Efuns_texbrowser._1>>=
let _ =
  tree#set_desc [iter_load false Sys.argv.(1) tree#container];
  top#setWM_NAME (Printf.sprintf "LaTeX Browser: %s" !filename);
  top#container_add tree#contained;
  top#add_menu "File" file_menu;
  top#add_button "Reload" (fun _ () ->
      tree#destroy_desc;
      tree#set_desc [iter_load false !filename tree#container];      
  );
  top#add_separator;
  top#show;
  loop ()
@


%-------------------------------------------------------------

<<misc/efuns_texbrowser.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                             ____                                    *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)



open Xtypes
open WX_types
open WX_tree


<<constant Efuns_texbrowser.display>>
<<constant Efuns_texbrowser.root>>
<<constant Efuns_texbrowser.top>>
<<constant Efuns_texbrowser.tree>>

<<constant Efuns_texbrowser.regexp>>

<<function Efuns_texbrowser.load>>

<<constant Efuns_texbrowser.filename>>
  
<<constant Efuns_texbrowser.dirname>>
<<constant Efuns_texbrowser.path>>
  
<<function Efuns_texbrowser.iter_load>>

open WX_filesel
  
<<constant Efuns_texbrowser.file_menu>>
    "Open", (fun _ -> 
        let info = {
            filter = Filename.concat !dirname  "*.tex";
            current_selection= !dirname;
            predicat = (fun _ -> true);
            action = (fun s -> 
                tree#destroy_desc;
                filename := s;
                dirname := Filename.dirname s;
                top#setWM_NAME (Printf.sprintf "LaTeX Browser: %s" !filename);
                tree#set_desc [iter_load false s tree#container]);
            cancel = (fun _ -> ());
          }    in
        let filesel = new WX_filesel.t root info [] in
        filesel#show              
        );
    "Quit", (fun _ -> exit 0);
  |]

<<toplevel Efuns_texbrowser._1>>
@


\subsection*{[[misc/local.ml]]}

<<type Local.var>>=
type 'a var = string
@

<<type Local.vars>>=
type vars = Obj.t ref Vars.t ref
@

<<function Local.vars>>=
let vars () = ref Vars.empty
@

<<function Local.create>>=
let create name print input =
  try
    let _ = Hashtbl.find vars_table name in
    failwith (Printf.sprintf "A variable named %s already exists" name)
  with
    Not_found ->
      Hashtbl.add vars_table name (magic print,magic input);
      name
@

<<function Local.no_print>>=
let no_print _ = "<abstr>"
@

<<function Local.no_input>>=
let no_input (s : string) = failwith "This variable can not be set"
@

<<function Local.create_abstr>>=
let create_abstr name = create name no_print no_input
@

<<function Local.create_string>>=
let create_string name = create name id id
@

<<function Local.create_int>>=
let create_int name = create name string_of_int int_of_string
@

<<function Local.create_float>>=
let create_float name = create name string_of_float float_of_string
@

<<function Local.get>>=
let get vars var =  Obj.magic !(Vars.find var !vars)
@

<<function Local.set>>=
let set vars var value =
  let value = repr value in
  try
    let r = Vars.find var !vars in
    r := value
  with
    Not_found -> 
      vars := Vars.add var (ref value) !vars
@

<<function Local.get_print>>=
let get_print vars var =
  let value = get vars var in
  let (p,i) = Hashtbl.find vars_table var in
  p value  
@

<<function Local.set_input>>=
let set_input vars var value =
  let (p,i) = Hashtbl.find vars_table var in
  set vars var (i value)
@

<<function Local.list>>=
let list vars =
  let list = ref [] in
  Vars.iter (fun var value ->
      list := var :: !list;
  ) !vars;
  !list
@

<<constant Local.print>>=
let print = get_print
@

<<constant Local.input>>=
let input = set_input
@


%-------------------------------------------------------------

<<misc/local.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                             ____________                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

(* We use strings instead of ints to enable migration of datas between
editors (data must be symbolic) *)

open Obj
  
<<type Local.var>>

module Vars = Map.Make (struct  
      type t = string
      let compare = compare end)

<<type Local.vars>>
<<function Local.vars>>

let (vars_table :
    (string, (Obj.t -> string) * (string -> Obj.t)) Hashtbl.t)
  = Hashtbl.create 203

<<function Local.create>>

<<function Local.no_print>>
<<function Local.no_input>>
<<function Local.create_abstr>>
  
external id : 'a -> 'a = "%identity"

<<function Local.create_string>>
<<function Local.create_int>>
<<function Local.create_float>>
  
<<function Local.get>>
<<function Local.set>>
      
<<function Local.get_print>>
  
<<function Local.set_input>>
  
<<function Local.list>>
  
<<constant Local.print>>
<<constant Local.input>>
@


\section{[[prog_modes/]]}

\subsection*{[[prog_modes/makefile_mode.ml]]}

<<constant Makefile_mode.mkfile_vars>>=
let mkfile_vars= Str.regexp "\(\$([a-zA-Z0-9_]*)\)\|\([a-zA-Z0-9_]+=\)"
@
%$

<<constant Makefile_mode.mkfile_target>>=
let mkfile_target= Str.regexp "^.*:"
@

<<constant Makefile_mode.mkfile_rules>>=
let mkfile_rules= Str.regexp "^\t.*$"
@
%$

<<constant Makefile_mode.rules_color>>=
let rules_color = define_option ["makefile_mode";"rules_color"] "" 
  string_option "red"
@

<<constant Makefile_mode.target_color>>=
let target_color = define_option ["makefile_mode"; "target_color"] ""
    string_option "cadetblue"
@

<<constant Makefile_mode.vars_color>>=
let vars_color = define_option ["makefile_mode"; "vars_color"] ""
    string_option "blue"
@

<<function Makefile_mode.makefile_color>>=
let makefile_color buf =
  let location = buf.buf_location in
  color buf mkfile_rules false
    (make_attr (get_color location !!rules_color) 1 0 false);
  color buf mkfile_target false 
    (make_attr (get_color location !!target_color) 1 0 false);
  color buf mkfile_vars false 
    (make_attr (get_color location !!vars_color) 1 0 false)
@

<<constant Makefile_mode.c_c>>=
let c_c = (ControlMap,Char.code 'c')
@

<<function Makefile_mode.install>>=
let install buf =
  makefile_color buf;
  execute_buffer_action "tab_mode" buf
@

<<constant Makefile_mode.mode>>=
let mode = Ebuffer.new_major_mode "Makefile" [makefile_color]
@

<<constant Makefile_mode.local_map>>=
let local_map = define_option ["makefile_mode"; "local_map"] ""
    (list_option binding_option) []
@

<<constant Makefile_mode.interactives_map>>=
let interactives_map = define_option ["makefile_mode"; "interactives_map"] ""
    (list_option string2_option) 
  []
@

<<toplevel Makefile_mode._1>>=
(* let insert_tab frame = ignore (insert_string frame "\t") *)
  
let _ =
  if !!local_map = [] then
    local_map =:= [
      [c_c; ControlMap, Char.code 'c'], "makefile_mode.compile";    
      [ControlMap, Char.code 'l'], "makefile_mode.color_buffer";
     (*  [NormalMap, XK.xk_Tab], "insert_tab"; *)
    ];
  if !!interactives_map = [] then 
        interactives_map =:= [
          "compile", "makefile_mode.compile";
          "color_buffer", "makefile_mode.color_buffer";
      ]
@

<<function Makefile_mode.makefile_mode>>=
let makefile_mode frame = Ebuffer.set_major_mode frame.frm_buffer mode
@

<<toplevel Makefile_mode._2>>=
let _ = 
  define_action "makefile_mode.compile" (compile c_find_error);
  define_action "makefile_mode.color_buffer" 
    (fun frame -> makefile_color frame.frm_buffer);
(*  define_action "insert_tab" insert_tab; *)
  define_action "makefile_mode" makefile_mode;
  ()
@

<<toplevel Makefile_mode._3>>=
let _ =
  let map = mode.maj_map in
  List.iter (fun (keys, action) ->
      try
        Keymap.add_binding map keys (execute_action action)
      with e ->
          Log.printf "Error for action %s" action;
          Log.exn "%s\n" e;
  
  ) !!local_map;
  List.iter (fun (name, action) ->
      try
        add_interactive map name (execute_action action)
      with e ->
          Log.printf "Error for action %s" action;
          Log.exn "%s\n" e;
          
  ) !!interactives_map;
  ()
@

<<toplevel Makefile_mode._4>>=
let _ = 
  (* Keymap.add_prefix mode.maj_map [c_c];   *)
  Efuns.add_start_hook (fun location ->
      let alist = get_global (location) Ebuffer.modes_alist in
      set_global location Ebuffer.modes_alist 
        ((".*/[Mm]akefile.*",mode)
        :: alist);
      add_option_parameter location vars_color;
      add_option_parameter location target_color;
      add_option_parameter location rules_color;
      )   
@


%-------------------------------------------------------------

<<prog_modes/makefile_mode.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Options
open Text
open Keymap
open Efuns
open Simple
open Compil
open Complex
open Window

<<constant Makefile_mode.mkfile_vars>>
<<constant Makefile_mode.mkfile_target>>
<<constant Makefile_mode.mkfile_rules>>

<<constant Makefile_mode.rules_color>>
<<constant Makefile_mode.target_color>>
<<constant Makefile_mode.vars_color>>
  
<<function Makefile_mode.makefile_color>>
 
<<constant Makefile_mode.c_c>>

<<function Makefile_mode.install>>
  
<<constant Makefile_mode.mode>>
  

<<constant Makefile_mode.local_map>>

<<constant Makefile_mode.interactives_map>>

<<toplevel Makefile_mode._1>>

<<function Makefile_mode.makefile_mode>>
        
<<toplevel Makefile_mode._2>>

<<toplevel Makefile_mode._3>>

  
<<toplevel Makefile_mode._4>>
@


\subsection*{[[prog_modes/ocaml_toplevel.ml]]}

<<function Ocaml_toplevel.type_buffer>>=
let type_buffer buf =
  let text = buf.buf_text in
  let start_point = Text.add_point text in
  let end_point = Text.add_point text in
  set_position text end_point (size text);
  let lexbuf = lexing text start_point end_point in
  try  
    let (str, env) = Type.type_buffer buf.buf_name lexbuf !!ocaml_path in
    remove_point text start_point;
    remove_point text end_point;
    (str,env)
  with x ->
      remove_point text start_point;
      remove_point text end_point;
      raise x
@

<<constant Ocaml_toplevel.compiled_idents>>=
let compiled_idents = Local.create_abstr "compiled_idents"
@

<<function Ocaml_toplevel.all_idents>>=
let all_idents buf =
  try
    let (ids, version) = Local.get buf.buf_vars compiled_idents in
    if Text.version buf.buf_text = version then ids else raise Not_found
  with
    _ -> 
      let _, (str,env) = Utils.do_and_format type_buffer buf in
      let ids = Type.iter_structure str [] GlobalDefined in
      set_local buf compiled_idents (ids, Text.version buf.buf_text);
      ids      
@

<<function Ocaml_toplevel.find_value_type>>=
let find_value_type sign names =
  let rec solv sign names =
    match names with
      [] -> raise Not_found
    | name :: names ->
        let rec find sign =
          match sign with
            [] -> raise Not_found
          | sg :: sign ->
              match sg with
                Tsig_value (ident,vd) 
                when Ident.name ident = name ->
                  vd.val_type
              | Tsig_module (ident,Tmty_signature sign ) 
                when Ident.name ident = name ->
                  solv sign names
              | _ -> find sign
        in
        find sign
  in
  solv sign names
@

<<function Ocaml_toplevel.print_type>>=
let print_type frame = 
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  let top_window = Window.top frame.frm_window in
  try
    let ids = all_idents buf in
    let text = buf.buf_text in
    let pos = get_position text point in
    List.iter (fun (p,l,t,w) ->
        if l.loc_start-1 <= pos && l.loc_end+1 >= pos then
          Top_window.message top_window 
            (Utils.format_to_string 
              (fun () -> 
                printtyp_path p;
                Format.print_string " : ";
                printtyp_type_expr t
            ) ())
    ) ids
  with
    _ ->
  let name = find_long_word buf point in
  let names = parse_name name in
  let test_name modname names =
    try    
      let ps = Ocaml_env.find_pers_struct !!ocaml_path modname in
      let typ = find_value_type ps.ps_sig names in
      let styp = format_to_string () in
      Format.print_string modname;
      let rec iter list =
        match list with
          [] -> ()
        | name :: tail -> 
            Format.print_string ".";
            Format.print_string name;
            iter tail
      in
      iter names;
      Format.print_string ": ";
      printtyp_type_expr typ;
      Format.print_flush ();
      Top_window.message top_window !styp    
    with
      Env.Error e ->
        let m,s1,s2,s3 =
          match e with    
            Not_an_interface s -> "Not_an_interface",s,"",""
          | Corrupted_interface s -> "Corrupted_interface",s,"",""
          | Illegal_renaming (s1 , s2) ->
              "Illegal_renaming",s1,s2,"" 
          | Inconsistent_import (s1,s2,s3) ->
              "Inconsistent_import",s1,s2,s3
        in
        Top_window.message top_window 
          (Printf.sprintf "Env error: %s %s %s %s" m s1 s2 s3)
  in
  try
    match names with
      modname :: names when modname = String.capitalize modname -> 
        test_name modname names
    | _ -> raise Not_found
  with
    Not_found ->
      let rec iter env =
        match env with
          [] -> failwith "Can not find type"
        | modname :: env ->
            try
              test_name modname names
            with
              Not_found -> iter env
      in
      iter (find_env buf point)
@

<<constant Ocaml_toplevel.back_list>>=
let back_list = ref []
@

<<function Ocaml_toplevel.find_implementation>>=
let find_implementation frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let word = find_long_word buf point in
  let ids = all_idents buf in
  let pos = get_position text point in
  try
    List.iter (fun (pp,l,t,w) ->
        if l.loc_start-1 <= pos && l.loc_end+1 >= pos then
          begin
            List.iter (fun (p,l,t,w) ->
                if p = pp && (w <> Type.Used)then
                  (Text.set_position text frame.frm_point l.loc_start;
                    raise Exit)
            ) ids;  
            match pp with
              Path.Pdot (Path.Pident id,name,pos) when Ident.persistent id ->
              (* Look in another file ... *)
                let ident = Ident.name id in
                let file = ident ^ ".ml" in
                file.[0] <- Char.lowercase file.[0];
                let filename = 
                  try
                    Utils.find_in_path !!ocaml_path file
                  with _ -> failwith (Printf.sprintf "No %s in path" file)
                in 
                let location = frame.frm_location in
                let buf = Ebuffer.read location filename (Keymap.create ()) in
                let text = buf.buf_text in
                let frame = try
                    Frame.find_buffer_frame location buf
                  with Not_found ->
                      Frame.create frame.frm_window None buf
                in
                Frame.active frame;
                let ids = all_idents buf in
                List.iter (fun (p,l,t,w) ->
                    match p with
                      Path.Pident id ->
                        if Ident.name id = name && w = Type.GlobalDefined then
                          (Text.set_position text frame.frm_point l.loc_start;
                            raise Exit)
                    | _ -> ()
                ) ids;
            | _  -> ()
          end
    
    ) ids;
  with
    Exit -> 
      let filename = 
        match buf.buf_filename with
          None -> buf.buf_name
        | Some filename -> filename
      in
      back_list := (filename,Text.get_position text point) :: !back_list
@

<<function Ocaml_toplevel.backward_implementation>>=
let rec backward_implementation frame =
  match !back_list with
    [] -> failwith "No more buffers in history"
  | (filename, pos) :: tail ->
      back_list := tail;
      let location = frame.frm_location in
      let buf = Ebuffer.read location filename (Keymap.create ()) in
      let frame = Frame.create frame.frm_window None buf in
      Frame.active frame
@

<<function Ocaml_toplevel.mouse_find_implementation>>=
let mouse_find_implementation frame =
  let frame = Top_window.mouse_set_active (Window.top frame.frm_window) in
  find_implementation frame
@

<<constant Ocaml_toplevel.mode>>=
let mode = Ebuffer.new_minor_mode "compiler" []
@

<<constant Ocaml_toplevel.local_map>>=
let local_map = define_option ["ocaml_compiler_mode"; "local_map"] ""
    (list_option binding_option) []
@

<<toplevel Ocaml_toplevel._1>>=
let _ = 
  if !!local_map = [] then 
    local_map =:= [
      [c_c; ControlMap, Char.code 'i'] , "ocaml_mode.find_implementation";
      [c_c; ControlMap, XK.xk_BackSpace], "ocaml_mode.backward_implementation";
      [c_c; ControlMap, Char.code 't'], "ocaml_mode.print_type";
    ];
  Keymap.add_binding mode.min_map [ControlMap, XK.xk_Pointer_Button1]
    mouse_find_implementation
@

<<toplevel Ocaml_toplevel._2>>=
let _ = 
  define_buffer_action "ocaml_compiler_mode" 
    (fun buf -> 
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode);
  define_action "ocaml_compiler_mode.find_implementation" find_implementation;
  define_action "ocaml_compiler_mode.backward_implementation" backward_implementation;
  define_action "ocaml_compiler_mode.print_type" print_type;
@


%-------------------------------------------------------------

<<prog_modes/ocaml_toplevel.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                             Efuns                                   *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Ocaml_mode
open Options
open Text
open Efuns
open Interactive
open Simple
open Select
open Compil
open Eval
open Complex
open Abbrevs  
open Env
open Types
open Keymap
open Window
open Location
open Compat_comp
open Type
open Ocaml_env
  
<<function Ocaml_toplevel.type_buffer>>

<<constant Ocaml_toplevel.compiled_idents>>

<<function Ocaml_toplevel.all_idents>>

<<function Ocaml_toplevel.find_value_type>>
    
<<function Ocaml_toplevel.print_type>>

<<constant Ocaml_toplevel.back_list>>
          
<<function Ocaml_toplevel.find_implementation>>

<<function Ocaml_toplevel.backward_implementation>>
      
<<function Ocaml_toplevel.mouse_find_implementation>>
  
  

<<constant Ocaml_toplevel.mode>>

<<constant Ocaml_toplevel.local_map>>
<<toplevel Ocaml_toplevel._1>>

<<toplevel Ocaml_toplevel._2>>

    
    
@


