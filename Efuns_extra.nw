\section{[[commons2/]]}

\subsection*{[[commons2/local.mli]]}


%-------------------------------------------------------------

<<commons2/local.mli>>=

<<signature type Local.vars>>
<<signature function Local.vars>>

<<signature type Local.var>>
<<signature functions Local.create_xxx>>
(* internal *)
<<signature function Local.create>>

<<signature function Local.get>>
<<signature function Local.set>>

<<signature functions Local>>
@

\subsection*{[[commons2/local.ml]]}


%-------------------------------------------------------------

<<commons2/local.ml>>=
<<copyright header>>

(* We use strings instead of ints to enable migration of datas between
editors (data must be symbolic) *)

  
<<type Local.var>>

<<module Local.Vars>>

<<type Local.vars>>
<<function Local.vars>>

<<global Local.vars_table>>

<<function Local.create>>

<<function Local.no_print>>
<<function Local.no_input>>
<<function Local.create_abstr>>
  
external id : 'a -> 'a = "%identity"

<<function Local.create_string>>
<<function Local.create_int>>
<<function Local.create_float>>
  
<<function Local.get>>
<<function Local.set>>
      
<<function Local.get_print>>
  
<<function Local.set_input>>
  
<<function Local.list>>
  
<<constant Local.print>>
<<constant Local.input>>
@


\section{[[core/]]}

\subsection*{[[core/var.ml]]}

<<core/var.ml>>=
<<copyright header efuns>>
open Efuns
open Globals

<<function Efuns.set_global>>
<<function Efuns.set_local>>
<<function Efuns.get_var>>
          
<<function Efuns.get_global>>
<<function Efuns.get_local>>
  
<<function Efuns.set_minor_var>>
<<function Efuns.set_major_var>>
  

@

\subsection*{[[core/attr.ml]]}

<<core/attr.ml>>=
<<copyright header efuns>>
open Efuns

(* see also Text.make_attr *)

<<function Window.get_font>>
        
<<function Window.get_color>>

@

\subsection*{[[core/hook.ml]]}

<<core/hook.ml>>=
<<copyright header efuns>>

<<constant Efuns.start_hooks>>
<<function Efuns.add_start_hook>>

<<function Efuns.exec_hooks>>

<<function Efuns.add_hook>>

<<function Frame.exec_named_hooks>>

<<function Ebuffer.exec_named_buf_hooks>>

<<function Ebuffer.exec_named_buf_hooks_with_abort>>

@

\subsection*{[[core/action.ml]]}

<<core/action.ml>>=
<<copyright header efuns>>
open Efuns

<<global Efuns.actions>>

<<function Efuns.define_action>>

<<function Efuns.define_buffer_action>>

<<function Efuns.get_action>>

<<function Efuns.execute_action>>

<<function Efuns.execute_buffer_action>>

@

\subsection*{[[core/globals.ml]]}

<<core/globals.ml>>=
<<copyright header efuns>>
open Efuns

(* there are other globals: actions, start_hooks, etc *)

<<global Efuns.global_location>>
<<function Efuns.location>>

let with_lock f =
  let loc = location () in
  Mutex.lock loc.loc_mutex;
  Common.finalize f (fun () -> Mutex.unlock loc.loc_mutex)
  
<<function Efuns.error>>

(*************************************************************************)
(*      Initialization      *)
(*************************************************************************)
  
(* Les variables importantes dans le reste du programme. *)
open Options

<<constant Efuns.check>>

<<constants Efuns.debug_xxx>>

<<constant Efuns.load_path>>

<<constant Efuns.path>>
  
<<constant Efuns.efuns_path>>
  
<<toplevel Efuns._1>>

(* used in some major mode *)
<<constant Efuns.font>>
  
(*--------------------    Ressources *)
<<constant Efuns.xdefaults>>

<<constant Efuns.x_res>>
<<toplevel Efuns._2>>
  
<<constant Efuns.t>>

(*
  let _ = Printf.printf "%d %d %s %s %s" !width !height !font !fg !bg; 
  print_newline () 
*)
  

@

\subsection*{[[core/efuns.ml]]}


%-------------------------------------------------------------

<<core/efuns.ml>>=
<<copyright header2>>
(* Useful types for Efuns *)

<<exception Efuns.UnboundKey>>

(*************************************************************************)
(* Keymaps and actions *)
(*************************************************************************)

<<type Efuns.map>>
<<type Efuns.keySym>>
<<type Efuns.key>>

<<type Efuns.action>>

and action_name = string

<<type Efuns.generic_action>>

<<type Efuns.mod_ident>>

and keys = key list

<<type Efuns.prefix>>

<<type Efuns.binding>>

(*************************************************************************)
(* Buffers *)
(*************************************************************************)

<<type Efuns.buffer>>

<<type Efuns.major_mode>>

<<type Efuns.minor_mode>>

(*************************************************************************)
(* Frames *)
(*************************************************************************)
  
<<type Efuns.frame>>

<<type Efuns.status_info>>

<<type Efuns.status>>

<<type Efuns.line_repr>>

(*************************************************************************)
(* Windows *)
(*************************************************************************)

<<type Efuns.top_window>>

<<type Efuns.window>>

<<type Efuns.window_up>>

<<type Efuns.window_down>>

(*************************************************************************)
(* The world *)
(*************************************************************************)

<<type Efuns.location>>

(*************************************************************************)
(* Misc *)
(*************************************************************************)

(* used by frame, so can't be in top_window.ml *)
<<function Efuns.backend>>

<<type Efuns.sens>>
<<type Efuns.to_regexp>>

<<function Efuns.string_to_regex>>

open Options    
<<constant Efuns.regexp_option>>
@


\subsection*{[[core/text.ml]]}


<<function Text.insert_at_end>>=
let insert_at_end tree str =
  let text = tree.tree_text in
  low_insert tree text.text_size str |> ignore;
  text.text_history <- [];
  text.text_modified <- text.text_modified + 1
@




<<function Text.find_xy>>=
let find_xy text point line pos =
  let text = text.tree_text in    
  let gpos = text.gpoint.pos in
  let gline = text.gpoint.line in
  let gap_end = gpos + text.gsize in
  let y,x =
    if pos >= gap_end then
(* go forward *)
      let rec iter line =
        if line >= text.text_nlines then
          text.text_nlines - 1
        else
        if text.text_newlines.(line).position > pos then line - 1
        else
          iter (line + 1)
      in
      let line = 
        if point > gap_end && pos > point then
          iter (line+1) 
        else
          iter (gline+1) 
      in
      if line = gline then
        let gchars = gpos - text.text_newlines.(gline).position in
        line, gchars + pos - gap_end
      else
        line, pos - text.text_newlines.(line).position
    else
(* go backward *)
    let rec iter line =
      if line > 0 then
        if text.text_newlines.(line).position > pos then 
          iter (line - 1)
        else
          line
      else
        0
    in
    let line = 
      if point < gpos && pos <= point then
        iter line 
      else
        iter gline in
    line, pos - text.text_newlines.(line).position
  in
  x,y
@


<<function Text.read>>=
let read inc =
  create (read_string inc)
@

<<function Text.save>>=
let save tree outc =
  let text = tree.tree_text in    
  let str = text.text_string in
  let gpos = text.gpoint.pos in
  let gsize = text.gsize in
  output outc str 0 gpos;
  output outc str (gpos + gsize) 
  (text.text_size - gpos - gsize)
@




<<function Text.compare>>=
let compare text p1 p2 = 
  compare p1.pos p2.pos
@

%<<function Text.add>>=
%(*
%let add text point delta =
%  let gpos = text.gpoint.pos in
%  let gap_end = gpos + text.gsize in
%  if point <= gpos && point + delta > gpos then
%    point + delta + text.gsize
%  else
%  if point >= gap_end && point+delta < gap_end then
%    point + delta - text.gsize
%  else
%    point + delta
%*)
%@

<<function Text.get_char>>=
let get_char tree point =
  let text = tree.tree_text in    
  let pos = point.pos in
  let gpos = text.gpoint.pos in
  let pos = 
    if pos = gpos 
    then pos + text.gsize 
    else pos
  in
  if pos < text.text_size 
  then text.text_string.[pos]
  else '\000'
@


<<function Text.fmove_res>>=
let fmove_res tree p delta =
  let text = tree.tree_text in    
  if delta = 0 then 0 else
  let gpos = text.gpoint.pos in
  let size = text.text_size in
  let gap_end = gpos + text.gsize in
  let gline = text.gpoint.line in
  let pos = p.pos in
  let old_pos = pos in
  let lines = text.text_newlines in
  let rec iter y point end_point =
    if end_point > point then
      let end_line = lines.(y+1).position in
      if end_point >= end_line then
        iter (y+1) end_line end_point
      else
        (y, end_point)
    else
      (y,point)
  in
  let (y,pos) = 
    if pos + delta <= gpos then
      iter p.line pos (pos+delta)
    else
    if pos >= gap_end then
      let delta = min delta (size - pos) in
      iter p.line pos (pos + delta)
    else
    let delta = min (delta - (gpos - pos)) (size - gap_end) in
    iter gline gap_end (gap_end + delta) 
  in
  p.pos <- pos;
  p.line <- y;
  low_distance text old_pos pos
@

<<function Text.bmove_res>>=
let bmove_res tree p delta =
  let text = tree.tree_text in    
  if delta = 0 then 0 else
  let gpos = text.gpoint.pos in
  let gap_end = gpos + text.gsize in
  let gline = text.gpoint.line in
  let pos = p.pos in
  let old_pos = pos in
  let lines = text.text_newlines in
  let rec iter y end_point =
    let start_line = lines.(y).position in
    if end_point >= start_line then
      (y, end_point)
    else
      iter (y-1) end_point
  in
  let (y,pos) = 
    if pos - delta >= gap_end then
      if pos - delta < lines.(gline+1).position then
        (
          gline, pos - delta)
      else
        iter p.line (pos-delta)
    else
    if pos <= gpos then
      let delta = min delta pos in
      iter p.line (pos - delta)
    else
    let delta = min (delta - (pos - gap_end)) gpos in
    iter gline (gpos - delta) 
  in
  p.pos <- pos;
  p.line <- y;
  low_distance text pos old_pos
@

<<function Text.bmove>>=
let bmove text p delta = 
  bmove_res text p delta |> ignore
@
<<function Text.fmove>>=
let fmove text p delta = 
  fmove_res text p delta |> ignore
@

<<function Text.to_string>>=
let to_string tree =
  let text = tree.tree_text in    
  let len = text.text_size - text.gsize in
  if len = 0 
  then "" 
  else begin
    let str = String.create len in
    let gpos = text.gpoint.pos in
    let gap_end = gpos + text.gsize in
    String.blit text.text_string 0 str 0 gpos;
    String.blit text.text_string gap_end str gpos (len- gpos);
    str
  end
@

% ?? -> <>
<<function Text.clean_text>>=
let clean_text text =
  if not text.text_clean then
    let size = text.text_size in
    let gsize = text.gsize in
    let string = text.text_string in
    move_gpoint_to text size;
    String.fill string (size - gsize) gsize '\000';
    text.text_clean <- true
@

<<[[Text.text]] other fields>>=
mutable text_clean : bool;
@
% useful for?



<<function Text.blit>>=
let blit str tree point len =
  let text = tree.tree_text in      
  let pos = point.pos in
  let len = min len (low_distance text pos text.text_size) in
  let gpos = text.gpoint.pos in
  let gap_end = gpos + text.gsize in
  if pos+len >= gpos && pos < gap_end 
  then clean_text text;
  (try
    String.blit text.text_string pos str 0 len
   with e -> raise e
   );
  len
@


<<function Text.set_position>>=
let set_position tree point pos =
  let text = tree.tree_text in    
  move_point_to tree point
    (if pos > text.gpoint.pos 
     then pos + text.gsize
     else pos
     )
@

<<function Text.sub>>=
let sub text point len =
  let str = String.create len in
  blit str text point len |> ignore;
  str
@









<<function Text.move_res>>=
let move_res text point n =
  if n > 0 
  then fmove_res text point n
  else bmove_res text point (-n)
@

<<function Text.move>>=
let move text point n = 
  move_res text point n |> ignore
@


<<function Text.clear>>=
let clear tree =
  let text = tree.tree_text in      
  low_delete tree 0 (text.text_size - text.gsize) |> ignore;
  text.text_history <- [];
  List.iter (fun p -> p.pos <- 0; p.line <- 0) text.text_points
@



<<function Text.region>>=
let rec region tree p1 p2 =
  if p1>p2 
  then region tree p2 p1
  else sub tree p1 (distance tree p1 p2)
@

%<<function Text.goto_xy>>=
%(*
%let goto_xy tree point x y =
%  let text = tree.tree_text in    
%  let y =
%    if y < text.text_nlines then y
%    else text.text_nlines - 1
%  in
%  point.pos <- text.text_newlines.(y).position;
%  point.line <- y;
%  fmove tree point x |> ignore
%*)
%@

<<function Text.update>>=
let update tree str =
  let text = tree.tree_text in    
  let newlines = compute_newlines str in
  let len = String.length str in
  text.text_points |> List.iter (fun point -> 
    point.pos <- get_position tree point
  );
  text.text_string <- str;
  text.text_attrs <- (Array.create len direct_attr);
  text.text_size <- len;
  text.gpoint <- { pos = 0; line = 0 };
  text.gsize <- 0;
  text.text_newlines <- newlines;
  text.text_nlines <- Array.length newlines;
  text.text_modified <- text.text_modified + 1 ;
  text.text_clean <- true;
  text.text_history <- [];
  text.text_points |> List.iter (fun point -> 
      let pos = point.pos in
      point.pos <- 0;
      point.line <- 0;
      set_position tree point pos
  ) 
  
@

<<function Text.lexing>>=
let lexing tree curseur end_point =
  let text = tree.tree_text in    
  clean_text text;
  Lexing.from_function 
    (fun str len ->
      let len = min len (distance tree curseur end_point) in
      let len = blit str tree curseur len in
      fmove tree curseur len |> ignore;
      len
  )
@

<<function Text.start_session>>=
let start_session tree =   
  let text = tree.tree_text in    
  text.text_modified
@



%-------------------------------------------------------------

<<core/text.ml>>=
<<copyright header2>>

(* A FAIRE:
On doit faire converger ce text vers un text directement affichable par
WX_text. Pour cela:

Modifier WX_text pour qu'il se satisfasse de l'interface de Text.
En particulier, il doit n'utiliser que les fonctions suivantes:

Text.representation text line --> string (buffer or copy) * int (position)
Text.items line -> item array
  
Il doit aussi utiliser la structure un peu particuliere de l'arbre utiliser
ici.
  
*)
open Options
open Utils

<<type Text.position>>
<<type Text.version>>

<<type Text.attribute>>
<<type Text.delta>>
<<type Text.session>>


<<type Text.line>>

<<type Text.point>>

<<type Text.repr>>

<<type Text.text>>
  
<<type Text.action>>


type tree_desc =
      { mutable tree_nlines: int;
        mutable tree_width: int;
        mutable tree_height: int;
(*        mutable tree_parts: 'a array; *)
(*        mutable tree_up: tree tree_desc; *)
        mutable tree_pos: int;
        mutable tree_modified: bool;
        mutable line_height: int;
        mutable line_width: int;

        mutable tree_text: text 
}

let make_text text lines =
  let nlines = Array.length lines in
  let tree = {
      tree_nlines = nlines;
      tree_width = 0;
      tree_height = 0;
(*
      tree_parts = [| Lines {
          tree_nlines = nlines;
          tree_width = 0;
          tree_height = 0;
          tree_parts = lines;
          tree_up = tree;
          tree_pos = 0;
          tree_modified = true;
          line_height = 0;
          line_width = 0;
          tree_text = text;      
        }|];
      tree_up = tree;
*)
      tree_pos = 0;
      tree_modified = true;
      line_height = 0;
      line_width = 0;
      tree_text = text;
    }
  in tree

type t = tree_desc
  
<<function Text.version>>
  
<<function Text.nbre_lines>>
  
<<function Text.size>>
  
<<function Text.point_col>>

<<function Text.make_attr>>

<<constant Text.direct_attr>>
<<constant Text.inverse_attr>>

<<function Text.mk_line_with_pos>>


<<function Text.move_gpoint_to>>

<<function Text.cancel_repr>>

<<constant Text.add_amount>>
<<function Text.extend_gap>>

<<function Text.low_insert>>

<<function Text.low_delete>>

<<function Text.undo>>

<<function Text.insert_at_end>>

<<function Text.insert_res>>

<<function Text.insert>>
  
<<function Text.delete_res>>

<<function Text.delete>>

  
<<function Text.compute_newlines>>

<<function Text.create>>
  
<<function Text.find_xy>>

<<function Text.new_point>>

<<function Text.dup_point>>

<<function Text.goto_point>>

<<function Text.move_point_to>>

<<function Text.remove_point>>

let with_dup_point text point f =
  let p = dup_point text point in
  Common.finalize (fun () -> f p) (fun () -> remove_point text p)


<<function Text.read>>

<<function Text.save>>

<<function Text.unset_attr>>

<<function Text.set_attr>>

<<function Text.low_distance>>

<<function Text.distance>>

<<function Text.compare>>
  
<<function Text.get_char>>

<<function Text.get_attr>>


<<function Text.set_char_attr>>

<<function Text.fmove_res>>



<<function Text.bmove_res>>

<<function Text.bmove>>

<<function Text.fmove>>
  
<<function Text.to_string>>


<<function Text.clean_text>>


<<function Text.blit>>
  
<<function Text.get_position>>

<<function Text.set_position>>
    
<<function Text.sub>>
    
<<function Text.search_forward>>

<<function Text.replace_matched>>
  
<<function Text.search_forward_matched>>

<<function Text.search_forward_groups>>

<<function Text.search_backward>>

<<function Text.search_backward_groups>>


<<constant Text.repr_string>>
<<constant Text.repr_size>>

<<constant Text.dummy_line>>
  
<<constant Text.tabreprs>>

type charreprs = string array

<<function Text.compute_representation>>


<<function Text.point_to_eol>>

<<function Text.point_to_bol>>

<<function Text.point_to_eof>>

<<function Text.point_to_bof>>

<<function Text.move_res>>

<<function Text.move>>

<<function Text.point_to_lof>>

<<function Text.point_to_lol>>

<<function Text.point_to_line>>

<<function Text.clear>>


<<function Text.point_line>>


<<function Text.goto_line>>


<<function Text.region>>

<<function Text.update>>

<<function Text.lexing>>

<<function Text.start_session>>
  
<<function Text.commit_session>>
    
<<function Text.readonly>>
  
<<function Text.toggle_readonly>>
  
@

%(*      
%module TextTree = WX_text.Make(Text)
%open TextTree
%*)
%  
%(* type t = tree tree_desc   *)
%
%(* external id: t -> tree tree_desc = "%identity" *)
%
%(*
%let print msg text =
%  let s = text.text_string in
%  let gpoint = text.gpoint in
%  let gsize  = text.gsize in
%  let len = text.text_size in
%  let gap_end = gpoint + gsize in
%    Printf.printf "%s: <<%s[gap:%d]%s>>" msg (String.sub s 0 gpoint) gsize 
%      (String.sub s gap_end (len - gap_end));
%    print_newline ()
% 
%let print_newlines text =
%  print_string "Newlines :";
%  for i = 0 to text.text_nlines - 1 do
%    Printf.printf " %d" text.text_newlines.(i).position;
%  done;
%  print_newline ()
%*)


%(*
%  let rec iter tree lines =
%    match tree with
%      Parts text ->
%        if lines = text.tree_nlines || lines = -1 then
%          (* Insert in the last part *)
%          iter text.tree_parts.(Array.length text.tree_parts - 1) (-1)
%        else
%        let rec iter2 lines i =
%          let tlines = match text.tree_parts.(i) with
%              Parts t -> t.tree_nlines
%            | Lines t -> t.tree_nlines 
%          in
%          if tlines > lines then
%            iter text.tree_parts.(i) lines
%          else
%            iter2 (lines - tlines) (i+1)
%        in
%        iter2 lines 0;
%        text.tree_modified <- true;
%        text.tree_nlines <- text.tree_nlines + nbr
%    | Lines text ->
%        let newtext = Array.create text.tree_nlines text.tree_parts.(0) in
%        Array.blit text.tree_parts 0 newtext 0 lines;
%        Array.blit t.text_newlines gline newtext lines nbr;
%        Array.blit text.tree_parts lines newtext (lines+nbr) (
%          text.tree_nlines - lines);
%        text.tree_modified <- true;        
%        text.tree_nlines <- text.tree_nlines + nbr
%  in
%  iter (Parts tree) gline
%*)



\subsection*{[[core/ebuffer.ml]]}


<<function Ebuffer.read>>=
let read filename local_map =
  let loc = Globals.location() in
  let filename = Utils.normal_name loc.loc_dirname filename in
  try
    Hashtbl.find loc.loc_files filename
  with Not_found ->
    let text =
      try
        let inc = open_in filename in
        let text = Text.read inc in         
        close_in inc; 
        text
      with _ -> Text.create ""
    in
    let buf = create filename (Some filename) text local_map in
    Hashtbl.add loc.loc_files filename buf;
    buf
@



<<exception Ebuffer.BufferAlreadyOpened>>=
exception BufferAlreadyOpened
@

<<function Ebuffer.change_name>>=
let change_name buf filename =
  let loc = Globals.location() in
  Hashtbl.remove loc.loc_buffers buf.buf_name;
  buf.buf_filename |> Common.do_option (fun filename ->
    Hashtbl.remove loc.loc_files filename
  );
  let filename = 
    if Filename.is_relative filename then
      Filename.concat loc.loc_dirname filename
    else
      filename
  in
  if Utils.hashtbl_mem loc.loc_files filename 
  then raise BufferAlreadyOpened;
  let filename = Utils.normal_name loc.loc_dirname filename in
  let name = get_name filename in
  Hashtbl.add loc.loc_buffers name buf;
  Hashtbl.add loc.loc_files filename buf;
  buf.buf_filename <- Some filename;
  buf.buf_name <- name
@





<<function Ebuffer.catch>>=
let catch format buf f =
  try
    f ()
  with e ->
    let loc = Globals.location() in
    let name = "*Messages*" in
    let m = Printf.sprintf format (Utils.printexn e) in
    try
      let buf = Hashtbl.find loc.loc_buffers name in
      Text.insert_at_end buf.buf_text (m ^ "\n");
    with Not_found ->
      create name None (Text.create (m^"\n")) (Keymap.create ())  |>ignore
@



%-------------------------------------------------------------

<<core/ebuffer.ml>>=
<<copyright header2>>
open Common
open Efuns

(* this file is called ebuffer.ml because buffer.ml already exists in stdlib *)

<<constant Ebuffer.create_buf_hook>>
<<constant Ebuffer.modes_alist>>

<<function Ebuffer.create_syntax_table>>

<<constant Ebuffer.default_syntax_table>>

<<function Ebuffer.get_name>>

<<function Ebuffer.new_minor_mode>>

<<function Ebuffer.new_major_mode>>

<<constant Ebuffer.fondamental_mode>>
  
<<constant Ebuffer.tab_size>>

<<function Ebuffer.create>>

<<function Ebuffer.kill>>

open Options
  
<<constant Ebuffer.save_buffer_hooks>>
  
<<constant Ebuffer.saved_buffer_hooks>>

<<function Ebuffer.save>>
 
<<function Ebuffer.read>>

let find_buffer_opt name =
  try Some (Hashtbl.find (Globals.location()).loc_buffers name)
  with Not_found -> None

<<constant Ebuffer.help_buffer_content>>

<<function Ebuffer.default>>
      

<<function Ebuffer.compute_representation>>

<<exception Ebuffer.BufferAlreadyOpened>>

<<function Ebuffer.change_name>>
  
  
<<function Ebuffer.set_mark>>

<<function Ebuffer.get_mark>>

<<function Ebuffer.remove_mark>>

<<constant Ebuffer.modes_old>>
<<constant Ebuffer.regexp_alist>>

<<function Ebuffer.set_major_mode>>

<<function Ebuffer.set_minor_mode>>

<<function Ebuffer.del_minor_mode>>
  
<<function Ebuffer.modep>>

<<constant Ebuffer.suffix_reg>>
  
<<function Ebuffer.set_buffer_mode>>
      
<<function Ebuffer.get_binding>>

<<function Ebuffer.message>>

<<function Ebuffer.catch>>
          
      
<<toplevel Ebuffer._1>>
@


\subsection*{[[core/keymap.ml]]}


%<<function Keymap.unbound_key>>=
%let unbound_key buffer _ = raise UnboundKey
%@
%dead?
%<<function Keymap.define_char_binding>>=
%let define_char_binding map char (f : frame -> 'a) =
%  add_binding map [NormalMap,Char.code char] f
%@
%dead?
%dead: let keysym_to_name = []
% (it's in XK now)

%-------------------------------------------------------------

<<core/keymap.ml>>=
<<copyright header2>>
open Efuns

(*
La gestion des keymaps est inadapte'e a` la modification dynamique.
En effet, on aurait envie de pouvoir modifier les bindings selon divers
  crite`res, tels que le buffer (possible), le mode(pas possible).
*)


<<function Keymap.dummy_action>>

<<function Keymap.create>>

<<function Keymap.print_key>>
            
<<function Keymap.print_key_list>>

   
<<function Keymap.get_binding>>
          
          
<<function Keymap.set_binding>>

<<function Keymap.add_binding>>
          
   
<<constant Keymap.c_h>>
<<constant Keymap.c_x>>
<<constant Keymap.c_c>>
<<constant Keymap.n_5>>

<<function Keymap.all_bindings>>
  
<<function Keymap.interactive>>

<<function Keymap.add_interactive>>

<<function Keymap.add_global_key>>
<<function Keymap.add_local_key>>
<<function Keymap.add_minor_key>>
<<function Keymap.add_major_key>>

let define_interactive_action action_name action_fun =
  Action.define_action action_name action_fun;
  let map = (Globals.location()).loc_map in
  add_interactive map action_name action_fun
@


\subsection*{[[core/minibuffer.ml]]}


<<function Minibuffer.return>>=
let return action old_frame mini_frame =
  let repstr = Text.to_string mini_frame.frm_buffer.buf_text in
  kill mini_frame old_frame;
  action old_frame repstr
@


<<function Minibuffer.create_return>>=
let create_return frame local_map request default action =
  let mini_frame = create frame local_map request in
  Simple.insert_string mini_frame default;
  Keymap.add_binding local_map [NormalMap, XK.xk_Return] 
    (return action frame);
  mini_frame
@

<<function Minibuffer.update_request>>=
let update_request frame request =
  let qlen = String.length request in
  let window = frame.frm_window in
  let top_window = Window.top window in
  let _mini_window = Window.create true window.win_up
      qlen window.win_ypos
      (top_window.top_width - qlen) 1
  in
  frame.frm_width <- top_window.top_width - qlen;
  frame.frm_xpos <- qlen;
  frame.frm_mini_buffer <- Some request;
  frame.frm_redraw <- true
@


%-------------------------------------------------------------

<<core/minibuffer.ml>>=
<<copyright header2>>
open Efuns

<<constant Minibuffer.charreprs>>
<<toplevel Minibuffer._1>>

<<function Minibuffer.buf_create>>


<<function Minibuffer.kill>>

<<function Minibuffer.return>>

<<function Minibuffer.create>>

<<function Minibuffer.create_return>>

<<function Minibuffer.update_request>>
  
@


\subsection*{[[core/window.ml]]}


%old: function Window.display>>=

%-------------------------------------------------------------

<<core/window.ml>>=
<<copyright header2>>
open Efuns

<<function Window.create_at_top>>

<<function Window.create>>

<<function Window.top>>

<<function Window.iter>>

<<function Window.first>>

<<function Window.last>>

<<function Window.next>>
      
<<function Window.prev>>
       
@


\subsection*{[[core/frame.ml]]}

<<function Frame.print_list>>=
let rec print_list list =
  match list with
    [] -> ""
  | [ele] -> ele
  | ele :: ( (_ :: _) as tail) ->
      ele ^ " " ^ (print_list tail)
@



<<function Frame.resize>>=
let resize frame =
  install frame.frm_window frame
@


<<constant Frame.dummy_mode>>=
let dummy_mode = Ebuffer.new_major_mode "" []
@


<<function Frame.active>>=
let active frame =
  let top_window = Window.top frame.frm_window in
  top_window.top_active_frame <- frame;
  frame.frm_buffer.buf_filename |> Common.do_option (fun filename ->
    (Globals.location()).loc_dirname <- Filename.dirname filename
  )
@

<<function Frame.create>>=
let create window mini buf =
  let top_window = Window.top window in
  let frame = create_without_top window mini buf in
  top_window.top_active_frame <- frame;
  frame
@

<<function Frame.create_inactive>>=
let create_inactive window buf =
  create_without_top window None buf
@










<<exception Frame.BufferKilled>>=
exception BufferKilled
@

<<function Frame.unkill>>=
let unkill window frame =
  let buf = frame.frm_buffer  in
  if buf.buf_shared < 0 then raise BufferKilled;
  let text = buf.buf_text in
  install window frame;
  frame.frm_start <- Text.dup_point text buf.buf_start;
  frame.frm_end <- Text.dup_point text buf.buf_start;
  frame.frm_point <- Text.dup_point text buf.buf_point;
  frame.frm_y_offset <- 0;
  buf.buf_shared <- buf.buf_shared + 1;
  frame.frm_killed <- false
@

<<function Frame.move_point>>=
let move_point frame point x y =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let x, y = cursor_to_point frame (x - frame.frm_xpos) (y - frame.frm_ypos) in
  goto_line text point y;
  fmove text point x |> ignore
@


<<exception Frame.FoundFrame>>=
exception FoundFrame of frame
@

<<function Frame.find_buffer_frame>>=
let find_buffer_frame buf =
  try
    (Globals.location()).top_windows |> List.iter (fun top_window ->
      top_window.window |> Window.iter (fun frame -> 
        if frame.frm_buffer == buf 
        then raise (FoundFrame frame)
      )
    );
    raise Not_found
  with FoundFrame frame -> frame
@




%-------------------------------------------------------------

<<core/frame.ml>>=
<<copyright header2>>
open Common
open Options

open Efuns
open Text

<<constant Frame.status_format>>

<<function Frame.status_print>>


<<function Frame.status_modified>>

<<function Frame.status_col>>

<<function Frame.print_list>>

<<function Frame.status_major_mode>>

<<function Frame.status_line>>

<<function Frame.status_name>>

<<function Frame.kill>>

<<function Frame.kill_all>>

<<function Frame.install>>

<<function Frame.resize>>

<<constant Frame.editname>>
<<constant Frame.dummy_mode>>
  
<<function Frame.create_without_top>>

<<function Frame.active>>
      
      
<<function Frame.create>>

<<function Frame.create_inactive>>


<<function Frame.point_to_cursor>>

<<function Frame.cursor_to_point>>


<<function Frame.display_line>>

<<function Frame.set_cursor>>

<<function Frame.update_table>>


<<function Frame.display>>

<<exception Frame.BufferKilled>>
<<function Frame.unkill>>

<<function Frame.move_point>>

<<function Frame.current_dir>>


<<exception Frame.FoundFrame>>

<<function Frame.find_buffer_frame>>

<<constant Frame.change_buffer_hooks>>

<<function Frame.load_file>>

  
<<function Frame.change_buffer>>

<<function Frame.save_buffer>>

<<function Frame.bindings_help>>

<<function Simple.to_frame>>
  
@


\section{[[features/]]}

\subsection*{[[features/highlight.ml]]}

<<features/highlight.ml>>=
<<copyright header efuns>>
open Efuns

<<constant Simple.highlighted>>
<<constant Simple.highlight_bit>>

<<function Simple.unhightlight_region>>

<<function Simple.hightlight_region>>

<<constant Simple.highlighted_chars>>

<<function Simple.unhightlight>>
  
<<function Simple.highlight>>

let _ =
  Hook.add_start_hook (fun () ->
    (* unhightlight region *)
    Hook.add_hook Top_window.handle_key_start_hook unhightlight;      
  )
@

\subsection*{[[features/parameter.ml]]}

<<features/parameter.ml>>=
<<copyright header efuns>>

  
open Options

<<type Simple.parameter>>
  
<<constant Simple.parameters_var>>
  
<<function Simple.add_parameter>>

<<function Simple.add_option_parameter>>
  
<<constant Simple.all_params>>
<<function Simple.all_parameters>>

@

\subsection*{[[features/mouse.ml]]}

<<features/mouse.ml>>=
<<copyright header efuns>>
open Efuns

<<function Simple.mouse_drag_region>>

<<function Simple.mouse_yank_at_click>>

<<function Simple.mouse_save_then_kill>>

<<function Simple.mouse_set_frame>>

let _ =
  Hook.add_start_hook (fun () ->
    Keymap.add_global_key [NormalMap, XK.xk_Pointer_Drag1]
      "mouse_drag_region" mouse_drag_region;
  )

@

\subsection*{[[features/indent.ml]]}

<<features/indent.ml>>=
<<copyright header efuns>>

<<function Simple.set_indent>>

@

\subsection*{[[features/structure.ml]]}

<<features/structure.ml>>=
<<copyright header efuns>>
open Efuns

<<function Simple.next_hole>>


<<function Simple.insert_structure>>

<<function Simple.install_structures>>

@

\subsection*{[[features/simple.ml]]}

% ?? -> <>
<<function Simple.string_to_modifier>>=
let string_to_modifier s =  
  let mask = ref 0 in
  for i = 0 to String.length s - 1 do
    mask := !mask lor (match s.[i] with
      | 'C' -> controlMask
      | 'A' -> mod1Mask
      | 'M' -> mod1Mask
      | '1' -> mod1Mask
      | _ -> 0
    )
  done;
  !mask
@

<<function Simple.modifier_to_string>>=
@

%<<function Simple.modifier_to_string>>=
%(*
%let modifier_to_string mask = 
%  let s = if mask land shiftMask = 0 then "" else "S" in
%  let s = if mask land controlMask = 0 then s else "C" ^ s in
%  let s = if mask land mod1Mask = 0 then s else "M" ^ s in
%  let s = if mask land mod2Mask = 0 then s else "2" ^ s in
%  let s = if mask land mod3Mask = 0 then s else "3" ^ s in
%  let s = if mask land mod4Mask = 0 then s else "4" ^ s in
%  let s = if mask land mod5Mask = 0 then s else "5" ^ s in
%  s
%*)
%@

<<constant Simple.name_to_keysym>>=
let name_to_keysym = 
  ("Button1", XK.xk_Pointer_Button1) ::
  ("Button2", XK.xk_Pointer_Button2) ::
  ("Button3", XK.xk_Pointer_Button3) ::
  ("Button4", XK.xk_Pointer_Button4) ::
  ("Button5", XK.xk_Pointer_Button5) ::
  XK.name_to_keysym
@

<<function Simple.value_to_keysym>>=
@

%<<function Simple.value_to_keysym>>=
%(*
%let value_to_keysym v =
%  match v with
%    Value v -> List.assoc v name_to_keysym
%  | _ -> raise Not_found
%*)
%@

<<function Simple.keysym_to_value>>=
@
%<<function Simple.keysym_to_value>>=
%(*
%let keysym_to_value k =
%  Value (List.assoc k XK.keysym_to_name)
%*)
%@

<<function Simple.value_to_key>>=
(* form: SC-Button1 *)
let value_to_key v =
  match v with 
    Value s -> 
      let key, mods = 
        try
          let index = String.index s '-' in
          let mods = String.sub s 0 index in
          let key = String.sub s (index+1) (String.length s - index - 1) in
          key, mods
        with _ -> s, ""
      in
      let key = List.assoc key name_to_keysym in
      let mods = string_to_modifier mods in
      let map = 
        if mods land (controlMask lor mod1Mask) = (controlMask lor mod1Mask)
        then ControlMetaMap else
        if mods land controlMask <> 0 then ControlMap else
        if mods land mod1Mask <> 0 then MetaMap else NormalMap
      in
      map, key
      
  | _ -> raise Not_found
@

<<function Simple.key_to_value>>=
let key_to_value k = Value (Keymap.print_key k)
@



<<function Simple.insert_string>>=
let insert_string frame str =
  let text = frame.frm_buffer.buf_text in
  let point = frame.frm_point in
  Text.insert text point str |> ignore;
  Text.fmove text point (String.length str) |> ignore
@




<<function Simple.previous_char>>=
let previous_char frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  if Text.bmove_res text point 1 = 0 then raise Not_found;
  let c = Text.get_char text point in
  Text.fmove text point 1 |> ignore;
  c
@


<<function Simple.insert_at_place>>=
let insert_at_place frame char =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let c = Text.get_char text point in
  if c = '\n' then
    insert_char frame char
  else
  let _sessionTODOBUG = Text.start_session text in
  Text.delete text point 1 |> ignore;
  single_char.[0] <- char;    
  Text.insert text point single_char |> ignore;
  Text.fmove text point 1 |> ignore
@

<<constant Simple.overwrite_mode>>=
let overwrite_mode = Ebuffer.new_minor_mode "Over" []
@


<<function Simple.char_insert_command>>=
let char_insert_command char frame =
  let buf = frame.frm_buffer in
  if Ebuffer.modep buf overwrite_mode 
  then insert_at_place frame char
  else insert_char frame char
@




<<function Simple.line_size>>=
let line_size frame =
  (point_to_end frame) + (point_to_end frame)
@






<<constant Simple.last_kill>>=
let last_kill = ref None
@



<<function Simple.kill_text>>=
let kill_text text point len =
  let point,str = Text.delete_res text point len in
  match !last_kill with
  | Some (oldtext,oldpoint) when
    oldpoint = point && oldtext == text ->
      kill_ring.(0) <- kill_ring.(0)^str
  | _ ->
      last_kill := Some (text,point);
      kill_string str
@


<<function Simple.kill_eol>>=
let kill_eol buf point =
  let text = buf.buf_text in
  let eol = Text.point_to_eol text point in
  let len =
    if eol = 0 then 1 else eol
  in
  kill_text text point len
@

<<function Simple.kill_bol>>=
let kill_bol buf point =
  let text = buf.buf_text in
  let len = Text.point_to_bol text point in
  if len > 0 then
    ( Text.bmove text point len;
      kill_text text point len)
@


<<function Simple.format_to>>=
@
%<<function Simple.format_to>>=
%let format_to frame =
%  let point = frame.frm_point in
%  let buf = frame.frm_buffer in
%  let text = buf.buf_text in
%  Format.set_formatter_output_functions 
%    (fun str pos len ->
%      let s = String.sub str pos len in
%      Text.insert text point s |> ignore;
%      Text.fmove text point len)
%  (fun () -> ())
%@
%

<<function Simple.format_to_string>>=
@
%<<function Simple.format_to_string>>=
%let format_to_string () =
%  let string = ref "" in
%  Format.set_formatter_output_functions 
%    (fun str pos len ->
%      let s = String.sub str pos len in
%      string := !string ^ s)
%  (fun () -> ());
%  string
%@


<<function Simple.to_frame>>=
let to_frame f frame =
  f frame.frm_buffer frame.frm_point
@



%<<function Simple.current_word>>=
%(*
%let current_word buf point =
%  let text = buf.buf_text in
%  let syntax = buf.buf_syntax_table in
%  let start = dup_point text point in
%  to_begin_of_word text start syntax;
%  let term = dup_point text point in
%  to_end_of_word text term syntax;
%  let word = Text.region text start term in
%  remove_point text start;
%  remove_point text term;
%  word
%*)
%@

<<function Simple.current_word>>=
let current_word buf point =
  (beginning_of_word buf point) ^ (end_of_word buf point)
@






<<function Simple.scroll_line>>=
let scroll_line frame n =
  frame.frm_force_start <- true;
  frame.frm_redraw <- true;
  frame.frm_y_offset <- frame.frm_y_offset + n
@









<<function Simple.mouse_drag_region>>=
(* C'est tout simple. On arrive dans cette fonction quand on est en train
de bouger la souris avec le bouton appuyer. La frame courante est donc 
correcte. On peut utiliser la position de la souris pour trouver la 
nouvelle position du curseur dans la frame. Si on en sort, on peut
ou prendre la derniere position, ou la premiere.
*)
let mouse_drag_region frame =
  failwith "Simple.mouse_drag_region: TODO"
(*
  let top_window = Window.top frame.frm_window in
  let point = frame.frm_point in
  begin
    try
      move_point frame point !mouse_x !mouse_y
    with
      Not_found ->
        let buf = frame.frm_buffer in
        let text = buf.buf_text in
        let y = !mouse_y - frame.frm_ypos in
        if y < 0 then
          ( scroll_line frame (y-1);
            goto_point text point frame.frm_start;
            bmove text point 1; ())
        else
        if y >= frame.frm_height - 1 then
          (
            scroll_line frame (y - frame.frm_height + 2);
            goto_point text point frame.frm_end;
            fmove text point 1; ())
  end;
  highlight frame;
  let top_window = Window.top frame.frm_window in
  let xterm = top_window.top_term in
  Selection.setSelection xterm#display xterm#window XA.xa_primary
    (fun target ->
      if target = XA.xa_string then 
        match !highlighted with
          None -> raise Not_found
        | Some (frame,debut,fin) -> 
            let buf = frame.frm_buffer in
            let text = buf.buf_text in
            let curseur = new_point text in
            let final = new_point text in
            set_position text curseur debut;
            set_position text final fin;
            let str = Text.region text curseur final in
            remove_point text curseur;
            remove_point text final;
            
            1, str
      else raise Not_found
  ) !Eloop.event_time
*)
@



<<function Simple.next_buffer>>=
(* useful when want to iterate over all buffers, e.g. in dabbrev_expand *)
let next_buffer buf =
  let buf_list = Utils.list_of_hash (Globals.location()).loc_buffers in
  let rec iter list =
    match list with
      [] -> raise Not_found 
    | (name,b) :: tail ->
        if b == buf 
        then 
          match tail with
          | [] -> snd (List.hd buf_list) (* go back to head *)
          | (_,b)::_ -> b
        else
          iter tail
  in
  iter buf_list
@








<<function Simple.electric_insert_space>>=
let electric_insert_space frame =
  self_insert_command frame;
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let line_len = Text.point_to_bol text point in
  if line_len > 75 then
    let mark = Text.dup_point text point in
    (try
        while (backward_word buf mark;
            Text.point_to_bol text mark > 75) do () done;
        forward_word buf mark; backward_word buf mark;
        Text.insert text mark "\n" |> ignore
    with Not_found -> ()
    );
    Text.remove_point text mark
@

<<function Simple.simplify>>=
let simplify text start point =
  let start = Text.dup_point text start in
  let rec iter last_c =
    if start < point then
      let c = Text.get_char text start in
      if c = ' ' || c = '\n' || c = '\t' then
        ( Text.delete text start 1 |> ignore;
          iter ' ')
      else
      if last_c = ' ' then
        ( Text.insert text start " " |> ignore;
          Text.fmove text start 2;
          iter 'a')
      else
        ( Text.fmove text start 1;
          iter 'a')
  in
  iter 'a';
  Text.remove_point text start
@

<<constant Simple.line_comment>>=
let line_comment = Local.create_abstr "Fill_mode.line_comment"
@


<<function Simple.set_indent>>=
(* modify the indentation of (point) line. Does not modify point *)
let set_indent text point offset = 
  let curseur = Text.dup_point text point in
  Text.bmove text curseur (Text.point_to_bol text curseur);
  let rec iter offset =
    let c = Text.get_char text curseur in
    if offset > 0 then
      if c = ' ' then
        (Text.fmove text curseur 1; iter (offset - 1))
      else
      if c = '\t' then
        (Text.delete text curseur 1 |> ignore;
         iter offset)
      else
        (Text.insert text curseur (String.make offset ' '))
    else
    if c = ' ' || c='\t' then
      (Text.delete text curseur 1;
        iter 0)
  in
  iter offset;
  Text.remove_point text curseur
@

<<function Simple.insert_special_char>>=
let insert_special_char frame =
  let key = !Top_window.keypressed in
  let char = Char.chr key in
  if char >= 'a' && char <= 'z' then
    insert_char frame (Char.chr (key - 97))
  else
    insert_char frame (Char.chr (key - 65))
@






<<toplevel Simple._1>>=
let _ =
  Action.define_buffer_action "overwrite_mode" (fun buf -> 
      let mode = overwrite_mode in
      if Ebuffer.modep buf mode 
      then Ebuffer.del_minor_mode buf mode
      else Ebuffer.set_minor_mode buf mode
  );

  Hook.add_start_hook (fun () ->
    let loc = Globals.location () in
    let gmap = loc.loc_map in

    (* standard chars *)
    for key = 32 to 127 do
      Keymap.add_binding gmap [NormalMap, key] self_insert_command
    done;

    (* special for AZERTY keyboards *)
    Array.iter (fun (key, char) ->
        Keymap.add_binding gmap [NormalMap, key] (char_insert_command char)
    ) [| 
(*
        (XK.xk_eacute, 'é');
        (XK.xk_egrave, 'è');
        (XK.xk_ccedilla, 'ç');
        (XK.xk_agrave, 'à');
        (XK.xk_ugrave, 'ù');
        (XK.xk_mu, 'µ'); 
        (XK.xk_sterling, '£');
        (XK.xk_section, '§');
        (XK.xk_degree,  '°');
*)
        |];
      let c_q = (ControlMap, Char.code 'q') in
      (* Keymap.add_prefix gmap [c_q]; *)
      for key = 65 to 65+25 do
        Keymap.add_binding gmap [c_q;ControlMap, key] insert_special_char;
      done;
      for key = 97 to 97+25 do
        Keymap.add_binding gmap [c_q;ControlMap, key] insert_special_char;
      done;

      Keymap.add_interactive (loc.loc_map) "fondamental_mode" 
        (fun frame -> Ebuffer.set_major_mode frame.frm_buffer 
            Ebuffer.fondamental_mode);

      Var.set_global line_comment ""
  )
@


%-------------------------------------------------------------

<<features/simple.ml>>=
<<copyright header2>>
open Efuns
open Xtypes

(*****************************************************************************)
(* Insertion *)
(*****************************************************************************)

<<function Simple.insert_string>>
  
<<constant Simple.single_char>>
<<function Simple.insert_char>>

<<function Simple.insert_return>>

<<function Simple.previous_char>>

<<function Simple.unset_attr>>
  
<<function Simple.insert_at_place>>


<<constant Simple.overwrite_mode>>
  
  
<<function Simple.self_insert_command>>
    
<<function Simple.char_insert_command>>

(*****************************************************************************)
(* Deletion *)
(*****************************************************************************)

<<function Simple.delete_char>>

<<function Simple.delete_backspace_char>>

<<function Simple.hungry_char>>

<<function Simple.hungry_electric_delete>>

(*****************************************************************************)
(* Navigation *)
(*****************************************************************************)

<<function Simple.move_backward>>

<<function Simple.move_forward>>

<<function Simple.begin_to_point>>

<<function Simple.point_to_end>>


<<function Simple.line_size>>

<<function Simple.beginning_of_line>>

<<function Simple.end_of_line>>


<<constant Simple.temporary_goal_column>>

<<function Simple.goal_column>>

<<function Simple.move_to_goal_column>>

<<function Simple.forward_line>>

<<function Simple.backward_line>>


(*****************************************************************************)
(* Kill *)
(*****************************************************************************)

<<constant Simple.kill_size>>
<<constant Simple.kill_max>>
<<constant Simple.kill_ring>>
<<constant Simple.last_kill>>
<<constant Simple.last_insert>>

<<function Simple.kill_string>>


<<function Simple.kill_text>>

<<function Simple.kill_end_of_line>>

<<function Simple.kill_eol>>

<<function Simple.kill_bol>>

<<function Simple.insert_killed>>

<<function Simple.insert_next_killed>>


<<function Simple.kill_region>>

<<function Simple.copy_region>>
  

(*****************************************************************************)
(* Words *)
(*****************************************************************************)

<<function Simple.in_next_word>>

<<function Simple.in_prev_word>>


<<function Simple.to_begin_of_word>>

<<function Simple.to_end_of_word>>


<<function Simple.backward_word>>

<<function Simple.forward_word>>

<<function Simple.beginning_of_word>>

<<function Simple.end_of_word>>

<<function Simple.current_word>>
 
<<function Simple.delete_backward_word>>

<<function Simple.delete_forward_word>>

<<function Simple.on_word>>
  
<<function Simple.transpose_words>>


<<function Simple.transpose_chars>>

(*****************************************************************************)
(* Paragraphs *)
(*****************************************************************************)

<<function Simple.backward_paragraph>>

<<function Simple.forward_paragraph>>

(*****************************************************************************)
(* Scroll *)
(*****************************************************************************)

(*
let move_backward frame =
   Functions.move_backward frame 1; ()

let move_forward frame = 
  Functions.move_forward frame 1; () 
*) 
  
<<function Simple.forward_screen>>

<<function Simple.backward_screen>>

<<function Simple.scroll_line>>

let scroll_down frame =
  scroll_line frame 1;
  forward_line frame

let scroll_up frame =
  scroll_line frame (-1);
  backward_line frame

let scroll_other_up frame =
  Window.next scroll_up frame.frm_window

let scroll_other_down frame =
  Window.next scroll_down frame.frm_window

<<function Simple.recenter>>

<<function Simple.end_of_file>>

<<function Simple.begin_of_file>>

(*****************************************************************************)
(* Undo *)
(*****************************************************************************)

<<function Simple.undo>>

(*****************************************************************************)
(* Color helpers *)
(*****************************************************************************)

<<function Simple.color>>

(*****************************************************************************)
(* Points *)
(*****************************************************************************)

<<function Simple.point_at_mark>>


(*****************************************************************************)
(* Electric *)
(*****************************************************************************)

<<function Simple.electric_insert_space>>

<<function Simple.simplify>>

<<constant Simple.line_comment>>

<<function Simple.fill_paragraph>>
  
<<function Simple.insert_special_char>>

(*****************************************************************************)
(* Keys *)
(*****************************************************************************)
open Options

<<function Simple.string_to_modifier>>
  
<<function Simple.modifier_to_string>>
      
<<constant Simple.name_to_keysym>>
  
<<function Simple.value_to_keysym>>
      
<<function Simple.keysym_to_value>>
  
<<function Simple.value_to_key>>
  
<<function Simple.key_to_value>>
      
<<constant Simple.key_option>>

<<constant Simple.binding_option>>

(*****************************************************************************)
(* Toplevel *)
(*****************************************************************************)
  
<<toplevel Simple._1>>
  
@

%  (*
%external id : 'a -> 'a = "%identity"
%let add_string_parameter location name param = 
%  add_parameter location name id id param
%let add_int_parameter location name param = 
%  add_parameter location name int_of_string string_of_int param
%let add_float_parameter location name param = 
%  add_parameter location name float_of_string string_of_float param
%let add_bool_parameter location name param = 
%  add_parameter location name bool_of_string string_of_bool param
%    *)
% ????

 
%(*
%     let move_backward frame =
%   Functions.move_backward frame 1; ()
%
%let move_forward frame = 
%  Functions.move_forward frame 1; () 
%*) 


\subsection*{[[features/select.ml]]}


<<function Select.select_yes_or_no>>=
let select_yes_or_no frame request action =
  let top_window = Window.top frame.frm_window in
  let map = Keymap.create () in
  let yes_reply mini_frame = 
    Minibuffer.kill mini_frame frame;
    top_window.top_second_cursor <- None;
    action true
  in
  let no_reply  mini_frame = 
    Minibuffer.kill mini_frame frame;
    top_window.top_second_cursor <- None;
    action false
  in
  Keymap.add_binding map [NormalMap, Char.code 'y'] yes_reply;
  Keymap.add_binding map [NormalMap, Char.code 'Y'] yes_reply;
  Keymap.add_binding map [NormalMap, Char.code 'n'] no_reply;
  Keymap.add_binding map [NormalMap, Char.code 'N'] no_reply;
  let mini = Minibuffer.create frame map request in
  mini.frm_buffer.buf_map_partial <- false;
  mini
@

<<function Select.find_completion_frame>>=
let find_completion_frame frame =
  let buf = Ebuffer.default "*Completions*" in
  Frame.find_buffer_frame buf
@

<<function Select.display_completions>>=
let display_completions frame list =
  let top_window = Window.top frame.frm_window in
  if list = [] 
  then Top_window.message top_window "No Completions"
  else
    let rec iter list s =
      match list with
      | [] -> s
      | [f] -> Printf.sprintf "%s\n%s" s f
      | f1::f2::tail  ->
          iter tail (Printf.sprintf "%s\n%-40s%s" s f1 f2)
    in
    let buf = Ebuffer.default "*Completions*" in
    let text = buf.buf_text in
    Text.update text (iter list "Completions :");
    
    let hooks = try Var.get_global completions_buf_hook with Not_found -> [] in
    Hook.exec_hooks hooks buf;

    (try Frame.find_buffer_frame buf
     with Not_found -> Frame.create_inactive (Multi_frames.cut_frame frame) buf
    ) |> ignore
@

<<function Select.remove_completions>>=
let remove_completions frame =
  try
    let frame = find_completion_frame frame in
    Multi_frames.remove_frame frame
  with Not_found -> ()
@

<<function Select.set_history>>=
let set_history map string history =
  let current = ref 0 in
  Keymap.add_binding map [NormalMap, XK.xk_Up] (fun mini_frame ->
    if !current = List.length !history 
    then Top_window.mini_message mini_frame "No previous line in history"
    else begin
      let ele = Utils.list_nth !current !history in
      incr current;
      let buf = mini_frame.frm_buffer in
      let text = buf.buf_text in
      Text.clear text;
      string := ele;
      Simple.insert_string mini_frame ele
    end
  );      
  Keymap.add_binding map [NormalMap, XK.xk_Down] (fun mini_frame ->
    if !current < 1 
    then Top_window.mini_message mini_frame "No other line in history"
    else begin
      decr current;
      let ele = Utils.list_nth !current !history in
      let buf = mini_frame.frm_buffer in
      let text = buf.buf_text in
      Text.clear text;
      string := ele;
      Simple.insert_string mini_frame ele; ()
    end
  )
@



<<constant Select.file_hist>>=
let file_hist = ref []
@

<<constant Select.dont_complete>>=
let dont_complete = define_option ["avoid_filenames"] ""
    (list_option string_option) 
  [ ".*\\.o"; ".*\\.cm.";".*\\.cmxa";".*~";".*\\.a";"core";"\\..*"]
@

<<constant Select.dont_complete_regexps>>=
let dont_complete_regexps = ref ([],Str.regexp "")
@

<<function Select.dont_complete_regexp>>=
let dont_complete_regexp () =
  let (old,reg) = !dont_complete_regexps in
  if old == !!dont_complete 
  then reg
  else
    let reg = Str2.regexp_from_list !!dont_complete in
    dont_complete_regexps := (!!dont_complete, reg);
    reg
@

<<function Select.avoid_completion>>=
let avoid_completion s =
  let bad_regexp = dont_complete_regexp () in
  not (Str.string_match bad_regexp s 0)
@

<<function Select.is_userdir>>=
let is_userdir string =
  let n = String.length string in
  (n > 1) && (string.[0] = '~') &&
  (try
      String.rindex string '/' |> ignore;
      false
   with Not_found -> true
   )
@

<<function Select.complete_filename>>=
let complete_filename frame good_file filename =
  if is_userdir filename 
  then (* Parse_file.users *) failwith "Select.complete_filename: TODO"
  else
  let filename = Utils.string_to_filename filename in
  let dirname = dirname frame filename in
  let file_list = Utils.file_list dirname in
  let file_list = file_list |> List.map (fun file ->
    let path = Filename.concat dirname file in
    try 
      let stat = Unix.stat path in
      match stat.Unix.st_kind with
      | Unix.S_DIR -> file ^ "/"
      | _ -> file
    with exn -> 
      pr2 (spf "complete_filename: exn = %s" (Common.exn_to_s exn));
      file
  )
  in

  match file_list with
  | a::b::_ -> 
      begin
        match 
          List.fold_left (fun list ele ->
              if good_file ele then ele :: list else list
          ) [] file_list
        with
          [] -> file_list 
            (* if no completion is OK, return files that should have 
          been avoided *)
        | list -> list
      end
  | _ -> file_list
@

<<function Select.select_file>>=
let select_file frame request history start action =
  let map = Keymap.create () in
  let string = ref "" in
  Keymap.add_binding map [ControlMap, Char.code 'g'] (fun mini_frame ->
    pr2 "HERE";
    remove_completions mini_frame;
    Minibuffer.kill mini_frame frame
  );
  let completion = ref "_*NoCompletion*_" in
  let completions = ref [] in
  Keymap.add_binding map [NormalMap, XK.xk_Tab] (fun mini_frame ->
    let text = mini_frame.frm_buffer.buf_text in
    (*if (!completion <> !string) then  *)
    begin
      string := Text.to_string text;
      completions := complete_filename frame avoid_completion !string;
      let suffix, n = 
        Utils.common_suffix !completions (basename !string) in
      let suffix = 
        let s = !string ^ suffix in
        let len = String.length s in
        if len>0 && s.[len - 1] <> '/' 
        then
          try
            let filename = Utils.string_to_filename s in
            let dirname = dirname frame filename in
            let basename = basename filename in
            let stat = Unix.stat (Filename.concat dirname basename) in
            match stat.Unix.st_kind with
            |  Unix.S_DIR -> suffix ^ "/"
            | _ -> suffix
          with _ -> suffix
        else suffix
      in
      completion := !string;
      Text.insert text mini_frame.frm_point suffix;
      Text.fmove text mini_frame.frm_point (String.length suffix);
      string := Text.to_string text;
       if n>1 
       then
          display_completions frame
            (Utils.completion !completions (basename !string))
    end
(* TODO later, but right now have some bad side effects.
 e.g. if do TAB in one dir, then do M-back to remove a dir, and rerun
 TAB then it does not update the completion buffer with the candidates
 for the new dir, so for now commented!
   else
    (* can be improved, by displaying another part of the completion buffer *)
      display_completions frame
          (Utils.completion !completions (basename !string))
*)
  );
  set_history map string history;
  incremental_mini_buffer frame map request start
    (fun frame str -> string := str)
    (fun old_frame str -> 
      history := str :: !history;
      remove_completions frame;
      let str = Utils.string_to_filename str in
      action str
    ) |> ignore;
  Keymap.add_binding map [NormalMap, XK.xk_Prior] (fun frame ->
    let frame = find_completion_frame frame in
    Simple.backward_screen frame
  );
  Keymap.add_binding map [NormalMap, XK.xk_Next] (fun frame ->
    let frame = find_completion_frame frame in
    Simple.forward_screen frame
  );
  Keymap.add_binding map [NormalMap, Char.code '~'] (fun frame ->
    let buf = frame.frm_buffer in
    let text = buf.buf_text in
    let point = frame.frm_point in
    Simple.kill_bol buf point;
    Simple.self_insert_command frame;      
    string := Text.to_string text
  );
  Keymap.add_binding map [NormalMap, Char.code '/'] (fun frame ->
    let buf = frame.frm_buffer in
    let text = buf.buf_text in
    let point = frame.frm_point in
    if Text.bmove_res text point 1 = 1 then
      ( let c = Text.get_char text point in
        Text.fmove text point 1;
        if c = '/' then
          Simple.kill_bol buf point);
    Simple.self_insert_command frame;
    string := Text.to_string text            
  );
  ()
@

<<function Select.select_filename>>=
let select_filename frame request action =
  let curdir = Frame.current_dir frame in
  select_file frame request file_hist (Utils.filename_to_string curdir) action
@


<<constant Select.next_default>>=
@


<<function Select.get_previous_frame>>=
let get_previous_frame () = 
  match !prev_buffers with
  | [] -> ""
  | x::xs -> x
@

<<constant Select.buf_hist>>=
let buf_hist = ref []
@

<<function Select.select_buffer>>=
let select_buffer frame request default action =
  Select.select frame (request^"(default :"^ default ^ ") ") buf_hist ""
    (fun _ -> buffer_list frame) 
    (fun s ->s) 
    (fun str ->
      let str = if str = "" then default else str in
      action str)
@

<<function Select.select_string>>=
let select_string frame request history default action =
  let map = Keymap.create () in
  let string = ref "" in
  set_history map string history;
  Minibuffer.create_return frame map request default
    (fun _ str -> 
      (match !history with
          hd :: _ when hd = str -> ()
        | _ -> if str <> "" then
              history := str :: !history);
      action str
    ) |> ignore
@

<<function Select.simple_select>>=
let simple_select frame request action =
  let map = Keymap.create () in
  Minibuffer.create_return frame map request "" (fun _ str -> action str) 
   |> ignore
@


%-------------------------------------------------------------

<<features/select.ml>>=
<<copyright header2>>
open Common
open Options
open Efuns

(* small wrappers around Filename but that better handles
 * completion on directories.
 *)
let basename str =
  if str = "" || str =~ ".*/$"
  then ""
  else Filename.basename str

let dirname frame filename =
  let str =
    if Filename.is_relative filename 
    then Filename.concat (Frame.current_dir frame) filename
    else filename
  in
  match str with
  | "" -> Frame.current_dir frame
  | _ when str =~ ".*/$" -> filename
  | _ -> Filename.dirname str


<<function Select.select_yes_or_no>>

<<function Select.find_completion_frame>>

let completions_buf_hook = Local.create_abstr "completions_buf_hook"

<<function Select.display_completions>>

<<function Select.remove_completions>>

<<function Select.set_history>>

<<function Select.incremental_mini_buffer>>

<<function Select.select>>
  
  (****************************************************
  
               Filename selection
  
  ****************************************************)

<<constant Select.file_hist>>

<<constant Select.dont_complete>>
  
<<constant Select.dont_complete_regexps>>
<<function Select.dont_complete_regexp>>

<<function Select.avoid_completion>>

<<function Select.is_userdir>>

<<function Select.complete_filename>>

<<function Select.select_file>>

<<function Select.select_filename>>


  (****************************************************
  
               Other selection
  
  ****************************************************)

<<function Select.select_string>>


<<function Select.simple_select>>
  
  
@


\subsection*{[[features/complexe.ml]]}
% used to be complex.ml, but conflict with stdlib

<<function Complex.save_buffers_and_action>>=
let rec save_buffers_and_action frame buffers action =
  match buffers with
    [] -> let () = action frame in ()
  | (_,buf) :: buffers ->
      let text = buf.buf_text in
      if buf.buf_last_saved = Text.version text  ||
        buf.buf_name.[0] = '*'
      then
        save_buffers_and_action frame buffers action
      else
      let map = Keymap.create () in
      let request = Printf.sprintf "Save buffer %s ? (y,n,!,a)" buf.buf_name
      in
      let yes mini_frame =
        Minibuffer.kill mini_frame frame;
        Ebuffer.save buf;
        save_buffers_and_action frame buffers action
      in
      let no mini_frame =
        Minibuffer.kill mini_frame frame;
        save_buffers_and_action frame buffers action; ()
      in
      let action_immediately mini_frame = 
        Minibuffer.kill mini_frame frame;
        let () = action mini_frame in ()
      in
      let abort mini_frame =
        Minibuffer.kill mini_frame frame
      in
      Keymap.add_binding map [NormalMap, Char.code 'y'] yes;
      Keymap.add_binding map [NormalMap, Char.code 'Y'] yes;
      Keymap.add_binding map [NormalMap, Char.code 'n'] no;
      Keymap.add_binding map [NormalMap, Char.code 'N'] no;
      Keymap.add_binding map [NormalMap, Char.code '!'] action_immediately;
      Keymap.add_binding map [NormalMap, Char.code 'a'] abort;
      Keymap.add_binding map [NormalMap, Char.code 'A'] abort;
      Keymap.add_binding map [ControlMap, Char.code 'g'] abort;
      Minibuffer.create frame map request |> ignore
@



<<function Complex.reload>>=
let reload frame = 
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  match buf.buf_filename with
    None -> ()
  | Some file ->
      let inc = open_in file in
      let s = read_string inc in
      close_in inc;
      let point = frame.frm_point in
      let pos = Text.get_position text point in
      Text.clear buf.buf_text;
      Text.insert_at_end text s;
      Text.set_position text point pos;
      List.iter (fun f -> f buf) buf.buf_major_mode.maj_hooks;
      List.iter (fun minor_mode -> List.iter
          (fun f -> f buf) minor_mode.min_hooks) buf.buf_minor_modes;
      Frame.status_modified frame false 
@




<<function Complex.change_font>>=
let change_font frame =
  Minibuffer.create_return 
    frame (Keymap.create ()) "Find font: " "fixed"
    (fun old_frame name ->
      let window = frame.frm_window in
      let _top_window = Window.top window in
      (*WX_xterm.change_font xterm name*)
      failwith "Complex.change_font: TODO"
  ) |> ignore
@

<<function Complex.color>>=
@

<<constant Complex.display_hist>>=
(*let display_hist = ref []*)
@

<<function Complex.open_display>>=
let open_display frame =
  failwith "Complex.open_display: TODO"
(*
  select frame "open_display :" display_hist ""
    (fun _ -> [])
  (fun s -> s)
  (fun name -> 
      let top_window = Window.top frame.frm_window in
      let location = top_window.top_location in
      let dpy_oo = new WX_display.t name in
      let root_oo = new WX_root.t dpy_oo 0 in
      let display = WX_xterm.create_display root_oo
          location.loc_colors_names location.loc_fonts_names
        in
      Top_window.create location display |> ignore
   )
*)
@





<<constant Complex.umask>>=
let umask = 
  let old = Unix.umask 0 in 
  Unix.umask old |> ignore;
  old
@

<<constant Complex.file_perm>>=
let file_perm = Local.create "file_perm" string_of_int int_of_string
@
% create_int?

<<function Complex.mkdir>>=
let mkdir frame =
  Select.select_filename frame "Make directory: "
    (fun str -> 
      let file_perm = try Var.get_var frame.frm_buffer file_perm with _ -> 
            0x1ff land (lnot umask) in
      Unix.mkdir str file_perm)
@


<<constant Complex.variable_hist>>=
let variable_hist = ref []
@

<<constant Complex.value_hist>>=
let value_hist = ref []
@

<<constant Complex.all_vars>>=
let all_vars = ref None
@

<<function Complex.all_variables>>=
let all_variables frame _ =
  let buf = frame.frm_buffer in
  match !all_vars with
    Some (f,l) when f == frame -> l
  | _ ->
      let list = 
        (Local.list buf.buf_vars) @ 
        (Local.list (Globals.location()).loc_vars) 
      in
      all_vars := Some (frame, list);
      list
@

<<function Complex.set_local_variable>>=
let set_local_variable frame = 
  Select.select frame "set_local_variable : " variable_hist
    "" (all_variables frame) (fun s -> s) (fun variable ->
      Select.select_string frame (Printf.sprintf "%s : " variable)
      value_hist "" (fun value ->
          Local.input frame.frm_buffer.buf_vars variable value))
@

<<function Complex.set_global_variable>>=
let set_global_variable frame =
  Select.select frame "set_global_variable : " variable_hist
    "" (all_variables frame) (fun s -> s) (fun variable ->
      Select.select_string frame (Printf.sprintf "%s : " variable)
      value_hist "" (fun value ->
          Local.input (Globals.location()).loc_vars variable value))
@



<<toplevel Complex._1>>=
let _ =
  Hook.add_start_hook (fun () ->
    let loc = Globals.location() in
      Keymap.add_interactive loc.loc_map "make_directory" mkdir;
      Keymap.add_interactive loc.loc_map "set_local_variable" 
        set_local_variable;
      Keymap.add_interactive loc.loc_map "set_global_variable" 
        set_global_variable;
      Keymap.add_interactive loc.loc_map "set_parameter" set_parameter;
      Keymap.add_interactive loc.loc_map "get_parameter" get_parameter;
      
  )
@


%-------------------------------------------------------------

<<features/complexe.ml>>=
<<copyright header2>>
open Unix
open Utils
open Efuns

<<function Complex.save_buffers_and_action>>

<<constant Complex.buf_mtime>>

<<function Complex.update_time>>
      
<<function Complex.reload>>
      
<<function Complex.check_file>>
    
<<function Complex.exit_efuns>>

<<function Complex.save_some_buffers>>

<<function Complex.load_buffer>>

<<function Complex.insert_file>>

<<function Complex.write_buffer>>

<<function Complex.save_buffer>>

<<function Complex.window_load_buffer>>

<<function Complex.change_buffer>>

<<function Complex.window_change_buffer>>

<<function Complex.change_font>>

<<function Complex.color>>

<<constant Complex.display_hist>>
<<function Complex.open_display>>

<<function Complex.goto_line>>

<<function Complex.goto_char>>


<<function Complex.get_pos>>

<<function Complex.mark_at_point>>

<<constant Complex.umask>>
  
<<constant Complex.file_perm>>
<<function Complex.mkdir>>

<<constant Complex.eval_history>>
<<function Complex.eval>>

<<constant Complex.variable_hist>>
<<constant Complex.value_hist>>
  
<<constant Complex.all_vars>>
<<function Complex.all_variables>>
  
<<function Complex.set_local_variable>>
  
<<function Complex.set_global_variable>>
  
<<function Complex.get_variable>>

open Options
  
<<constant Complex.parameters_hist>>
  
<<function Complex.set_parameter>>
  
<<function Complex.get_parameter>>

  
<<toplevel Complex._1>>
  
@


\subsection*{[[features/system.ml]]}


%-------------------------------------------------------------

<<features/system.ml>>=
open Common
open Efuns
open Unix

type end_action = (Efuns.buffer -> int -> unit)

<<function System.open_process>>

<<function System.system>>

<<function System.start_command>>

<<constant System.shell_hist>>
<<function System.shell_command>>
  
@


\subsection*{[[features/search.ml]]}

<<toplevel Search._1>>=
(*let _ = Time.init ()*)
@


<<function Search.to_regexp>>=
let to_regexp flag str =
  match flag with
  | Regexp ->
      (if !case_fold 
       then Str.regexp_case_fold 
       else Str.regexp
      ) str
  | RegexpString ->
      (if !case_fold 
       then Str.regexp_string_case_fold
       else Str.regexp_string
      ) str
@

<<type Search.query>>=
type query = NoQuery | Query of frame * string
@


<<function Search.no_query>>=
let no_query f = f true
@

<<function Search.query>>=
let query frame request f =
  let top_window = Window.top frame.frm_window in
  top_window.top_second_cursor <- Some frame;
  Select.select_yes_or_no frame request f |> ignore
@

<<constant Search.string_history>>=
let string_history = ref []
@



<<constant Search.library_regexp>>=
let library_regexp = Str.regexp ".*\\.cm[oa]"
@

<<function Search.library_file>>=
let library_file str =
  Str.string_match library_regexp str 0
@

<<function Search.select_lib_filename>>=
let select_lib_filename frame request action =
  Select.select frame request Select.file_hist (Frame.current_dir frame)
  (Select.complete_filename frame library_file)
  Filename.basename action
@


%-------------------------------------------------------------

<<features/search.ml>>=
<<copyright header2>>
open Efuns
    
<<toplevel Search._1>>

<<constant Search.case_fold>>
<<function Search.to_regexp>>

<<type Search.query>>

<<function Search.replace>>


<<function Search.no_query>>
<<function Search.query>>

<<constant Search.string_history>>
<<function Search.select_replace>>

<<function Search.replace_string>>

<<function Search.query_replace_string>>

<<function Search.replace_regexp>>

<<function Search.query_replace_regexp>>

<<constant Search.library_regexp>>
<<function Search.library_file>>

<<function Search.select_lib_filename>>

<<constant Search.last_search>>
<<function Search.isearch>>




<<constant Search.isearch_forward_regexp>>
<<constant Search.isearch_forward>>
<<constant Search.isearch_backward>>
<<constant Search.isearch_backward_regexp>>
  
@


\subsection*{[[features/interactive.ml]]}



%-------------------------------------------------------------

<<features/interactive.ml>>=
<<copyright header2>>
open Efuns
  
<<function Interactive.create_bindings>>

<<constant Interactive.meta_hist>>

<<function Interactive.buf_interactives>>
  
<<function Interactive.exec_interactive>>
      
<<function Interactive.call_interactive>>
@


\subsection*{[[features/abbrevs.ml]]}

%-------------------------------------------------------------

<<features/abbrevs.ml>>=
<<copyright header2>>
(*
Expansion des abbreviations: 
deux fonctions principales: 
- "dabbrev_expand": expansion des mots a partir de mots trouves dans les
     buffers (binding normap "M-/").
- "expand_sabbrev": expansion des mots a partir d'abbreviations trouvees
    dans des tables associees au buffer (variable "abbrev_table") 
    (binding normal: un caractere de fin de mot (espace,newline,..))
*)
open Efuns


<<function Abbrevs.escaped>>
  
<<constant Abbrevs.dabbrev_buf>>
<<function Abbrevs.dabbrev_expand>>

<<constant Abbrevs.abbrev_table>>
  
<<function Abbrevs.expand_sabbrev>>

<<toplevel Abbrevs._1>>
  
@


\subsection*{[[features/multi_buffers.ml]]}


%-------------------------------------------------------------

<<features/multi_buffers.ml>>=
<<copyright header2>>
open Efuns

<<function Simple.buffer_list>>


<<constant Select.prev_buffers>>
<<constant Select.next_default>>
<<function Select.set_previous_frame>>
<<function Select.get_previous_frame>>

(* C-M-l *)
let switch_to_other_buffer frame =
  let default = get_previous_frame () in
  set_previous_frame frame;
  Frame.change_buffer frame.frm_window default
  

<<constant Select.buf_hist>>
<<function Select.select_buffer>>


<<function Simple.next_buffer>>

<<function Simple.kill_buffer>>

<<constant Complex.up_buffer>>
<<function Complex.down_buffer>>

<<function Complex.up_buffer>>
  
<<function Complex.left_buffer>>

<<function Complex.right_buffer>>


@

\subsection*{[[features/multi_frames.ml]]}


%-------------------------------------------------------------

<<features/multi_frames.ml>>=
<<copyright header2>>
open Efuns
  

<<function Multi_frames.cut_frame>>

<<function Multi_frames.remove_frame>>

<<function Multi_frames.v_cut_frame>>

<<function Multi_frames.h_cut_frame>>

<<function Multi_frames.delete_frame>>

<<function Multi_frames.one_frame>>
      
      
<<function Multi_frames.next_frame>>
@


\subsection*{[[features/compil.ml]]}


<<type Compil.error>>=
type error = {
    (* error location *)    
    err_filename : string;
    err_line : int;
    err_begin : int;
    err_end : int;
    (* error message *)
    err_msg : int;
  }
@

<<constant Compil.c_error_regexp>>=
let c_error_regexp = define_option ["compil"; "error_regexp"] "" regexp_option
  (string_to_regex "^\\([^:\n]+\\):\\([0-9]+\\):.*$")
@
%$

<<function Compil.c_find_error>>=
(* todo: vs C_mode.c_find_error? *)
let find_error_gen re text error_point =
  let groups = 
    Text.search_forward_groups text re
      error_point 2 in
  let error =
    {  
      err_msg = Text.get_position text error_point;
      err_filename = groups.(0);
      err_line = (int_of_string groups.(1)) - 1;
      err_begin = 0;
      err_end = 0;
    } in
  Text.fmove text error_point 1;
  error
@








<<function Compil.set_compilation_buffer>>=
let set_compilation_buffer frame comp_buf cdir =
  (*let error_point = new_point comp_buf.buf_text in*)
  let window =
    match !compilation_frame with
    | None -> 
        Multi_frames.cut_frame frame
    | Some (frame,point, _) ->
        Text.remove_point frame.frm_buffer.buf_text point;  
        if frame.frm_killed 
        then Multi_frames.cut_frame frame 
        else frame.frm_window
  in
  let error_point = Text.new_point comp_buf.buf_text in
  let comp_frame = Frame.create window None comp_buf in
  compilation_frame := Some (comp_frame, error_point, cdir)
@

<<constant Compil.grep_command>>=
let grep_command = define_option ["compil"; "grep_command"] "" string_option
    "grep -n"
@

<<constant Compil.grep_hist>>=
let grep_hist = ref [""]
@



%-------------------------------------------------------------

<<features/compil.ml>>=
<<copyright header2>>
open Common
open Options
open Efuns

<<constant Compil.compilation_frame>>

<<type Compil.error>>

type find_error_fun = Text.t -> Text.point -> error

<<constant Compil.c_error_regexp>>

<<function Compil.c_find_error>>

<<constant Compil.find_error>>
<<constant Compil.default_error>>

let find_error_location_regexp = Local.create_abstr "find_error_loc_regexp"
let find_error_error_regexp = Local.create_abstr "find_error_err_regexp"
  
<<function Compil.next_error>>

<<constant Compil.compile_find_makefile>>
  
<<constant Compil.make_command>>

let color_buffer buf =
  Dircolors.colorize buf;

  let re =
    try Var.get_var buf find_error_location_regexp
    with Not_found | Failure _ -> snd !!c_error_regexp
  in
  Simple.color buf re false
    (Text.make_attr (Attr.get_color "green") 1 0 false);

  let re =
    try Var.get_var buf find_error_error_regexp
    with Not_found | Failure _ -> Str.regexp "Error"
  in
  Simple.color buf re false
    (Text.make_attr (Attr.get_color "red") 1 0 false);
  ()

let install buf =
  color_buffer buf

let mode = Ebuffer.new_major_mode "Compilation" [install]
  
<<constant Compil.make_hist>>
<<function Compil.compile>>

<<function Compil.set_compilation_buffer>>
  
<<constant Compil.grep_command>>
  
<<constant Compil.grep_hist>>
<<function Compil.grep>>
@




















\section{[[graphics/]]}

\subsection*{[[graphics/top_window.ml]]}


%<<[[Efuns.frame]] other fields>>=
%mutable frm_repeat_action : int;
%@
%% for undo?
%
%<<[[Top_window.try_map()]] set repeat action>>=
%frame.frm_repeat_action <- 
%  if (f == frame.frm_last_action) 
%  then frame.frm_repeat_action + 1
%  else 0;
%@





<<function Top_window.resize_window>>=
let rec resize_window window xpos ypos width height =
  let old_width = window.win_width in
  let old_height = window.win_height in
  window.win_xpos <- xpos;
  window.win_ypos <- ypos;
  window.win_width <- width;
  window.win_height <- height;
  match window.win_down with
    WFrame frame -> Frame.install window frame
  | NoFrame () -> assert false
  | HComb (w1,w2) ->
      let wi1 = w1.win_width * width / old_width in
      resize_window w1 xpos ypos wi1 height;
      resize_window w2 (xpos + wi1) ypos (width - wi1) height
  | VComb (w1,w2) ->
      let he1 = w1.win_height * height / old_height in
      resize_window w1 xpos ypos width he1;
      resize_window w2 xpos (ypos + he1) width (height - he1)
@

<<function Top_window.find_frame>>=
let rec find_frame window x y =
  match window.win_down with
    NoFrame () -> assert false
  | WFrame frame -> frame
  | HComb (w1,w2) -> 
      if w2.win_xpos > x then find_frame w1 x y
      else find_frame w2 x y
  | VComb (w1,w2) ->
      if w2.win_ypos > y then find_frame w1 x y
      else find_frame w2 x y
@



<<function Top_window.find_selected_frame>>=
let find_selected_frame top_window =
  let x = !mouse_x in
  let y = !mouse_y in
  let frame = 
    if y > top_window.top_height - 2 then
      match top_window.top_mini_buffers with
        [] -> raise Not_found
      | mini_frame :: _ -> mini_frame
    else
      find_frame top_window.window x y
  in
  Frame.active frame;
  frame
@

<<function Top_window.mouse_set_active>>=
let mouse_set_active top_window =
  let x = !mouse_x in
  let y = !mouse_y in
  let frame = find_selected_frame top_window in
  Frame.move_point frame frame.frm_point x y;
  frame
@

<<function Top_window.mini_message>>=
let mini_message frame msg =
  let top_window = Window.top frame.frm_window in
  message top_window msg
@




<<function Top_window.wrap>>=
let wrap top_window f () = 
  let loc = Globals.location() in
  Mutex.lock loc.loc_mutex;  
  clean_display ();    
  clear_message top_window;
  keypressed := XK.xk_Menu;
  let frame = top_window.top_active_frame in
  Hook.exec_hooks (try Var.get_global handle_key_start_hook with _ ->[]) frame;
  begin
    try f top_window 
    with e -> message top_window (Printf.sprintf "Uncaught exception %s" 
                                    (Utils.printexn e))
  end;
  Hook.exec_hooks (try Var.get_global handle_key_end_hook with _ -> []) ();    
  update_display ();
  Mutex.unlock loc.loc_mutex
@

<<function Top_window.wrap_item>>=
let wrap_item top_window (n,f) =
  n, wrap top_window (fun top_window -> f top_window.top_active_frame)
@


<<constant Top_window.buffers_menu>>=
let buffers_menu = ref 
  (fun (top_window : top_window) (button : (*WX_button.t*) unit) ()
  -> ())
@


<<constant Top_window.menus>>=
let menus = define_option ["menus"] ""
    (list_option (tuple2_option (string_option, list_option string2_option)))
  []
@




<<constant Top_window.check_abort>>=
(*let check_abort = ref 0*)
@

<<constant Top_window.check_abort_delay>>=
(*let check_abort_delay = ref 100*)
@

<<function Top_window.check_abort>>=
let check_abort frame =
  failwith "Top_window.check_abort: TODO"
(*
  incr check_abort; 
  if !check_abort mod !check_abort_delay = 0 then
    let top_window = Window.top frame.frm_window in
    let xterm = top_window.top_term in
    xterm#check_abort
  else false
*)
@


%-------------------------------------------------------------

<<graphics/top_window.ml>>=
<<copyright header2>>
open Common
open Options
open Efuns

  
<<function Top_window.message>>

<<function Top_window.clear_message>>

<<function Top_window.try_map>>

<<function Top_window.set_cursor_on>>

<<function Top_window.set_cursor_off>>

<<function Top_window.cursor_on>>

<<function Top_window.cursor_off>>


<<function Top_window.update_display>>

<<function Top_window.clean_display>>

<<function Top_window.resize_window>>

<<function Top_window.find_frame>>

<<constant Top_window.keypressed>>
<<constant Top_window.mouse_x>>
<<constant Top_window.mouse_y>>

<<function Top_window.find_selected_frame>>


<<function Top_window.mouse_set_active>>


<<function Top_window.mini_message>>

<<constant Top_window.handle_key_start_hook>>
<<constant Top_window.handle_key_end_hook>>
  
<<constant Top_window.meta>>
  
<<function Top_window.handle_key>>

  (* We can receive events from different sources. In particular, some of
  them can be received during the painting (scrollbar ...)
  *)
  
<<function Top_window.wrap>>

<<function Top_window.wrap_item>>
        
<<function Top_window.handler>>


<<constant Top_window.buffers_menu>>

<<function Top_window.scroll_to_frame>>


<<constant Top_window.menus>>
<<constant Top_window.file_menu>>
<<constant Top_window.edit_menu>>
<<constant Top_window.help_menu>>

  
  
<<function Top_window.create>>

<<function Top_window.delete_window>>

        
<<constant Top_window.check_abort>>
<<constant Top_window.check_abort_delay>>

  (* This function should be used in loops that could be interrupted by
  the user. It returns "true" if the user pressed C-g, and false
  in other cases. *)
  
<<function Top_window.check_abort>>

@


\section{[[./]]}

\subsection*{[[std_efunsrc.ml]]}



%-------------------------------------------------------------

<<std_efunsrc.ml>>=
<<copyright header2>>
open Utils
open Options
open Efuns
open Action

<<constant Std_efunsrc.grep_hist>>

<<function Std_efunsrc.save_options>>
<<function Std_efunsrc.fondamental_mode>>

<<function Std_efunsrc.compile>>

<<toplevel Std_efunsrc._1>>
  
  
<<constant Std_efunsrc.global_map>>
<<constant Std_efunsrc.interactives_map>>

open Keymap (* c_xxx *)

<<toplevel Std_efunsrc._2>>
    
<<function Std_efunsrc.init_global_map>>
  
(*open WX_filesel*)
 
<<toplevel Std_efunsrc._4>>
  
<<toplevel Std_efunsrc._5>>
@


\subsection*{[[main.ml]]}

%let dpy_oo = new WX_display.t !displayname
%let root_oo = new WX_root.t dpy_oo 0
%let display = WX_xterm.create_display root_oo
%  location.loc_colors_names location.loc_fonts_names 
%
%let top_window = Top_window.create location display
%let _ =
%  WX_xterm.setHighlight display 2;
%  Dyneval.init true;
%  Eval.load top_window "Efunsrc";
%  Efuns.init location; (* launch second hooks *)
%  let _ = Interactive.create_bindings location in
%(* open the fisrt buffers *)
%  List.iter (fun name ->
%    let _ = Frame.load_file top_window.window name in ()) 
%  !init_files;
%  List.iter 
%    (fun str -> let top_window = Top_window.create top_window.top_location
%          (Window.display top_window) in
%      let _ = Frame.load_file top_window.window str in ()) !init_frames;
%  Top_window.update_display location;
%
%  
%  if not (Sys.file_exists (Filename.concat Utils.homedir ".efunsrc")) then
%    begin
%      Printf.printf "Saving .efunsrc after install"; print_newline ();
%      Options.save ();
%    end;
%
%  if !check then exit 0;  
%  (* Main loop *)
%  let rec loop () =
%    try
%      WX_types.loop ()
%    with
%      SigInt -> loop ()
%  in
%  loop ()


%-------------------------------------------------------------

% was copyright header2, but better to use header1
<<main.ml>>=
<<copyright header>>
open Options
open Efuns

<<constant Efuns.init_files>>
<<constant Efuns.init_frames>>
<<constant Efuns.displayname>>
<<constants Main options>>
<<constant Main.highlight_color>>

<<function Efuns.init>>

<<exception Main.SigInt>>

<<constants Main.xxx_opt>>
  
<<constant Efuns.usage_str>>
  
<<function Main.main>>

<<toplevel Main._>>

@






\section{[[major_modes/]]}

\subsection*{[[major_modes/dired.ml]]}

<<function Dired.update>>=
let update buf =
  let filename = match buf.buf_filename with
      None -> failwith "Not a directory"
    | Some filename -> filename in
  let s = Utils.load_directory filename in
  let text = buf.buf_text in
  Text.update text s;
  (* pad extension *)
  Dircolors.colorize buf;
  buf.buf_last_saved <- Text.version text
@

<<constant Dired.file_reg>>=
let file_reg = Str.regexp ".* \\([^ ]+\\)$"
@
%$

<<function Dired.get_file_line>>=
let get_file_line frame =
  frame.frm_buffer.buf_filename |> Common.do_option (fun filename ->
    (Globals.location()).loc_dirname <- Filename.dirname filename;
  );
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let start_point = Text.dup_point text point in
  let before = Text.point_to_bol text point in
  let after = Text.point_to_eol text point in
  Text.bmove text start_point before;
  let line = Text.sub text start_point (before + after) in
  Text.remove_point text start_point;
  line
@

<<function Dired.select_file>>=
let select_file line =
  if line.[0] = ' ' 
  then
    if Str.string_match file_reg line 0 
    then Str.matched_group 1 line 
    else String.sub line 60 (String.length line - 60)
  else
    failwith "Dired: not a file line"
@

<<function Dired.dirname>>=
let dirname frame =
  match frame.frm_buffer.buf_filename with
    None -> "."
  | Some dirname -> dirname 
@

<<function Dired.fullname>>=
let fullname frame filename = 
  Filename.concat (dirname frame) filename
@

<<function Dired.open_file>>=
let open_file frame =
  let filename = fullname frame (select_file (get_file_line frame)) in
  let buf = Ebuffer.read filename (Keymap.create ()) in
  let frame = Frame.create  frame.frm_window None buf in
  Frame.active frame
@

<<function Dired.remove>>=
let remove frame =
  let line = get_file_line frame in   
  let filename = select_file line in
  Select.select_yes_or_no frame (Printf.sprintf "Remove %s ? (y/n)" filename)
    (fun b -> if b then
          if line.[1] = 'd' then Unix.rmdir filename else
          Unix.unlink filename;
        update frame.frm_buffer) |> ignore
@

<<constant Dired.view_list>>=
let view_list = ref []
@

<<constant Dired.old_view_list>>=
let old_view_list = ref []
@

<<constant Dired.compiled_view_list>>=
let compiled_view_list = ref []
@

<<function Dired.fast_view>>=
let fast_view frame filename =
  if not (!old_view_list == !view_list) then
    begin
      compiled_view_list := List.map 
        (fun (file_reg, appli) ->
          Str.regexp file_reg, appli) !view_list;
      old_view_list := !view_list
    end;
  try
    List.iter (fun (regexp, viewer) ->
        if Str.string_match regexp filename 0 then
          try
            Unix.chdir (dirname frame);
            viewer frame filename;
            raise Exit
          with
            _ -> raise Exit
    ) !compiled_view_list;
    let _ = 
      Select.select_yes_or_no frame (Printf.sprintf "Open %s ? (y/n)" filename)
      (fun b -> if b then
            open_file frame) in
      ()

  with
    Exit -> ()      
@

<<function Dired.open_view>>=
let open_view frame =
  let filename = select_file (get_file_line frame) in
  fast_view frame filename
@

<<function Dired.mkdir>>=
let mkdir frame =
  failwith "Dired.mkdir: TODO"
(*
  Select.select_filename frame "Make directory: "
    (fun str -> 
      let file_perm = try get_var frame.frm_buffer file_perm with _ -> 
            0x1ff land (lnot umask) in
      Unix.mkdir str file_perm;
      update frame.frm_buffer)
*)
@

<<function Dired.install>>=
let install buf = 
  match buf.buf_filename with
    None -> 
      failwith "Dired: Not a directory"
  | Some filename ->
      if not (Utils.is_directory filename) then 
        failwith (Printf.sprintf "Dired: %s not a directory" filename);
      update buf
@

<<constant Dired.mode>>=
let mode = Ebuffer.new_major_mode "Dired" [install]
@

<<constant Dired.map>>=
let map = mode.maj_map
@

<<function Dired.viewer>>=
let viewer commande frame filename =
  Sys.command (Printf.sprintf "(%s %s) &" commande filename) |> ignore
@

<<function Dired.commande>>=
let commande commande frame filename =
  Sys.command (Printf.sprintf commande filename) |> ignore;
  failwith  (Printf.sprintf commande filename)
@

<<function Dired.unzip_and_view>>=
let unzip_and_view frame filename =
  let new_filename = Printf.sprintf "/tmp/efuns-view-%s" (
      Filename.chop_extension filename) in
  let res = Sys.command (
      Printf.sprintf "gzip -cd %s > %s" filename new_filename)
  in
  if res = 0 then fast_view frame new_filename
@

<<toplevel Dired._1>>=
let _ = 
  Keymap.interactive map [NormalMap, XK.xk_Return] "dired_open_file" 
    open_file;
  Keymap.interactive map [NormalMap, Char.code 'g'] "dired_update" 
    (fun frame -> update frame.frm_buffer);  
  Keymap.interactive map [NormalMap, Char.code 'v'] "dired_view_file" 
    open_view;  
  Keymap.interactive map [NormalMap, Char.code '+'] "dired_make_directory" 
    mkdir;  
  Keymap.interactive map [NormalMap, Char.code '-'] "dired_remove_entry" 
    remove;  
  
  view_list := [
    ".*\\(\\.jpg\\|\\..gig\\|\\.xpm\\|\\.ppm\\)",viewer "xv";
    ".*\\(\\.ps\\|\\.PS\\)",viewer "gv";
    ".*\\(\\.dvi\\)",viewer "xdvi";
    ".*\\(\\.gz\\|\\.Z\\|\\.z\\)",unzip_and_view; 
    ".*\\.tgz", commande "xterm -e sh -c \"tar zvtf %s | less\"";
    ".*\\.tar", commande "xterm -e sh -c \"tar vtf %s | less\"";
    ".*\\.tar", commande "xterm -e sh -c \"tar vtf %s | less\"";
    ];
  
  Hook.add_start_hook (fun () ->
    Keymap.add_interactive ((Globals.location()).loc_map) "dired_mode" 
        (fun frame -> 
          Ebuffer.set_major_mode frame.frm_buffer mode);
    Var.set_global Ebuffer.modes_alist 
      ((".*/$",mode) :: (Var.get_global Ebuffer.modes_alist));
  )   
@
%$


%-------------------------------------------------------------

<<major_modes/dired.ml>>=
<<copyright header>>
open Efuns


<<function Dired.update>>

<<constant Dired.file_reg>>
  
<<function Dired.get_file_line>>
    
<<function Dired.select_file>>

<<function Dired.dirname>>
      
<<function Dired.fullname>>
      
<<function Dired.open_file>>
  
<<function Dired.remove>>

<<constant Dired.view_list>>
<<constant Dired.old_view_list>>
<<constant Dired.compiled_view_list>>
  
<<function Dired.fast_view>>
  
<<function Dired.open_view>>
  
<<function Dired.mkdir>>
          
<<function Dired.install>>
      
<<constant Dired.mode>>

<<constant Dired.map>>
  

<<function Dired.viewer>>

<<function Dired.commande>>
  
<<function Dired.unzip_and_view>>
    
<<toplevel Dired._1>>
@


\section{[[minor_modes/]]}

\subsection*{[[minor_modes/minor_mode_sample.ml]]}

%-------------------------------------------------------------

<<minor_modes/minor_mode_sample.ml>>=
<<copyright header2>>
open Efuns
          
<<constant Minor_mode_sample.minor_mode_name>>

<<function Minor_mode_sample.install>>

<<function Minor_mode_sample.minor_mode_fun>>
  
<<constant Minor_mode_sample.mode>>

<<toplevel Minor_mode_sample._1>>

<<toplevel Minor_mode_sample._2>>
    
@


\subsection*{[[minor_modes/abbrevs_mode.ml]]}

<<constant Abbrevs_mode.abbreviations>>=
let abbreviations = define_option ["abbrevs_mode"; "abbrevs"] ""
    (list_option string2_option) []
@

<<constant Abbrevs_mode.abbrevs>>=
let abbrevs = Hashtbl.create 11
@

<<toplevel Abbrevs_mode._1>>=
let _ =
  Utils.hash_add_assoc abbrevs !!abbreviations
@

<<function Abbrevs_mode.install>>=
let install buf =
  try Var.get_local buf abbrev_table |> ignore
  with _ -> Var.set_local buf abbrev_table abbrevs
@

<<constant Abbrevs_mode.mode>>=
let mode = Ebuffer.new_minor_mode "abbrevs" [install]
@

<<constant Abbrevs_mode.abbrevs_chars>>=
let abbrevs_chars = define_option ["abbrevs_mode"; "abbrevs_chars"] ""
    string_option " "
@

<<function Abbrevs_mode.find_matching>>=
let find_matching  frame = 
  self_insert_command frame; 
  Paren_mode.highlight_paren frame
@

<<function Abbrevs_mode.char_expand_abbrev>>=
let char_expand_abbrev frame =
  expand_sabbrev frame; self_insert_command frame
@

<<toplevel Abbrevs_mode._2>>=
let _ = 
  let chars = !!abbrevs_chars in
  for i = 0 to String.length chars - 1 do
    Keymap.add_binding mode.min_map [NormalMap, Char.code chars.[i]]
      char_expand_abbrev
  done
@

<<toplevel Abbrevs_mode._3>>=
let _ = 
  Action.define_action "abbrevs_mode" 
    (fun frame -> 
      let buf = frame.frm_buffer in
      if Ebuffer.modep buf mode 
      then Ebuffer.del_minor_mode buf mode
      else Ebuffer.set_minor_mode buf mode
    )
@


%-------------------------------------------------------------

<<minor_modes/abbrevs_mode.ml>>=
<<copyright header2>>
open Options
open Abbrevs
open Simple
open Efuns

<<constant Abbrevs_mode.abbreviations>>
  
<<constant Abbrevs_mode.abbrevs>>
<<toplevel Abbrevs_mode._1>>
  
<<function Abbrevs_mode.install>>

<<constant Abbrevs_mode.mode>>

<<constant Abbrevs_mode.abbrevs_chars>>
  
<<function Abbrevs_mode.find_matching>>
<<function Abbrevs_mode.char_expand_abbrev>>
  
<<toplevel Abbrevs_mode._2>>

<<toplevel Abbrevs_mode._3>>

@


\subsection*{[[minor_modes/accents_mode.ml]]}

<<function Accents_mode.accent>>=
let accent frame =
  let key = !keypressed in
  let c = previous_char frame in
  try
    let key = 
      if key = XK.xk_grave then
        match c with
        | 'e' -> XK.xk_egrave
        | 'a' -> XK.xk_agrave
        | 'i' -> XK.xk_igrave 
        | 'o' -> XK.xk_ograve 
        | 'u' -> XK.xk_ugrave
        | 'A' -> XK.xk_Agrave
        | 'E' -> XK.xk_Egrave
        | 'I' -> XK.xk_Igrave
        | 'O' -> XK.xk_Ograve
        | 'U' -> XK.xk_Ugrave 
        | _ -> raise Not_found
      else 
      if key = XK.xk_apostrophe then
        match c with
        | 'e' -> XK.xk_eacute
        | 'E' -> XK.xk_Eacute
        
        | 'a' -> XK.xk_aacute
        | 'i' -> XK.xk_iacute
        | 'o' -> XK.xk_oacute
        | 'u' -> XK.xk_uacute
        | 'A' -> XK.xk_Aacute
        | 'I' -> XK.xk_Iacute
        | 'O' -> XK.xk_Oacute
        | 'U' -> XK.xk_Uacute
        
        | _ -> raise Not_found
      else
      if key = XK.xk_semicolon then
        match c with
          'c' -> XK.xk_ccedilla
        | _ -> raise Not_found
      else
      if key = XK.xk_asciicircum then
        match c with
        | 'e' -> XK.xk_ecircumflex
        | 'a' -> XK.xk_acircumflex 
        | 'i' -> XK.xk_icircumflex
        | 'o' -> XK.xk_ocircumflex
        | 'u' -> XK.xk_ucircumflex
        | 'A' -> XK.xk_Acircumflex
        | 'E' -> XK.xk_Ecircumflex
        | 'I' -> XK.xk_Icircumflex
        | 'O' -> XK.xk_Ocircumflex
        | 'U' -> XK.xk_Ucircumflex 
        | _ -> raise Not_found
      else              
      if key = XK.xk_quotedbl then
        match c with
        | 'e' -> XK.xk_ediaeresis
        | 'a' -> XK.xk_adiaeresis 
        | 'i' -> XK.xk_idiaeresis
        | 'o' -> XK.xk_odiaeresis
        | 'u' -> XK.xk_udiaeresis
        | 'A' -> XK.xk_Adiaeresis
        | 'E' -> XK.xk_Ediaeresis
        | 'I' -> XK.xk_Idiaeresis
        | 'O' -> XK.xk_Odiaeresis
        | 'U' -> XK.xk_Udiaeresis 
        | _ -> raise Not_found
      else              
      if key = XK.xk_asciitilde then
        match c with
        | 'n' -> XK.xk_ntilde
        | 'a' -> XK.xk_atilde
        | 'o' -> XK.xk_otilde
        | 'A' -> XK.xk_Atilde
        | 'N' -> XK.xk_Ntilde
        | 'O' -> XK.xk_Otilde 
        | _ -> raise Not_found
      else              
        raise Not_found
    in
    bmove frame.frm_buffer.buf_text frame.frm_point 1;
    insert_at_place frame (Char.chr key)
  with
    Not_found ->
      try
        let c = Char.code c in
        let c = 
          if key = XK.xk_grave then
            if c = XK.xk_egrave then 'e' else
            if c = XK.xk_agrave then 'a' else
            if c = XK.xk_igrave then 'i' else 
            if c = XK.xk_ograve then 'o' else 
            if c = XK.xk_ugrave then 'u' else
            if c = XK.xk_Agrave then 'A' else
            if c = XK.xk_Egrave then 'E' else
            if c = XK.xk_Igrave then 'I' else
            if c = XK.xk_Ograve then 'O' else
            if c = XK.xk_Ugrave then 'U' else 
              raise Not_found
          else 
          if key = XK.xk_apostrophe then
            if c = XK.xk_eacute then 'e' else
            if c = XK.xk_Eacute then 'E' else
            if c = XK.xk_aacute then 'a' else
            if c = XK.xk_iacute then 'i' else
            if c = XK.xk_oacute then 'o' else
            if c = XK.xk_uacute then 'u' else
            if c = XK.xk_Aacute then 'A' else
            if c = XK.xk_Iacute then 'I' else
            if c = XK.xk_Oacute then 'O' else
            if c = XK.xk_Uacute then 'U' else
              raise Not_found
          else
          if key = XK.xk_semicolon then
            if c = XK.xk_ccedilla then 'c' else
              raise Not_found
          else
          if key = XK.xk_asciicircum then
            if c = XK.xk_ecircumflex then 'e' else
            if c = XK.xk_acircumflex then 'a' else 
            if c = XK.xk_icircumflex then 'i' else
            if c = XK.xk_ocircumflex then 'o' else
            if c = XK.xk_ucircumflex then 'u' else
            if c = XK.xk_Acircumflex then 'A' else
            if c = XK.xk_Ecircumflex then 'E' else
            if c = XK.xk_Icircumflex then 'I' else
            if c = XK.xk_Ocircumflex then 'O' else
            if c = XK.xk_Ucircumflex then 'U' else 
              raise Not_found
          else              
          if key = XK.xk_quotedbl then
            if c = XK.xk_ediaeresis then 'e' else
            if c = XK.xk_adiaeresis then 'a' else 
            if c = XK.xk_idiaeresis then 'i' else
            if c = XK.xk_odiaeresis then 'o' else
            if c = XK.xk_udiaeresis then 'u' else
            if c = XK.xk_Adiaeresis then 'A' else
            if c = XK.xk_Ediaeresis then 'E' else
            if c = XK.xk_Idiaeresis then 'I' else
            if c = XK.xk_Odiaeresis then 'O' else
            if c = XK.xk_Udiaeresis then 'U' else 
              raise Not_found
          else              
          if key = XK.xk_asciitilde then
            if c = XK.xk_ntilde then 'n' else
            if c = XK.xk_atilde then 'a' else
            if c = XK.xk_otilde then 'o' else
            if c = XK.xk_Atilde then 'A' else
            if c = XK.xk_Ntilde then 'N' else
            if c = XK.xk_Otilde then 'O' else 
              raise Not_found
          else              
            raise Not_found
        in
        bmove frame.frm_buffer.buf_text frame.frm_point 1;
        insert_at_place frame c;
        insert_char frame (Char.chr key)
      with
        Not_found ->
          insert_char frame (Char.chr key)
@

<<function Accents_mode.install>>=
let install buf =
  List.iter (fun key ->
      buf.buf_syntax_table.(key) <- true)
  [ XK.xk_egrave; XK.xk_agrave; XK.xk_igrave; XK.xk_ograve; XK.xk_ugrave;
    XK.xk_Agrave; XK.xk_Egrave; XK.xk_Igrave; XK.xk_Ograve; XK.xk_Ugrave;
    XK.xk_eacute; XK.xk_aacute; XK.xk_iacute; XK.xk_oacute; XK.xk_uacute;
    XK.xk_Aacute; XK.xk_Eacute; XK.xk_Iacute; XK.xk_Oacute; XK.xk_Uacute;
    XK.xk_ccedilla;
    XK.xk_ecircumflex; XK.xk_acircumflex; XK.xk_icircumflex;
    XK.xk_ocircumflex; XK.xk_ucircumflex; XK.xk_Acircumflex;
    XK.xk_Ecircumflex; XK.xk_Icircumflex; XK.xk_Ocircumflex;
    XK.xk_Ucircumflex;
    XK.xk_ediaeresis; XK.xk_adiaeresis; XK.xk_idiaeresis; XK.xk_odiaeresis;
    XK.xk_udiaeresis; XK.xk_Adiaeresis; XK.xk_Ediaeresis; XK.xk_Idiaeresis;
    XK.xk_Odiaeresis; XK.xk_Udiaeresis;
    XK.xk_ntilde; XK.xk_atilde; XK.xk_otilde;
    XK.xk_Atilde; XK.xk_Ntilde; XK.xk_Otilde; ]
@

<<constant Accents_mode.mode>>=
let mode = Ebuffer.new_minor_mode  "accents" [install]
@

<<toplevel Accents_mode._1>>=
let _ = 
  List.iter
    (fun key -> 
      Keymap.add_binding mode.min_map [NormalMap, key] accent
  )
  [ XK.xk_apostrophe; XK.xk_grave; XK.xk_semicolon; XK.xk_asciicircum;
    XK.xk_quotedbl; XK.xk_asciitilde]
@

<<toplevel Accents_mode._2>>=
let _ = 
  define_buffer_action "accents_mode" 
    (fun buf -> 
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode)
@


%-------------------------------------------------------------

<<minor_modes/accents_mode.ml>>=
<<copyright header2>>
open Simple
open Efuns
open Top_window
  
(* franc;ais strict *)
<<function Accents_mode.accent>>
          
          
<<function Accents_mode.install>>
  
<<constant Accents_mode.mode>>

<<toplevel Accents_mode._1>>

<<toplevel Accents_mode._2>>

@


\subsection*{[[minor_modes/fill_mode.ml]]}

<<constant Fill_mode.minor_mode_name>>=
let minor_mode_name = "fill"
@

<<function Fill_mode.install>>=
let install buf = ()
@

<<constant Fill_mode.fill_line_len>>=
let fill_line_len = define_option ["fill_line_len"] "" int_option 80
@

<<constant Fill_mode.mode>>=
let mode = Ebuffer.new_minor_mode minor_mode_name [install]
@

<<constant Fill_mode.fill_on_char>>=
let fill_on_char = define_option ["fill_on_char"] "" string_option " "
@

<<toplevel Fill_mode._1>>=
let _ =
  let fill_on_char = !!fill_on_char in
  for i = 0 to String.length fill_on_char - 1 do 
      Keymap.add_binding mode.min_map [NormalMap, Char.code fill_on_char.[i]] 
        electric_insert_space
  done
@

<<toplevel Fill_mode._2>>=
let _ = 
  Action.define_buffer_action (minor_mode_name ^ "_mode")
    (fun buf -> 
      if Ebuffer.modep buf mode 
      then Ebuffer.del_minor_mode buf mode
      else Ebuffer.set_minor_mode buf mode
     );
@


%-------------------------------------------------------------

<<minor_modes/fill_mode.ml>>=
<<copyright header2>>
open Options
open Simple
open Efuns
          
<<constant Fill_mode.minor_mode_name>>
  
<<function Fill_mode.install>>

<<constant Fill_mode.fill_line_len>>
  
<<constant Fill_mode.mode>>

<<constant Fill_mode.fill_on_char>>
  
<<toplevel Fill_mode._1>>
  
<<toplevel Fill_mode._2>>
    
    
@


\subsection*{[[minor_modes/paren_mode.ml]]}

<<constant Paren_mode.mode>>=
let mode = Ebuffer.new_minor_mode "paren" []
@

<<function Paren_mode.find_matching>>=
let find_matching frame = 
  self_insert_command frame; 
  highlight_paren frame
@

<<toplevel Paren_mode._1>>=
let _ = 
  [ ')'; '}'; ']' ] |> List.iter (fun key -> 
    Keymap.add_binding mode.min_map [NormalMap, Char.code key] find_matching
  ) 
@

<<toplevel Paren_mode._2>>=
let _ = 
  Action.define_buffer_action "paren_mode" 
    (fun buf -> 
      if Ebuffer.modep buf mode 
      then Ebuffer.del_minor_mode buf mode
      else Ebuffer.set_minor_mode buf mode
    )
@


%-------------------------------------------------------------

<<minor_modes/paren_mode.ml>>=
<<copyright header2>>
open Simple
open Efuns

module H = Highlight

<<constant Simple.htmlp>>
<<function Simple.is_paren_end>>
<<function Simple.is_paren_begin>>

<<function Simple.highlight_paren>>




<<constant Paren_mode.mode>>

<<function Paren_mode.find_matching>>
  
<<toplevel Paren_mode._1>>

<<toplevel Paren_mode._2>>
@


\subsection*{[[minor_modes/tab_mode.ml]]}

<<constant Tab_mode.mode>>=
let mode = Ebuffer.new_minor_mode "tab" []
@

<<function Tab_mode.insert_tab>>=
let insert_tab frame = 
  insert_string frame "\t" |> ignore
@

<<toplevel Tab_mode._1>>=
let _ = 
  Keymap.add_binding mode.min_map [NormalMap, XK.xk_Tab] insert_tab
@

<<toplevel Tab_mode._2>>=
let _ = 
  Action.define_buffer_action "tab_mode" 
    (fun buf -> 
      if Ebuffer.modep buf mode 
      then Ebuffer.del_minor_mode buf mode
      else Ebuffer.set_minor_mode buf mode
  );
  Action.define_action "insert_tab" insert_tab
@

%-------------------------------------------------------------

<<minor_modes/tab_mode.ml>>=
<<copyright header2>>
open Simple
open Efuns

<<constant Tab_mode.mode>>
  
<<function Tab_mode.insert_tab>>
  
<<toplevel Tab_mode._1>>

<<toplevel Tab_mode._2>>
@



\section{[[prog_modes/]]}

\subsection*{[[prog_modes/makefile_mode.ml]]}

\subsubsection{Colors}

<<constant Makefile_mode.mkfile_vars>>=
let mkfile_vars= Str.regexp "\\(\\$([a-zA-Z0-9_]*)\\)\\|\\([a-zA-Z0-9_]+=\\)"
@
%$

<<constant Makefile_mode.mkfile_target>>=
let mkfile_target= Str.regexp "^.*:"
@

<<constant Makefile_mode.mkfile_rules>>=
let mkfile_rules= Str.regexp "^\t.*$"
@
%$

<<constant Makefile_mode.vars_color>>=
@
<<constant Makefile_mode.target_color>>=
let target_color = define_option ["makefile_mode"; "target_color"] ""
    string_option "MediumAquamarine"
@
<<constant Makefile_mode.rules_color>>=
let rules_color = define_option ["makefile_mode";"rules_color"] "" 
  string_option "orange"
@

% font-lock-mode :)
<<function Makefile_mode.makefile_color>>=
let makefile_color buf =
  Simple.color buf mkfile_rules false
    (Text.make_attr (Attr.get_color !!rules_color) 1 0 false);
  Simple.color buf mkfile_target false 
    (Text.make_attr (Attr.get_color !!target_color) 1 0 false);
  Simple.color buf mkfile_vars false 
    (Text.make_attr (Attr.get_color !!Pl_colors.variable_name_color) 1 0 false);
  Simple.color buf mkfile_comments false 
    (Text.make_attr (Attr.get_color !!Pl_colors.comment_color) 1 0 false);
  ()
@

<<function Makefile_mode.install>>=
let install buf =
  makefile_color buf;
  Action.execute_buffer_action "tab_mode" buf
@
<<constant Makefile_mode.mode>>=
let mode = Ebuffer.new_major_mode "Makefile" [makefile_color]
@
% should be install instead no? bug?

\subsubsection{Keys and actions}

<<constant Makefile_mode.c_c>>=
let c_c = (ControlMap,Char.code 'c')
@

% its own configuration!
<<constant Makefile_mode.local_map>>=
let local_map = define_option ["makefile_mode"; "local_map"] ""
    (list_option Simple.binding_option) []
@
<<constant Makefile_mode.interactives_map>>=
let interactives_map = define_option ["makefile_mode"; "interactives_map"] ""
    (list_option string2_option) 
  []
@
% useful? redundant this interactives_map no?


<<toplevel Makefile_mode._2>>=
let _ = 
  Action.define_action "makefile_mode.color_buffer" 
    (fun frame -> makefile_color frame.frm_buffer);
  Action.define_action "makefile_mode" makefile_mode;
  ()
@
%(*  define_action "insert_tab" insert_tab; *)
% why not use define_buffer_action for color_buffer?

<<toplevel Makefile_mode._1>>=
let _ =
  if !!local_map = [] then
    local_map =:= [
      [c_c; ControlMap, Char.code 'c'], "makefile_mode.compile";    
      [ControlMap, Char.code 'l'], "makefile_mode.color_buffer";
     (*  [NormalMap, XK.xk_Tab], "insert_tab"; *)
    ];
  if !!interactives_map = [] then 
        interactives_map =:= [
          "color_buffer", "makefile_mode.color_buffer";
          (*"compile", "makefile_mode.compile";*)
      ]
@
% meh for interactives, ok shorter name, but meh
%less: forced to do C-l to recolor :(

\subsubsection{Major mode}

<<function Makefile_mode.makefile_mode>>=
let makefile_mode frame = 
  Ebuffer.set_major_mode frame.frm_buffer mode
@


<<toplevel Makefile_mode._3>>=
let _ =
  let map = mode.maj_map in
  !!local_map |> List.iter (fun (keys, action) ->
      try
        Keymap.add_binding map keys (Action.execute_action action)
      with e ->
          Log.printf "Error for action %s" action;
          Log.exn "%s\n" e;
  
  );
  !!interactives_map |> List.iter (fun (name, action) ->
      try
        Keymap.add_interactive map name (Action.execute_action action)
      with e ->
          Log.printf "Error for action %s" action;
          Log.exn "%s\n" e;
          
  );
  ()
@

<<toplevel Makefile_mode._4>>=
let _ = 
  (* Keymap.add_prefix mode.maj_map [c_c];   *)
  Hook.add_start_hook (fun () ->
    let alist = Var.get_global Ebuffer.modes_alist in
    Var.set_global Ebuffer.modes_alist ((".*/[Mm]akefile.*",mode):: alist);
    
    Parameter.add_option_parameter target_color;
    Parameter.add_option_parameter rules_color;
  )   
@


%-------------------------------------------------------------

<<prog_modes/makefile_mode.ml>>=
<<copyright header2>>
open Options
open Efuns

<<constant Makefile_mode.mkfile_vars>>
<<constant Makefile_mode.mkfile_target>>
<<constant Makefile_mode.mkfile_rules>>

let mkfile_comments= Str.regexp "^#.*$"

<<constant Makefile_mode.rules_color>>
<<constant Makefile_mode.target_color>>
<<constant Makefile_mode.vars_color>>
<<function Makefile_mode.makefile_color>>
 
<<constant Makefile_mode.c_c>>

<<function Makefile_mode.install>>
  
<<constant Makefile_mode.mode>>
  

<<constant Makefile_mode.local_map>>

<<constant Makefile_mode.interactives_map>>

(* let insert_tab frame = ignore (insert_string frame "\t") *)
 
<<toplevel Makefile_mode._1>>

<<function Makefile_mode.makefile_mode>>
        
<<toplevel Makefile_mode._2>>

<<toplevel Makefile_mode._3>>

  
<<toplevel Makefile_mode._4>>
@
%$


\subsection*{[[prog_modes/ocaml_toplevel.ml]]}

<<function Ocaml_toplevel.type_buffer>>=
let type_buffer buf =
  let text = buf.buf_text in
  let start_point = Text.new_point text in
  let end_point = Text.new_point text in
  set_position text end_point (size text);
  let lexbuf = lexing text start_point end_point in
  try  
    let (str, env) = Type.type_buffer buf.buf_name lexbuf !!ocaml_path in
    remove_point text start_point;
    remove_point text end_point;
    (str,env)
  with x ->
      remove_point text start_point;
      remove_point text end_point;
      raise x
@

<<constant Ocaml_toplevel.compiled_idents>>=
let compiled_idents = Local.create_abstr "compiled_idents"
@

<<function Ocaml_toplevel.all_idents>>=
let all_idents buf =
  try
    let (ids, version) = Local.get buf.buf_vars compiled_idents in
    if Text.version buf.buf_text = version then ids else raise Not_found
  with
    _ -> 
      let _, (str,env) = Utils.do_and_format type_buffer buf in
      let ids = Type.iter_structure str [] GlobalDefined in
      set_local buf compiled_idents (ids, Text.version buf.buf_text);
      ids      
@

<<function Ocaml_toplevel.find_value_type>>=
let find_value_type sign names =
  let rec solv sign names =
    match names with
      [] -> raise Not_found
    | name :: names ->
        let rec find sign =
          match sign with
            [] -> raise Not_found
          | sg :: sign ->
              match sg with
                Tsig_value (ident,vd) 
                when Ident.name ident = name ->
                  vd.val_type
              | Tsig_module (ident,Tmty_signature sign ) 
                when Ident.name ident = name ->
                  solv sign names
              | _ -> find sign
        in
        find sign
  in
  solv sign names
@

<<function Ocaml_toplevel.print_type>>=
let print_type frame = 
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  let top_window = Window.top frame.frm_window in
  try
    let ids = all_idents buf in
    let text = buf.buf_text in
    let pos = get_position text point in
    List.iter (fun (p,l,t,w) ->
        if l.loc_start-1 <= pos && l.loc_end+1 >= pos then
          Top_window.message top_window 
            (Utils.format_to_string 
              (fun () -> 
                printtyp_path p;
                Format.print_string " : ";
                printtyp_type_expr t
            ) ())
    ) ids
  with
    _ ->
  let name = find_long_word buf point in
  let names = parse_name name in
  let test_name modname names =
    try    
      let ps = Ocaml_env.find_pers_struct !!ocaml_path modname in
      let typ = find_value_type ps.ps_sig names in
      let styp = format_to_string () in
      Format.print_string modname;
      let rec iter list =
        match list with
          [] -> ()
        | name :: tail -> 
            Format.print_string ".";
            Format.print_string name;
            iter tail
      in
      iter names;
      Format.print_string ": ";
      printtyp_type_expr typ;
      Format.print_flush ();
      Top_window.message top_window !styp    
    with
      Env.Error e ->
        let m,s1,s2,s3 =
          match e with    
            Not_an_interface s -> "Not_an_interface",s,"",""
          | Corrupted_interface s -> "Corrupted_interface",s,"",""
          | Illegal_renaming (s1 , s2) ->
              "Illegal_renaming",s1,s2,"" 
          | Inconsistent_import (s1,s2,s3) ->
              "Inconsistent_import",s1,s2,s3
        in
        Top_window.message top_window 
          (Printf.sprintf "Env error: %s %s %s %s" m s1 s2 s3)
  in
  try
    match names with
      modname :: names when modname = String.capitalize modname -> 
        test_name modname names
    | _ -> raise Not_found
  with
    Not_found ->
      let rec iter env =
        match env with
          [] -> failwith "Can not find type"
        | modname :: env ->
            try
              test_name modname names
            with
              Not_found -> iter env
      in
      iter (find_env buf point)
@

<<constant Ocaml_toplevel.back_list>>=
let back_list = ref []
@

<<function Ocaml_toplevel.find_implementation>>=
let find_implementation frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let word = find_long_word buf point in
  let ids = all_idents buf in
  let pos = get_position text point in
  try
    List.iter (fun (pp,l,t,w) ->
        if l.loc_start-1 <= pos && l.loc_end+1 >= pos then
          begin
            List.iter (fun (p,l,t,w) ->
                if p = pp && (w <> Type.Used)then
                  (Text.set_position text frame.frm_point l.loc_start;
                    raise Exit)
            ) ids;  
            match pp with
              Path.Pdot (Path.Pident id,name,pos) when Ident.persistent id ->
              (* Look in another file ... *)
                let ident = Ident.name id in
                let file = ident ^ ".ml" in
                file.[0] <- Char.lowercase file.[0];
                let filename = 
                  try
                    Utils.find_in_path !!ocaml_path file
                  with _ -> failwith (Printf.sprintf "No %s in path" file)
                in 
                let buf = Ebuffer.read filename (Keymap.create ()) in
                let text = buf.buf_text in
                let frame = try
                    Frame.find_buffer_frame buf
                  with Not_found ->
                      Frame.create frame.frm_window None buf
                in
                Frame.active frame;
                let ids = all_idents buf in
                List.iter (fun (p,l,t,w) ->
                    match p with
                      Path.Pident id ->
                        if Ident.name id = name && w = Type.GlobalDefined then
                          (Text.set_position text frame.frm_point l.loc_start;
                            raise Exit)
                    | _ -> ()
                ) ids;
            | _  -> ()
          end
    
    ) ids;
  with
    Exit -> 
      let filename = 
        match buf.buf_filename with
          None -> buf.buf_name
        | Some filename -> filename
      in
      back_list := (filename,Text.get_position text point) :: !back_list
@

<<function Ocaml_toplevel.backward_implementation>>=
let rec backward_implementation frame =
  match !back_list with
    [] -> failwith "No more buffers in history"
  | (filename, pos) :: tail ->
      back_list := tail;
      let buf = Ebuffer.read filename (Keymap.create ()) in
      let frame = Frame.create frame.frm_window None buf in
      Frame.active frame
@

<<function Ocaml_toplevel.mouse_find_implementation>>=
let mouse_find_implementation frame =
  let frame = Top_window.mouse_set_active (Window.top frame.frm_window) in
  find_implementation frame
@

<<constant Ocaml_toplevel.mode>>=
let mode = Ebuffer.new_minor_mode "compiler" []
@

<<constant Ocaml_toplevel.local_map>>=
let local_map = define_option ["ocaml_compiler_mode"; "local_map"] ""
    (list_option binding_option) []
@

<<toplevel Ocaml_toplevel._1>>=
let _ = 
  if !!local_map = [] then 
    local_map =:= [
      [c_c; ControlMap, Char.code 'i'] , "ocaml_mode.find_implementation";
      [c_c; ControlMap, XK.xk_BackSpace], "ocaml_mode.backward_implementation";
      [c_c; ControlMap, Char.code 't'], "ocaml_mode.print_type";
    ];
  Keymap.add_binding mode.min_map [ControlMap, XK.xk_Pointer_Button1]
    mouse_find_implementation
@

<<toplevel Ocaml_toplevel._2>>=
let _ = 
  define_buffer_action "ocaml_compiler_mode" 
    (fun buf -> 
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode);
  define_action "ocaml_compiler_mode.find_implementation" find_implementation;
  define_action "ocaml_compiler_mode.backward_implementation" backward_implementation;
  define_action "ocaml_compiler_mode.print_type" print_type;
@


%-------------------------------------------------------------

<<prog_modes/ocaml_toplevel.ml>>=
<<copyright header efuns>>
open Ocaml_mode
open Options
open Text
open Efuns
open Interactive
open Simple
open Select
open Compil
open Eval
open Complex
open Abbrevs  
open Env
open Types
open Keymap
open Window
open Location
open Compat_comp
open Type
open Ocaml_env
  
<<function Ocaml_toplevel.type_buffer>>

<<constant Ocaml_toplevel.compiled_idents>>

<<function Ocaml_toplevel.all_idents>>

<<function Ocaml_toplevel.find_value_type>>
    
<<function Ocaml_toplevel.print_type>>

<<constant Ocaml_toplevel.back_list>>
          
<<function Ocaml_toplevel.find_implementation>>

<<function Ocaml_toplevel.backward_implementation>>
      
<<function Ocaml_toplevel.mouse_find_implementation>>
  
  

<<constant Ocaml_toplevel.mode>>

<<constant Ocaml_toplevel.local_map>>
<<toplevel Ocaml_toplevel._1>>

<<toplevel Ocaml_toplevel._2>>

@

\section{[[ipc/]]}

\subsection*{[[ipc/server.ml]]}

<<constant Server.efuns_property>>=
let efuns_property = "_EFUNS_SERVER"  
@

<<constant Server.user>>=
let user = 
  try Sys.getenv "USER" 
  with _ -> "noname"
@

<<constant Server.socket_name>>=
let socket_name = (Printf.sprintf "/tmp/efuns-server.%s.%s:0" user !displayname)
@

<<constant Server.started>>=
let started = ref false
@

<<type Server.proto>>=
type proto =
  LoadFile of string * int * string
@

<<function Server.read_command>>=
let read_command fd frame =
  let inc = in_channel_of_descr fd in
  try
    let cmd = input_value inc in
    match cmd with
    | LoadFile (name,pos,str) ->
        let window = frame.frm_window in
        let top_window = Window.top window in
        wrap top_window (fun top_window ->
            let frame = Frame.load_file window name in
            if pos <> 0 then
              let buf = frame.frm_buffer in
              let text = buf.buf_text in
              let point = frame.frm_point in
              try
                if str = "" then raise Not_found else                  
                let regexp = Str.regexp_string str in
                let len = Text.search_forward text regexp point in
                ()
              with
                Not_found -> 
                  Text.set_position text point pos
        ) ()
  with
    _ -> Concur.Thread.remove_reader fd 
@

<<function Server.module_accept>>=
let module_accept s frame = 
  let fd,_ = accept s in
  Unix.set_close_on_exec fd;
  Concur.Thread.add_reader fd (fun _ -> read_command fd frame)
@

<<function Server.start>>=
let start frame =
  if not !started then
  let top_window = Window.top frame.frm_window in
  Utils.catchexn "Efuns server:" (fun _ ->
      let s = Unix.socket PF_UNIX SOCK_STREAM 0 in
      if Sys.file_exists socket_name then Unix.unlink socket_name;
      Unix.bind s (ADDR_UNIX socket_name);
      Unix.listen s 254;
      Unix.set_nonblock s;
      Unix.set_close_on_exec s;
      let display = top_window.top_root#display  in
        Concur.Thread.add_reader s (fun _ -> 
            started := true;
            module_accept s frame);
      let atom = X.internAtom display efuns_property false in
      X.changeProperty display top_window.top_root#window 
        PropModeReplace atom XA.xa_string 1 socket_name;
  )  
@
% todo: no M-x server-start?

%-------------------------------------------------------------

<<ipc/server.ml>>=
<<copyright header>>
open Efuns
open Xtypes
open Unix  
open Top_window
  
<<constant Server.efuns_property>>
<<constant Server.user>>
<<constant Server.socket_name>>

<<constant Server.started>>
  
<<type Server.proto>>
  
<<function Server.read_command>>
  
<<function Server.module_accept>>
  
<<function Server.start>>
  

@


\subsection*{[[ipc/efuns_client.ml]]}

<<constant Efuns_client.pos>>=
let pos = ref 0
@

<<constant Efuns_client.string>>=
let string = ref ""
@

<<constant Efuns_client.filename>>=
let filename = ref None
@

<<toplevel Efuns_client._1>>=
let _ = Arg.parse [
    "-pos", Arg.Int (fun i -> pos := i)," <int>: set position";
    "-str", Arg.String (fun s -> string := s)," <string>: search string";
  ] (fun name -> filename := Some name)
  "efuns_server: connect to efuns"
@

<<constant Efuns_client.pos (client/efuns_client.ml)>>=
let pos = !pos    
@

<<constant Efuns_client.filename (client/efuns_client.ml)>>=
let filename = match !filename with
    None -> failwith "efuns_server: filename missing"
  | Some s -> s
@

<<constant Efuns_client.string (client/efuns_client.ml)>>=
let string = !string
@

<<constant Efuns_client.filename (client/efuns_client.ml)2>>=
let filename = if is_relative filename then 
    concat (getcwd ()) filename else filename
@

<<constant Efuns_client.efuns_property>>=
let efuns_property = "_EFUNS_SERVER"  
@

<<constant Efuns_client.display>>=
let display = Xlib.openDisplay ""
@

<<constant Efuns_client.root>>=
let root = display.dpy_roots.(0).scr_root
@

<<constant Efuns_client.atom>>=
let atom = X.internAtom display efuns_property false
@

<<constant Efuns_client.socket_name>>=
let socket_name = (Xlib.getWholeProperty display root atom).gp_value
@

<<toplevel Efuns_client._2>>=
let _ =  if not (Sys.file_exists socket_name) then raise Not_found
@

<<toplevel Efuns_client._3>>=
let (inc,outc) = open_connection (ADDR_UNIX socket_name)
let _ =  
  output_value outc (LoadFile (filename,pos,string)); 
  flush outc
@


%-------------------------------------------------------------

<<ipc/efuns_client.ml>>=
open Server  
open Xtypes
open Unix
open Sys
open Filename
  
<<constant Efuns_client.pos>>
<<constant Efuns_client.string>>
<<constant Efuns_client.filename>>
  
<<toplevel Efuns_client._1>>
  
<<constant Efuns_client.pos (client/efuns_client.ml)>>
<<constant Efuns_client.filename (client/efuns_client.ml)>>
<<constant Efuns_client.string (client/efuns_client.ml)>>
    
<<constant Efuns_client.filename (client/efuns_client.ml)2>>
    
<<constant Efuns_client.efuns_property>>

<<constant Efuns_client.display>>
<<constant Efuns_client.root>>
<<constant Efuns_client.atom>>
<<constant Efuns_client.socket_name>>
<<toplevel Efuns_client._2>>
<<toplevel Efuns_client._3>>
  
@


\subsection*{[[misc/efuns_filebrowser.ml]]}

<<constant Efuns_filebrowser.argv>>=
let argv = Array.to_list Sys.argv
@

<<constant Efuns_filebrowser.regexps>>=
let regexps = List.map (fun str -> str, 
      Str.regexp (Utils.glob_to_regexp str)) (
    match argv with
      program :: dirname :: strs -> strs
    | _ -> failwith "Usage: efuns_filebrowser dirname [regexps]")
@

<<constant Efuns_filebrowser.dirname>>=
let dirname = ref (if Filename.is_relative Sys.argv.(1) then
      Filename.concat (Sys.getcwd ()) Sys.argv.(1) else Sys.argv.(1))
@

<<constant Efuns_filebrowser.display>>=
let display = new WX_display.t ""
@

<<constant Efuns_filebrowser.root>>=
let root = new WX_root.t display 0
@

<<constant Efuns_filebrowser.top>>=
let top = new WX_appli.t root [MinWidth 10; MinHeight 10; MaxHeight (root#height - 200)]
@

<<constant Efuns_filebrowser.adx>>=
let adx = new WX_adjust.t ()
@

<<constant Efuns_filebrowser.ady>>=
let ady = new WX_adjust.t ()
@

<<constant Efuns_filebrowser.hbar>>=
let hbar = new WX_bar.h top#container []
@

<<constant Efuns_filebrowser.viewport>>=
let viewport = new WX_viewport.t hbar#container adx ady []
@

<<constant Efuns_filebrowser.scrollbar>>=
let scrollbar = new WX_scrollbar.v hbar#container ady []
@

<<constant Efuns_filebrowser.tree>>=
let tree = new WX_tree.t viewport#container []
@

<<function Efuns_filebrowser.load>>=
let load filename =
  Sys.command(Printf.sprintf "efuns_server %s &" filename) |> ignore
@

<<function Efuns_filebrowser.iter_load>>=
let rec iter_load closed dirname basename container =
  try
    let dirname = Filename.concat dirname basename in
    let filenames = Sort.list (<=) (Utils.list_dir dirname) in
    let subdirs = List.fold_left (fun files filename ->
          if filename <> "." && filename <> ".." then
            let fullname = Filename.concat dirname filename in
            let stats = lstat fullname in
            if stats.st_kind = S_DIR then filename::files else
              files
          else files
      ) [] filenames in
    let file_lists = List.fold_left (fun lists (name,regexp) ->
          let newlist = List.rev (List.fold_left (fun files filename ->
                if Str.string_match regexp filename 0 then filename :: files
                else files
              ) [] filenames) in
          let rec iter pos newlist addlist lists =
            match newlist with
            | ele :: tail -> 
                if pos mod 15 = 0 then
                  iter 1 tail [] (((
                        Printf.sprintf "%s[to %s]" name ele), (ele::addlist)) :: lists)
                else
                  iter (pos+1) tail (ele::addlist) lists
            |   [] -> match addlist with [] -> lists | _ -> 
                    (name,addlist) :: lists
          in
          let newlists = iter 1 newlist [] [] in
          match newlists with
            [] -> lists
          | _ -> (List.rev newlists) @ lists
      ) [] regexps in
    (List.map (fun subdir ->
          let label = new WX_label.t container subdir [] in
          let tree  = new WX_tree.t container [] in
          tree#set_desc (iter_load true dirname subdir tree#container);
          branch true label#contained tree#contained
      ) subdirs) @ (
      List.map (fun (name,files) -> 
          let label = new WX_label.t container name [] in
          let tree  = new WX_tree.t container [] in
          tree#set_desc (List.map (fun filename ->
                let label = new WX_button.with_label tree#container filename 
                  [IpadX 0; IpadY 0] 
                  in
                label#set_action (fun () -> 
                    load (Filename.concat dirname filename));                
                leaf 0 label#contained
            ) (List.rev files));
            branch true label#contained tree#contained         
      ) file_lists
    )
  with
    _ -> []
@

<<constant Efuns_filebrowser.file_menu>>=
let file_menu = [|
    "Open", (fun _ -> 
        let info = {
            filter = Filename.concat !dirname  "*";
            current_selection= !dirname;
            predicat = (fun _ -> true);
            action = (fun s -> 
                tree#destroy_desc;
                dirname := s;
                tree#set_desc (
                  iter_load false (Filename.dirname s) (Filename.basename s)
                  tree#container));
            cancel = (fun _ -> ());
          }    in
        let filesel = new WX_filesel.t root info [] in
        filesel#show
        );
    "Quit", (fun _ -> exit 0);
  |]
@

<<toplevel Efuns_filebrowser._1>>=
let _ =
  tree#set_desc (iter_load false (Filename.dirname Sys.argv.(1))
    (Filename.basename Sys.argv.(1))
    tree#container);
  top#container_add hbar#contained;
  hbar#container_add_s [viewport#contained; scrollbar#contained];
  viewport#container_add tree#contained;
  top#setWM_NAME (Printf.sprintf "File Browser: %s" Sys.argv.(1));
  top#add_menu "File" file_menu;
  top#show;
  loop ()
@


%-------------------------------------------------------------

<<misc/efuns_filebrowser.ml>>=
<<copyright header>>
open Xtypes
open WX_types
open WX_tree
open Unix

<<constant Efuns_filebrowser.argv>>
<<constant Efuns_filebrowser.regexps>>

<<constant Efuns_filebrowser.dirname>>
  
<<constant Efuns_filebrowser.display>>
<<constant Efuns_filebrowser.root>>
<<constant Efuns_filebrowser.top>>
<<constant Efuns_filebrowser.adx>>
<<constant Efuns_filebrowser.ady>>
<<constant Efuns_filebrowser.hbar>>
<<constant Efuns_filebrowser.viewport>>
<<constant Efuns_filebrowser.scrollbar>>
<<constant Efuns_filebrowser.tree>>

<<function Efuns_filebrowser.load>>

<<function Efuns_filebrowser.iter_load>>

open WX_filesel
  
<<constant Efuns_filebrowser.file_menu>>
  
<<toplevel Efuns_filebrowser._1>>
@


\subsection*{[[misc/efuns_texbrowser.ml]]}

% outline better?

<<constant Efuns_texbrowser.display>>=
let display = new WX_display.t ""
@

<<constant Efuns_texbrowser.root>>=
let root = new WX_root.t display 0
@

<<constant Efuns_texbrowser.top>>=
let top = new WX_appli.t root [MinWidth 10; MinHeight 10]
@

<<constant Efuns_texbrowser.tree>>=
let tree = new WX_tree.t top#container []
@

<<constant Efuns_texbrowser.regexp>>=
let regexp = Str.regexp "\\(\\input\\|\\section\\|\\subsection\\|\\subsubsection\\|\\chapter\\)[*]?{\\([^}]+\\)}"
@

<<function Efuns_texbrowser.load>>=
let load filename pos all =
  Sys.command (spf "efuns_server %s -pos %d -str \"%s\" &" filename pos all)
   |> ignore
@

<<constant Efuns_texbrowser.filename>>=
let filename = ref 
  (if Array.length Sys.argv = 2 
   then Sys.argv.(1) 
   else failwith "Usage: efuns_texbrowser filename"
  )
@

<<constant Efuns_texbrowser.dirname>>=
let dirname = ref (Filename.dirname !filename)
@

<<constant Efuns_texbrowser.path>>=
let path = ref [ !dirname ]
@

<<function Efuns_texbrowser.iter_load>>=
let rec iter_load closed filename container =
  let label = new WX_button.with_label container filename [] in
  try
    let filename = try
        Utils.find_in_path !path filename
      with Not_found -> 
          Utils.find_in_path !path (filename^".tex")
    in
    label#set_action (fun () -> load filename 0 "");
    let inc = open_in filename in
    let s = Utils.read_string inc in
    close_in inc;
    let rec iter_search pos list = 
      try
        let newpos = Str.search_forward regexp s pos in
        let keyword = Str.matched_group 1 s in
        let all = Str.matched_group 0 s in
        iter_search (newpos+String.length keyword) (
          (all, keyword,Str.matched_group 2 s,newpos)::list)
      with
        _ -> List.rev list
    in
    let list =  iter_search 0 [] in
    if list = [] then leaf 0 label#contained else
    let tree2 = new WX_tree.t container [] in
    tree2#set_desc (List.map (
        fun (all,keyword,name,pos) -> 
          match keyword with
            "input" -> iter_load true name tree2#container
          | _ ->
              let (offset,prefix) =
                match keyword with
                  "section" -> 0, "s:"
                | "subsection" -> 10, "ss:"
                | "subsubsection" -> 20, "sss:"
                | _ -> 30,""
              in
              leaf offset (
                  let button = new WX_button.with_label tree2#container (
                      prefix^name) [] 
                  in
                  button#set_action (fun () -> load filename pos all);
                  button#contained
                  )
      ) list);
    branch closed label#contained tree2#contained
  with
    _ -> 
      leaf 0 label#contained
@

<<constant Efuns_texbrowser.file_menu>>=
let file_menu = [|
    "Open", (fun _ -> 
        let info = {
            filter = Filename.concat !dirname  "*.tex";
            current_selection= !dirname;
            predicat = (fun _ -> true);
            action = (fun s -> 
                tree#destroy_desc;
                filename := s;
                dirname := Filename.dirname s;
                top#setWM_NAME (Printf.sprintf "LaTeX Browser: %s" !filename);
                tree#set_desc [iter_load false s tree#container]);
            cancel = (fun _ -> ());
          }    in
        let filesel = new WX_filesel.t root info [] in
        filesel#show              
        );
    "Quit", (fun _ -> exit 0);
  |]
@

<<toplevel Efuns_texbrowser._1>>=
let _ =
  tree#set_desc [iter_load false Sys.argv.(1) tree#container];
  top#setWM_NAME (Printf.sprintf "LaTeX Browser: %s" !filename);
  top#container_add tree#contained;
  top#add_menu "File" file_menu;
  top#add_button "Reload" (fun _ () ->
      tree#destroy_desc;
      tree#set_desc [iter_load false !filename tree#container];      
  );
  top#add_separator;
  top#show;
  loop ()
@


%-------------------------------------------------------------

<<misc/efuns_texbrowser.ml>>=
<<copyright header>>
open Xtypes
open WX_types
open WX_tree


<<constant Efuns_texbrowser.display>>
<<constant Efuns_texbrowser.root>>
<<constant Efuns_texbrowser.top>>
<<constant Efuns_texbrowser.tree>>

<<constant Efuns_texbrowser.regexp>>

<<function Efuns_texbrowser.load>>

<<constant Efuns_texbrowser.filename>>
  
<<constant Efuns_texbrowser.dirname>>
<<constant Efuns_texbrowser.path>>
  
<<function Efuns_texbrowser.iter_load>>

open WX_filesel
  
<<constant Efuns_texbrowser.file_menu>>

<<toplevel Efuns_texbrowser._1>>
@

\section{[[dynamic/]]}

\subsection*{[[dynamic/eval.ml]]}

<<function Eval.try_load>>=
let try_load top_window f =
  try
    f (); 
    Efuns.init top_window.top_location
  with
  | Dynlink.Error error ->
      Top_window.message top_window (Dynlink.error_message error)
  | e -> 
      Top_window.message top_window (spf "Exception %s" (Printexc.to_string e))
@

<<function Eval.load>>=
let load top_window mod_name =
  try_load top_window (fun () -> load_module mod_name)
@

<<function Eval.load_library>>=
let load_library frame =
  select_lib_filename frame "Load library: " 
    (fun str ->
      let top_window = Window.top frame.frm_window in
      try_load top_window (fun () -> load_file str))
@

<<function Eval.eval_buffer>>=
let eval_buffer frame =
  let top_window = Window.top frame.frm_window in
  let location = top_window.top_location in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let filename = Filename.temp_file "buffer" ".ml" in
  let outc = open_out filename in
  Text.save buf.buf_text outc;
  close_out outc;
  let cmd = "ocamlc -c -I " ^ Version.efuns_lib ^ " " ^ filename in 
  let end_action buf status =
    match status with
      0 -> try_load top_window 
          (fun _ -> 
            let fl =  ((Filename.chop_suffix filename ".ml") ^ ".cmo") 
            in 
            load_file fl;
            Efuns.init top_window.top_location)
    | _ -> 
        set_compilation_buffer frame buf (Filename.dirname filename);
        Top_window.message top_window "Error while compiling buffer"
  in
  System.system "*Eval*" location cmd end_action |> ignore
@


%-------------------------------------------------------------

<<dynamic/eval.ml>>=
<<copyright header2>>

open Efuns
open Text
open Frame
open Simple
open Select
open Search
open Compil

(*
let rec load_module mod_name =
  let filename = (String.uncapitalize mod_name) ^ ".cmo" in
  try
    let filename = Utils.find_in_path !Efuns.load_path filename in
    load_file filename
  with
    Not_found -> failwith ("Can't find file "^filename)

and load_file filename =
  try
    Dynlink.loadfile filename
  with
    Dynlink.Error (Dynlink.Unavailable_unit mod_name) -> 
      load_interface mod_name;
      load_file filename
  | Dynlink.Error (
    Dynlink.Linking_error (_, Dynlink.Undefined_global mod_name)) ->
      load_module mod_name;
      load_file filename

and load_interface mod_name =
  try
    Dynlink.add_interfaces [mod_name] !Efuns.load_path; ()
  with
    Not_found ->
      failwith (Printf.sprintf "No interface for %s" mod_name)
      *)

open Dyneval

<<function Eval.try_load>>

<<function Eval.load>>

<<function Eval.load_library>>

  
<<function Eval.eval_buffer>>
@
