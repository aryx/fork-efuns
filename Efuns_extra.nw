\section{[[commons2/]]}

\subsection*{[[commons2/local.ml]]}

<<type Local.var>>=
type 'a var = string
@
% phantom type!

<<global Local.vars_table>>=
let (vars_table :
    (string, (Obj.t -> string) * (string -> Obj.t)) Hashtbl.t)
  = Hashtbl.create 203
@

<<type Local.vars>>=
type vars = Obj.t ref Vars.t ref
@

<<function Local.vars>>=
let vars () = ref Vars.empty
@

<<function Local.create>>=
let create name print input =
  try
    let _ = Hashtbl.find vars_table name in
    failwith (Printf.sprintf "A variable named %s already exists" name)
  with
    Not_found ->
      Hashtbl.add vars_table name (magic print,magic input);
      name
@

<<function Local.no_print>>=
let no_print _ = "<abstr>"
@

<<function Local.no_input>>=
let no_input (s : string) = failwith "This variable can not be set"
@


<<function Local.create_abstr>>=
let create_abstr name = create name no_print no_input
@

<<function Local.create_string>>=
let create_string name = create name id id
@

<<function Local.create_int>>=
let create_int name = create name string_of_int int_of_string
@

<<function Local.create_float>>=
let create_float name = create name string_of_float float_of_string
@



<<function Local.get>>=
let get vars var =  Obj.magic !(Vars.find var !vars)
@

<<function Local.set>>=
let set vars var value =
  let value = repr value in
  try
    let r = Vars.find var !vars in
    r := value
  with
    Not_found -> 
      vars := Vars.add var (ref value) !vars
@

<<function Local.get_print>>=
let get_print vars var =
  let value = get vars var in
  let (p,i) = Hashtbl.find vars_table var in
  p value  
@

<<function Local.set_input>>=
let set_input vars var value =
  let (p,i) = Hashtbl.find vars_table var in
  set vars var (i value)
@

<<function Local.list>>=
let list vars =
  let list = ref [] in
  Vars.iter (fun var value ->
      list := var :: !list;
  ) !vars;
  !list
@

<<constant Local.print>>=
let print = get_print
@

<<constant Local.input>>=
let input = set_input
@


%-------------------------------------------------------------

<<commons2/local.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                             ____________                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

(* We use strings instead of ints to enable migration of datas between
editors (data must be symbolic) *)

open Obj
  
<<type Local.var>>

module Vars = Map.Make (struct  
      type t = string
      let compare = compare end)

<<type Local.vars>>
<<function Local.vars>>

<<global Local.vars_table>>

<<function Local.create>>

<<function Local.no_print>>
<<function Local.no_input>>
<<function Local.create_abstr>>
  
external id : 'a -> 'a = "%identity"

<<function Local.create_string>>
<<function Local.create_int>>
<<function Local.create_float>>
  
<<function Local.get>>
<<function Local.set>>
      
<<function Local.get_print>>
  
<<function Local.set_input>>
  
<<function Local.list>>
  
<<constant Local.print>>
<<constant Local.input>>
@


\section{[[core/]]}

\subsection*{[[core/efuns.ml]]}


%-------------------------------------------------------------

<<core/efuns.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

(* Useful types for Efuns *)

(*************************************************************************)
               (*      Types      *)
(*************************************************************************)

open Utils
open Local
  
<<exception Efuns.UnboundKey>>

<<type Efuns.map>>
<<type Efuns.keySym>>
<<type Efuns.key>>

<<type Efuns.action>>

<<type Efuns.generic_action>>

<<type Efuns.mod_ident>>

<<type Efuns.prefix>>

<<type Efuns.binding>>

<<type Efuns.buffer>>

<<type Efuns.major_mode>>

<<type Efuns.minor_mode>>
  
<<type Efuns.frame>>

<<type Efuns.status_info>>

<<type Efuns.status>>

<<type Efuns.line_repr>>

<<type Efuns.top_window>>

<<type Efuns.window>>

<<type Efuns.window_up>>

<<type Efuns.window_down>>

<<type Efuns.location>>

<<type Efuns.sens>>
<<type Efuns.to_regexp>>

(*************************************************************************)
               (*      Values      *)
(*************************************************************************)

<<constant Efuns.start_hooks>>
<<function Efuns.add_start_hook>>

<<function Efuns.init>>

  (* Les variables locales *)
  
<<function Efuns.set_global>>
<<function Efuns.set_local>>
<<function Efuns.get_var>>
          
<<function Efuns.get_global>>
<<function Efuns.get_local>>
  
<<function Efuns.set_minor_var>>
<<function Efuns.set_major_var>>
  
<<function Efuns.exec_hooks>>

<<function Efuns.add_hook>>
  
(*************************************************************************)
               (*      Initialization      *)
(*************************************************************************)
  
(* Les variables importantes dans le reste du programme. *)
open Options
  
<<constant Efuns.load_path>>

<<constant Efuns.path>>
  
<<constant Efuns.efuns_path>>
  
<<toplevel Efuns._1>>

<<constant Efuns.init_files>>
<<constant Efuns.init_frames>>
<<constant Efuns.displayname>>
<<constant Efuns.no_init>>
  
(*--------------------    Ressources *)
<<constant Efuns.xdefaults>>

<<constant Efuns.x_res>>
<<toplevel Efuns._2>>
  
<<constant Efuns.t>>
  (*
  let _ = Printf.printf "%d %d %s %s %s" !width !height !font !fg !bg; 
  print_newline () 
*)
  
(*--------------------    Arguments *)
<<constant Efuns.width_opt>>
<<constant Efuns.height_opt>>
<<constant Efuns.font_opt>>
<<constant Efuns.fg_opt>>
<<constant Efuns.bg_opt>>
<<constant Efuns.check>>
  
<<toplevel Efuns._3>>
<<toplevel Efuns._4>>

open Options
  
<<constant Efuns.width>>
<<constant Efuns.height (core/efuns.ml)>>
<<constant Efuns.font>>
<<constant Efuns.foreground>>
<<constant Efuns.background>>
  
<<toplevel Efuns._5>>

<<global Efuns.actions>>

<<function Efuns.define_action>>

<<function Efuns.define_buffer_action>>

<<function Efuns.get_action>>

<<function Efuns.execute_action>>

<<function Efuns.execute_buffer_action>>
      
<<function Efuns.string_to_regex>>
    
<<constant Efuns.regexp_option>>
@


\subsection*{[[core/text.ml]]}

<<function Text.point_col>>=
let point_col tree point = 
  let text = tree.tree_text in    
  let gpoint = text.text_gpoint in
  let bol = text.text_newlines.(point.point_y).position in
  let point = point.point in
  if point > gpoint && bol <= gpoint then
    point - bol - text.text_gsize
  else
    point - bol
@



<<function Text.move_gpoint_to>>=
let move_gpoint_to text point =
  let gpoint = text.text_gpoint in
  let gsize = text.text_gsize in
  let gline = text.text_gline in
  text.text_clean <- false;
  if point <> gpoint then 
    let gap_end = gpoint + gsize in
    if point < gpoint then
      let delta = gpoint - point in
      let (delta_line,_) = count_char_sub text.text_string
          point delta '\n' in
      String.blit text.text_string point 
        text.text_string (point + gsize) delta;
      Array.blit text.text_attrs point 
        text.text_attrs (point + gsize) delta;
      for i = gline - delta_line + 1 to gline do
        text.text_newlines.(i).position
          <- text.text_newlines.(i).position + gsize 
      done;
      List.iter (fun p -> 
          if p.point > point && p.point <= gpoint then
            p.point <- p.point + gsize
      ) text.text_points;
      text.text_gpoint <- point;
      text.text_gline <- gline - delta_line;
    else
    let delta = point - gap_end in
    let (delta_line,_) = 
      count_char_sub text.text_string gap_end delta '\n' in
    String.blit text.text_string gap_end text.text_string gpoint delta;
    Array.blit text.text_attrs gap_end text.text_attrs gpoint delta;
    for i = gline + 1 to gline + delta_line do
      text.text_newlines.(i).position
        <- text.text_newlines.(i).position - gsize
    done;
    List.iter (fun p -> 
        if p.point >= gap_end && p.point <= point then
          p.point <- p.point - gsize
    ) text.text_points;
    text.text_gpoint <- point - gsize;
    text.text_gline <- gline + delta_line
@

<<function Text.cancel_repr>>=
let cancel_repr text point n =
  let line = text.text_newlines.(n) in
  let pos =  point - line.position in
  line.modified <- 
    (if line.modified < 0 then pos
    else min line.modified pos)
@

<<constant Text.add_amount>>=
let add_amount = define_option ["add_amount"] "Size of the gap in the buffer"
  int_option 200
@

<<function Text.extend_gap>>=
let extend_gap text amount =
  let add_size = max !!add_amount 
      ((amount / !!add_amount) * !!add_amount + !!add_amount) in
  let old_size = text.text_size in
(* use String.create here *)
  let new_text = String.create (old_size + add_size) in
  let new_attrs = Array.create (old_size + add_size) direct_attr in
  let gpoint = text.text_gpoint in
  let gsize = text.text_gsize in
  let gap_end = gpoint + gsize in
  String.blit text.text_string 0 new_text 0 gpoint; 
  Array.blit text.text_attrs 0 new_attrs 0 gpoint; 
  String.blit text.text_string gap_end
    new_text (gap_end + add_size) 
  (old_size - gap_end);
  Array.blit text.text_attrs gap_end
    new_attrs (gap_end + add_size) 
  (old_size - gap_end);
  for i = text.text_gline + 1 to text.text_nlines - 1 do
    text.text_newlines.(i).position <- 
      text.text_newlines.(i).position + add_size
  done;
  List.iter (fun p -> 
      if p.point > gpoint then
        p.point <- p.point + add_size
  ) text.text_points;
  text.text_gsize <- gsize + add_size;
  text.text_size <- old_size + add_size;
  text.text_string <- new_text;
  text.text_attrs <- new_attrs
@

<<exception Text.ReadOnlyBuffer>>=
exception ReadOnlyBuffer
@

<<function Text.tree_insert>>=
let tree_insert tree t gline nbr = ()
@

<<function Text.low_insert>>=
let low_insert tree point str =
  let text = tree.tree_text in
  <<[[Text.low_insert()]] fail if readonly buffer>>
  move_gpoint_to text point;
  let gpoint = text.text_gpoint in
  let gsize = text.text_gsize in
  let gline = text.text_gline in
  (*let gchars = gpoint - text.text_newlines.(gline).position in*)
  cancel_repr text gpoint gline;
  let strlen = String.length str in
  if strlen > gsize then extend_gap text strlen;
  let gsize = text.text_gsize in
  String.blit str 0 text.text_string gpoint strlen;
  Array.fill text.text_attrs gpoint strlen direct_attr;
  let (nbr_newlines,nbr_chars) = count_char str '\n' in
  if nbr_newlines > 0 then
    begin
      if (Array.length text.text_newlines - text.text_nlines)
        < nbr_newlines then
        begin
          let old_size = text.text_nlines in
          let new_cache = Array.create (old_size + (max 20 nbr_newlines)) 
            { position = -1;
              representation = [];
              modified = -1;
              repr_len = 0;
              repr_string = "";
              line_hlt = 0;
              items = [||];
            } 
          in
          Array.blit text.text_newlines 0 new_cache 0 old_size;
          text.text_newlines <- new_cache;
        end;
      Array.blit text.text_newlines (gline+1) 
      text.text_newlines (gline+1+ nbr_newlines) 
      (text.text_nlines - gline -1);
      text.text_nlines <- text.text_nlines + nbr_newlines;
      let rec iter n pos =
        let new_pos = String.index_from text.text_string pos '\n' in
        text.text_newlines.(gline+n) <- { position = (new_pos + 1);
          representation = [];
          modified = 0;
          repr_len = 0;
          repr_string = "";
          line_hlt = 0;
          items = [||];
        };
        if n < nbr_newlines then
          iter (n+1) (new_pos + 1)
      in
      iter 1 gpoint;
      tree_insert tree text text.text_gline nbr_newlines;
    end;
  let gline = text.text_gline in
  List.iter (fun p ->
      if p.point > gpoint then
        begin
          if p.point_y = gline then 
            (* p.point_x <- (p.point_x - (if nbr_newlines > 0 then gchars else 0)) + nbr_chars; *)
            p.point_y <- p.point_y + nbr_newlines;
        end
  ) text.text_points;
  text.text_gpoint <- gpoint + strlen;
  text.text_gsize <- gsize - strlen;
  text.text_gline <- gline + nbr_newlines;
  (gpoint,strlen,text.text_modified) 
@

<<function Text.low_delete>>=
let low_delete tree point len =
  let text = tree.tree_text in      
  <<[[Text.low_insert()]] fail if readonly buffer>>
  move_gpoint_to text point;
  let gsize = text.text_gsize in
  let size = text.text_size in
  let gpoint = text.text_gpoint in
  let gline = text.text_gline in
  cancel_repr text gpoint gline;
  (*let gchars = gpoint - text.text_newlines.(gline).position in*)
  let gap_end = gpoint + gsize in
  let len = min (size - gap_end) len in
  let str = String.sub text.text_string gap_end len
  in
  let (nbr_newlines, nbr_chars) = count_char str '\n' in
  if nbr_newlines > 0 then
    begin
      Array.blit text.text_newlines (gline + nbr_newlines + 1)
      text.text_newlines (gline + 1) 
      (text.text_nlines - gline - nbr_newlines - 1);
      text.text_nlines <- text.text_nlines - nbr_newlines;
    end;
  text.text_gsize <- gsize + len;
  List.iter (fun p -> 
      if p.point > gap_end + len then
        begin
          (*if p.point_y = gline + nbr_newlines then
            p.point_x <- (p.point_x - nbr_chars) + 
              (if nbr_newlines > 0 then gchars else 0);*)
          p.point_y <- p.point_y - nbr_newlines;
        end 
      else
      if p.point > gpoint then
        ( p.point <- gpoint;
          (* p.point_x <- gchars; *)
          p.point_y <- gline);
  ) text.text_points;
  (gpoint,str,text.text_modified) 
@


<<function Text.insert_at_end>>=
let insert_at_end tree str =
  let text = tree.tree_text in
  low_insert tree text.text_size str |> ignore;
  text.text_history <- [];
  text.text_modified <- text.text_modified + 1
@

<<function Text.insert_res>>=
let insert_res tree point str =
  let text = tree.tree_text in
  let (pos,len,modif) = low_insert tree point.point str in
  text.text_history <- Insertion(pos,len,modif) :: text.text_history;
  text.text_modified <- text.text_modified + 1;
  pos, len
@

<<function Text.insert>>=
let insert text point str = 
   insert_res text point str |> ignore
@

<<function Text.delete_res>>=
let delete_res tree point len =
  let text = tree.tree_text in  
  let (pos,str,modif) = low_delete tree point.point len in
  text.text_history <- Deletion(pos,str,modif) :: text.text_history;
  text.text_modified <- text.text_modified + 1;
  pos, str
@

<<function Text.delete>>=
let delete text point len = 
  delete_res text point len |> ignore
@

<<function Text.compute_newlines>>=
let compute_newlines string =
  let (nbr_newlines,_) = count_char string '\n' in
  let newlines = Array.create (nbr_newlines + 2) 
    { position = 0; representation = []; modified = 0; repr_len = 0; repr_string = ""; line_hlt = 0; items = [||]; } in
  let curs = ref 0 in
  for i = 1 to nbr_newlines do
    let pos = String.index_from string !curs '\n' in
    newlines.(i) <- { position = pos+1; representation = []; 
      modified = 0; repr_len = 0; repr_string = "";
      line_hlt = 0; items = [||];
    };
    curs := pos + 1;
  done;
  newlines.(nbr_newlines+1) <- { position = String.length string + 1; 
    representation = []; modified = 0; 
    repr_len = 0; repr_string = "";
    line_hlt = 0; items = [||];
  };
  newlines
@


<<function Text.find_xy>>=
let find_xy text point line pos =
  let text = text.tree_text in    
  let gpoint = text.text_gpoint in
  let gline = text.text_gline in
  let gap_end = gpoint + text.text_gsize in
  let y,x =
    if pos >= gap_end then
(* go forward *)
      let rec iter line =
        if line >= text.text_nlines then
          text.text_nlines - 1
        else
        if text.text_newlines.(line).position > pos then line - 1
        else
          iter (line + 1)
      in
      let line = 
        if point > gap_end && pos > point then
          iter (line+1) 
        else
          iter (gline+1) 
      in
      if line = gline then
        let gchars = gpoint - text.text_newlines.(gline).position in
        line, gchars + pos - gap_end
      else
        line, pos - text.text_newlines.(line).position
    else
(* go backward *)
    let rec iter line =
      if line > 0 then
        if text.text_newlines.(line).position > pos then 
          iter (line - 1)
        else
          line
      else
        0
    in
    let line = 
      if point < gpoint && pos <= point then
        iter line 
      else
        iter gline in
    line, pos - text.text_newlines.(line).position
  in
  x,y
@


<<function Text.read>>=
let read inc =
  create (read_string inc)
@

<<function Text.save>>=
let save tree outc =
  let text = tree.tree_text in    
  let str = text.text_string in
  let gpoint = text.text_gpoint in
  let gsize = text.text_gsize in
  output outc str 0 gpoint;
  output outc str (gpoint + gsize) 
  (text.text_size - gpoint - gsize)
@


<<function Text.low_distance>>=
let low_distance text p1 p2 =
  if p1 >= p2 then 0 else
  if p1 <= text.text_gpoint then
    if p2 <= text.text_gpoint then
      p2 - p1
    else
      p2 - p1 - text.text_gsize
  else
  if p2 <= text.text_gpoint then
    p2 - p1 + text.text_gsize
  else
    p2 - p1
@

<<function Text.distance>>=
let distance tree p1 p2 =
  let text = tree.tree_text in    
  low_distance text p1.point p2.point
@

<<function Text.compare>>=
let compare text p1 p2 = compare p1.point p2.point
@

<<function Text.add>>=
let add text point delta =
  let gpoint = text.text_gpoint in
  let gap_end = gpoint + text.text_gsize in
  if point <= gpoint && point + delta > gpoint then
    point + delta + text.text_gsize
  else
  if point >= gap_end && point+delta < gap_end then
    point + delta - text.text_gsize
  else
    point + delta
@

<<function Text.get_char>>=
let get_char tree point =
  let text = tree.tree_text in    
  let point = point.point in
  let gpoint = text.text_gpoint in
  let gsize = text.text_gsize in
  let size = text.text_size in
  let string = text.text_string in
  let point = 
    if point = gpoint then point + gsize else point
  in
  if point < size then
    string.[point]
  else
    '\000'
@


<<function Text.fmove_res>>=
let fmove_res tree p delta =
  let text = tree.tree_text in    
  if delta = 0 then 0 else
  let gpoint = text.text_gpoint in
  let size = text.text_size in
  let gap_end = gpoint + text.text_gsize in
  let gline = text.text_gline in
  let point = p.point in
  let old_point = point in
  let lines = text.text_newlines in
  let rec iter y point end_point =
    if end_point > point then
      let end_line = lines.(y+1).position in
      if end_point >= end_line then
        iter (y+1) end_line end_point
      else
        (y, end_point)
    else
      (y,point)
  in
  let (y,point) = 
    if point + delta <= gpoint then
      iter p.point_y point (point+delta)
    else
    if point >= gap_end then
      let delta = min delta (size - point) in
      iter p.point_y point (point + delta)
    else
    let delta = min (delta - (gpoint - point)) (size - gap_end) in
    iter gline gap_end
      (gap_end + delta) 
  in
  p.point <- point;
  p.point_y <- y;
  low_distance text old_point point
@

<<function Text.bmove_res>>=
let bmove_res tree p delta =
  let text = tree.tree_text in    
  if delta = 0 then 0 else
  let gpoint = text.text_gpoint in
  let gap_end = gpoint + text.text_gsize in
  let gline = text.text_gline in
  let point = p.point in
  let old_point = point in
  let lines = text.text_newlines in
  let rec iter y end_point =
    let start_line = lines.(y).position in
    if end_point >= start_line then
      (y, end_point)
    else
      iter (y-1) end_point
  in
  let (y,point) = 
    if point - delta >= gap_end then
      if point - delta < lines.(gline+1).position then
        (
          gline, point - delta)
      else
        iter p.point_y (point-delta)
    else
    if point <= gpoint then
      let delta = min delta point in
      iter p.point_y (point - delta)
    else
    let delta = min (delta - (point - gap_end)) gpoint in
    iter gline (gpoint - delta) 
  in
  p.point <- point;
  p.point_y <- y;
  low_distance text point old_point
@

<<function Text.bmove>>=
let bmove text p delta = 
  bmove_res text p delta |> ignore
@

<<function Text.fmove>>=
let fmove text p delta = 
  fmove_res text p delta |> ignore
@

<<function Text.to_string>>=
let to_string tree =
  let text = tree.tree_text in    
  let len = text.text_size - text.text_gsize in
  if len = 0 then "" else
  let str = String.create len in
  let gpoint = text.text_gpoint in
  let gap_end = gpoint + text.text_gsize in
  String.blit text.text_string 0 str 0 gpoint;
  String.blit text.text_string gap_end str gpoint (len- gpoint);
  str
@

<<[[Text.text]] other fields>>=
mutable text_clean : bool;
@

<<function Text.clean_text>>=
let clean_text text =
  if not text.text_clean then
    let size = text.text_size in
    let gsize = text.text_gsize in
    let string = text.text_string in
    move_gpoint_to text size;
    String.fill string (size - gsize) gsize '\000';
    text.text_clean <- true
@

<<function Text.blit>>=
let blit str tree point len =
  let text = tree.tree_text in      
  let len = min len (low_distance text point.point text.text_size) in
  let gpoint = text.text_gpoint in
  let gap_end = gpoint + text.text_gsize in
  if point.point+len >= gpoint && point.point < gap_end then clean_text text;
  (try
    String.blit text.text_string point.point str 0 len
    with 
      e -> raise e);
  len
@

<<function Text.get_position>>=
let get_position tree point = 
  let text = tree.tree_text in    
  if point.point > text.text_gpoint then
    point.point - text.text_gsize
  else
    point.point
@

<<function Text.set_position>>=
let set_position tree point pos =
  let text = tree.tree_text in    
  move_point_to tree point
    (if pos > text.text_gpoint then pos + text.text_gsize
    else
      pos)
@

<<function Text.sub>>=
let sub text point len =
  let str = String.create len in
  blit str text point len |> ignore;
  str
@





<<constant Text.repr_string>>=
let repr_string = ref ""
@

<<constant Text.repr_size>>=
let repr_size = ref 0
@

<<constant Text.tabreprs>>=
let tabreprs = [|
    "         ";
    "        ";
    "       ";
    "      ";
    "     ";
    "    ";
    "   ";
    "  ";
    " ";
    ""
  |]
@

<<constant Text.dummy_line>>=
let (dummy_line : line) = 
  {
    position = max_int;
    representation = [];
    modified = 0;
    repr_len = 0;
    repr_string = "";
    line_hlt = 0;
    items = [||];
  } 
@

<<[[Efuns.buffer]] other fields>>=
mutable buf_charreprs : string array; (* 256 array *)
@

% 26 letters of the alphabet?
<<[[Ebuffer.create()]] adjust charreprs>>=
for i=0 to 25 do
  let s = String.make 2 '^' in
  s.[1] <- Char.chr (97+i);    
  buf.buf_charreprs.(i) <- s
done;
buf.buf_charreprs.(9) <- String.make !tab_size ' ';
@



<<function Text.compute_representation>>=
(* On devrait reprendre la representation la ou elle est ... *)
let compute_representation tree charreprs n =
  let text = tree.tree_text in      
  if n >= text.text_nlines - 1 then 
    begin
      dummy_line.position <- text.text_size;
      dummy_line
    end
  else
  let line = text.text_newlines.(n) in
  if line.modified >= 0 then
    begin
      let end_pos = text.text_newlines.(n+1).position - 1 in
      let rec iter repr_list =
        match repr_list with
          repr :: tail ->
            let next_pos = repr.repr_line_pos + repr.repr_line_len in
            if next_pos < line.modified then
              repr_list, next_pos, repr.repr_pos + repr.repr_size
            else
              iter tail
        | [] ->
            [], 0, 0
      in
      let (repr_tail, next_pos, repr_pos) = iter line.representation in
      let repr_tail = ref repr_tail in
      let line_curs = ref (line.position + next_pos) in
      let line_start = ref next_pos in
      let repr_curs = ref repr_pos in
      let repr_start = ref repr_pos in
      let gpoint = text.text_gpoint in
      let gsize = text.text_gsize in
      let char_repr = ref "" in
      let char_size = ref 0 in
      repr_string := line.repr_string;
      repr_size := String.length line.repr_string;
      if !line_curs >= gpoint && 
        !line_curs < gpoint + gsize then 
        line_curs := !line_curs + gsize;
      while !line_curs < end_pos do
        let charattr = text.text_attrs.(!line_curs) in
        let charrepr =
          let char = Char.code text.text_string.[!line_curs] in      
          if char = 9 then tabreprs.(!repr_curs mod 9)
          else charreprs.(char) in
        let charsize = String.length charrepr in
        let line_len = ref 0 in
        (* for J.G. Malecki: tabs have a different representation depending
  on their position in the text (as in xterms) *)
        
        while !line_curs < end_pos && 
          (
            char_repr := 
            (let char = Char.code text.text_string.[!line_curs] in      
              if char = 9 then tabreprs.(!repr_curs mod 9)
              else charreprs.(char));
            char_size := String.length !char_repr;
            !char_size == charsize && 
            charattr == text.text_attrs.(!line_curs)) do
          if !repr_curs + charsize >= !repr_size then
            begin
(* find a better heuristic to realloc the line string *)
              let new_len = !repr_size + 
                  (low_distance text end_pos !line_curs) + charsize * 2 
              in
              let new_repr = String.create new_len in
              String.blit !repr_string 0 new_repr 0 !repr_curs;
              repr_string := new_repr;
              repr_size := new_len;
            end;
          String.blit !char_repr 0 !repr_string !repr_curs charsize;
          repr_curs := !repr_curs + charsize;
          line_curs := !line_curs + 1;
          line_len := !line_len +1;
          if !line_curs = gpoint then line_curs := gpoint + gsize;
        done;
        let repr = {
            repr_line_pos = !line_start;
            repr_line_len = !line_len;
            
            repr_attr = charattr;
            repr_charsize = charsize;
            
            repr_size = !line_len * charsize;
            repr_pos = !repr_start;
          } in
        repr_start := !repr_curs;
        line_start := !line_start + !line_len;
        repr_tail := repr :: !repr_tail;
      done;
      line.representation <- !repr_tail;
      line.modified <- -1;
      line.repr_len <- !repr_curs;
      line.repr_string <- !repr_string;

      (* once we have computed the simple representation, we can add more
      complicated things, such as highlighting ... *)
      if line.line_hlt <> 0 then
        if line.line_hlt > 0 then
          (* the line is hightlighted from the beginning to pos the
            line.line_hlt char *)
          begin
            let first = line.line_hlt - 1 in
            let rec iter list tail =
              match list with
                [] -> List.rev tail 
              | repr :: list_r ->
                  if repr.repr_line_pos > first then
                    iter list_r (repr :: tail)
                  else
                  let len = first - repr.repr_line_pos + 1 in
                  (List.rev tail) @
                    (let before, after = 
                      if len = repr.repr_line_len then
                        [], list
                      else
                        [ 
                          { 
                            repr_attr = repr.repr_attr;
                            repr_charsize = repr.repr_charsize;
                            repr_line_pos = repr.repr_line_pos+len;
                            repr_line_len = repr.repr_line_len - len;
                            repr_size = repr.repr_charsize * (repr.repr_line_len - len);
                            repr_pos = repr.repr_pos + (len * repr.repr_charsize)
                          }
                        ], (
                          { 
                            repr_attr = repr.repr_attr;
                            repr_charsize = repr.repr_charsize;
                            repr_line_pos = repr.repr_line_pos;
                            repr_pos = repr.repr_pos;
                            repr_line_len = len;
                            repr_size = repr.repr_charsize * len;
                          }
                            :: list_r)
                    in
                    List.iter 
                      (fun repr ->
                        repr.repr_attr <- repr.repr_attr lor (1 lsl 24))
                    after;
                    before @ after)
            in
            line.representation <- iter line.representation []
          end
        else
        (* the line is hightlighted from then end to pos line.line_hlt *)
          begin
            let first = line.line_hlt - 1 in
            let rec iter list tail =
              match list with
                [] -> List.rev tail 
              | repr :: list_r ->
                  if repr.repr_line_pos > first then
                    iter list_r (repr :: tail)
                  else
                  let len = first - repr.repr_line_pos + 1 in
                  (List.rev tail) @
                    (let before, after = 
                      if len = repr.repr_line_len then
                        [], list
                      else
                        [ 
                          {repr_attr = repr.repr_attr;
                            repr_charsize = repr.repr_charsize;
                            repr_line_pos = repr.repr_line_pos+len;
                            repr_line_len = repr.repr_line_len - len;
                            repr_size = repr.repr_charsize * (repr.repr_line_len - len);
                            repr_pos = repr.repr_pos + (len * repr.repr_charsize)
                          }
                        ], (
                          { 
                             repr_attr = repr.repr_attr;
                            repr_charsize = repr.repr_charsize;
                            repr_line_pos = repr.repr_line_pos;
                            repr_pos = repr.repr_pos;
                            repr_line_len = len;
                            repr_size = repr.repr_charsize * len;
                          }
                            :: list_r)
                    in
                    List.iter 
                      (fun repr ->
                        repr.repr_attr <- repr.repr_attr lor (1 lsl 24))
                    after;
                    before @ after)
            in
            line.representation <- iter line.representation []
          end;
    
    end;
  line
@

<<function Text.move_res>>=
let move_res text point n =
  if n > 0 then
    fmove_res text point n
  else
    bmove_res text point (-n)
@

<<function Text.move>>=
let move text point n = 
  move_res text point n |> ignore
@


<<function Text.clear>>=
let clear tree =
  let text = tree.tree_text in      
  low_delete tree 0 (text.text_size - text.text_gsize) |> ignore;
  text.text_history <- [];
  List.iter (fun p -> p.point <- 0; p.point_y <- 0) text.text_points
@

<<function Text.point_line>>=
let point_line text point = point.point_y
@


<<function Text.region>>=
let rec region tree p1 p2 =
  if p1>p2 
  then region tree p2 p1
  else sub tree p1 (distance tree p1 p2)
@

<<function Text.goto_xy>>=
let goto_xy tree point x y =
  let text = tree.tree_text in    
  let y =
    if y < text.text_nlines then y
    else text.text_nlines - 1
  in
  point.point <- text.text_newlines.(y).position;
  point.point_y <- y;
  fmove tree point x |> ignore
@

<<function Text.update>>=
let update tree str =
  let text = tree.tree_text in    
  let newlines = compute_newlines str in
  let len = String.length str in
  text.text_points |> List.iter (fun point -> 
    point.point <- get_position tree point
  );
  text.text_string <- str;
  text.text_attrs <- (Array.create len direct_attr);
  text.text_size <- len;
  text.text_gpoint <- 0;
  text.text_gline <- 0;
  text.text_gsize <- 0;
  text.text_newlines <- newlines;
  text.text_nlines <- Array.length newlines;
  text.text_modified <- text.text_modified + 1 ;
  text.text_clean <- true;
  text.text_history <- [];
  List.iter (fun point -> 
      let pos = point.point in
      point.point <- 0;
      point.point_y <- 0;
      set_position tree point pos) 
  text.text_points
@

<<function Text.lexing>>=
let lexing tree curseur end_point =
  let text = tree.tree_text in    
  clean_text text;
  Lexing.from_function 
    (fun str len ->
      let len = min len (distance tree curseur end_point) in
      let len = blit str tree curseur len in
      fmove tree curseur len |> ignore;
      len
  )
@

<<function Text.start_session>>=
let start_session tree =   
  let text = tree.tree_text in    
  text.text_modified
@

<<function Text.commit_session>>=
let commit_session tree session_date =
  let text = tree.tree_text in      
  if text.text_modified > session_date then
    let rec iter session history =
      match history with
        [] -> assert false
      | action :: history ->
          let date =
            match action with
              Session _ -> failwith "Can not commit nested sessions"
            | Insertion (_,_,date) -> date
            | Deletion (_,_,date) -> date
          in
          if date = session_date then
            text.text_history <- (Session (List.rev (action::session)))
            :: history
          else
            iter (action::session) history
    in
    iter [] text.text_history
@


%-------------------------------------------------------------

<<core/text.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

(* A FAIRE:
On doit faire converger ce text vers un text directement affichable par
WX_text. Pour cela:

Modifier WX_text pour qu'il se satisfasse de l'interface de Text.
En particulier, il doit n'utiliser que les fonctions suivantes:

Text.representation text line --> string (buffer or copy) * int (position)
Text.items line -> item array
  
Il doit aussi utiliser la structure un peu particuliere de l'arbre utiliser
ici.
  
*)

open Options
open Utils
(*
open WX_types
open WX_text
*)
(* from WX_types *)
type font = string
type color = string
<<type Text.item>>
<<type Text.item_attr>>


  
<<type Text.attribute>>
<<type Text.delta>>
<<type Text.position>>

<<type Text.direct>>
<<type Text.session>>

<<type Text.line>>

<<type Text.point>>

<<type Text.repr>>

<<type Text.text>>
  
<<type Text.action>>

module Text = struct
    type t = text
    type text = t
    type l = line
    type line = l
      
    let representation tree line = line.repr_string, line.position
    let items tree line = line.items
  end

(*      
module TextTree = WX_text.Make(Text)
open TextTree
*)
type tree_desc =
      { mutable tree_nlines: int;
        mutable tree_width: int;
        mutable tree_height: int;
(*        mutable tree_parts: 'a array; *)
(*        mutable tree_up: tree tree_desc; *)
        mutable tree_pos: int;
        mutable tree_modified: bool;
        mutable line_height: int;
        mutable line_width: int;

        mutable tree_text: text 
}

let make_text text lines =
  let nlines = Array.length lines in
  let rec tree = {
      tree_nlines = nlines;
      tree_width = 0;
      tree_height = 0;
(*
      tree_parts = [| Lines {
          tree_nlines = nlines;
          tree_width = 0;
          tree_height = 0;
          tree_parts = lines;
          tree_up = tree;
          tree_pos = 0;
          tree_modified = true;
          line_height = 0;
          line_width = 0;
          tree_text = text;      
        }|];
      tree_up = tree;
*)
      tree_pos = 0;
      tree_modified = true;
      line_height = 0;
      line_width = 0;
      tree_text = text;
    }
  in tree

type t = tree_desc
  
(* type t = tree tree_desc   *)

(* external id: t -> tree tree_desc = "%identity" *)

(*
let print msg text =
  let s = text.text_string in
  let gpoint = text.text_gpoint in
  let gsize  = text.text_gsize in
  let len = text.text_size in
  let gap_end = gpoint + gsize in
    Printf.printf "%s: <<%s[gap:%d]%s>>" msg (String.sub s 0 gpoint) gsize 
      (String.sub s gap_end (len - gap_end));
    print_newline ()
 
let print_newlines text =
  print_string "Newlines :";
  for i = 0 to text.text_nlines - 1 do
    Printf.printf " %d" text.text_newlines.(i).position;
  done;
  print_newline ()
*)

  
<<function Text.version>>
  
<<function Text.nbre_lines>>
  
<<function Text.size>>
  
<<function Text.point_col>>

<<function Text.make_attr>>

<<constant Text.direct_attr>>
<<constant Text.inverse_attr>>

<<function Text.move_gpoint_to>>

<<function Text.cancel_repr>>

<<constant Text.add_amount>>
<<function Text.extend_gap>>

<<exception Text.ReadOnlyBuffer>>

<<function Text.tree_insert>>

(*
  let rec iter tree lines =
    match tree with
      Parts text ->
        if lines = text.tree_nlines || lines = -1 then
          (* Insert in the last part *)
          iter text.tree_parts.(Array.length text.tree_parts - 1) (-1)
        else
        let rec iter2 lines i =
          let tlines = match text.tree_parts.(i) with
              Parts t -> t.tree_nlines
            | Lines t -> t.tree_nlines 
          in
          if tlines > lines then
            iter text.tree_parts.(i) lines
          else
            iter2 (lines - tlines) (i+1)
        in
        iter2 lines 0;
        text.tree_modified <- true;
        text.tree_nlines <- text.tree_nlines + nbr
    | Lines text ->
        let newtext = Array.create text.tree_nlines text.tree_parts.(0) in
        Array.blit text.tree_parts 0 newtext 0 lines;
        Array.blit t.text_newlines gline newtext lines nbr;
        Array.blit text.tree_parts lines newtext (lines+nbr) (
          text.tree_nlines - lines);
        text.tree_modified <- true;        
        text.tree_nlines <- text.tree_nlines + nbr
  in
  iter (Parts tree) gline
*)

<<function Text.low_insert>>

<<function Text.low_delete>>

<<function Text.undo>>

<<function Text.insert_at_end>>

<<function Text.insert_res>>

<<function Text.insert>>
  
<<function Text.delete_res>>

<<function Text.delete>>
  
<<function Text.compute_newlines>>

<<function Text.create>>
  
<<function Text.find_xy>>

<<function Text.add_point>>

<<function Text.dup_point>>

<<function Text.goto_point>>

<<function Text.move_point_to>>

<<function Text.remove_point>>

<<function Text.read>>

<<function Text.save>>

<<function Text.unset_attr>>

<<function Text.set_attr>>

<<function Text.low_distance>>

<<function Text.distance>>

<<function Text.compare>>
  
<<function Text.add>>

<<function Text.get_char>>

<<function Text.get_attr>>


<<function Text.set_char_attr>>

<<function Text.fmove_res>>



<<function Text.bmove_res>>

<<function Text.bmove>>

<<function Text.fmove>>
  
<<function Text.to_string>>


<<function Text.clean_text>>


<<function Text.blit>>
  
<<function Text.get_position>>

<<function Text.set_position>>
    
<<function Text.sub>>
    
<<function Text.search_forward>>

<<function Text.replace_matched>>
  
<<function Text.search_forward_matched>>

<<function Text.search_forward_groups>>

<<function Text.search_backward>>

<<function Text.search_backward_groups>>


<<constant Text.repr_string>>
<<constant Text.repr_size>>

<<constant Text.dummy_line>>
  
<<constant Text.tabreprs>>
      
<<function Text.compute_representation>>


<<function Text.point_to_eol>>

<<function Text.point_to_bol>>

<<function Text.point_to_eof>>

<<function Text.point_to_bof>>

<<function Text.move_res>>

<<function Text.move>>

<<function Text.point_to_lof>>

<<function Text.point_to_lol>>

<<function Text.point_to_line>>

<<function Text.clear>>


<<function Text.point_line>>


<<function Text.goto_line>>


<<function Text.region>>

<<function Text.goto_xy>>

<<function Text.update>>

<<function Text.lexing>>

<<function Text.start_session>>
  
<<function Text.commit_session>>
    
<<function Text.readonly>>
  
<<function Text.toggle_readonly>>
  
@


\subsection*{[[core/ebuffer.ml]]}


<<constant Ebuffer.tab_size>>=
let tab_size = ref 9
@


<<exception Ebuffer.Found>>=
exception Found of buffer
@

<<function Ebuffer.read>>=
let read location filename local_map =
  try
    let filename = Utils.normal_name location.loc_dirname filename in
    try
      Hashtbl.find location.loc_files filename
    with
      Not_found ->
        let text =
          try
            let inc = open_in filename in
            let text = Text.read inc in         
            close_in inc; 
            text
          with
            _ -> Text.create ""
        in
        let buf = create location filename (Some filename) text local_map in
        Hashtbl.add location.loc_files filename buf;
        buf
  with
    Found buf -> buf
@


<<function Ebuffer.compute_representation>>=
let compute_representation buf n =
  Text.compute_representation buf.buf_text buf.buf_charreprs n
@

<<exception Ebuffer.BufferAlreadyOpened>>=
exception BufferAlreadyOpened
@

<<function Ebuffer.change_name>>=
let change_name location buf filename =
  Hashtbl.remove location.loc_buffers buf.buf_name;
  (match buf.buf_filename with
      None -> ()
    | Some filename ->
        Hashtbl.remove location.loc_files filename);
  let filename = 
    if Filename.is_relative filename then
      Filename.concat location.loc_dirname filename
    else
      filename
  in
  if hashtbl_mem location.loc_files filename then
    raise BufferAlreadyOpened;
  let filename = Utils.normal_name location.loc_dirname filename in
  let name = get_name location filename in
  Hashtbl.add location.loc_buffers name buf;
  Hashtbl.add location.loc_files filename buf;
  buf.buf_filename <- Some filename;
  buf.buf_name <- name
@


<<constant Ebuffer.modes_old>>=
let modes_old = ref []
@



<<function Ebuffer.catch>>=
let catch format buf f =
  try
    f ()
  with e ->
      let location = buf.buf_location in
      let name = "*Messages*" in
      let m = Printf.sprintf format (Utils.printexn e) in
      try
        let buf = Hashtbl.find location.loc_buffers name in
        Text.insert_at_end buf.buf_text (m ^ "\n");
      with Not_found ->
        create location name None (Text.create (m^"\n")) (Keymap.create ()) 
          |>ignore
@

<<toplevel Ebuffer._1>>=
let _ =
  Efuns.add_start_hook 
    (fun location ->
      set_global location create_buf_hook [set_buffer_mode];
      set_global location modes_alist []
      )
@


%-------------------------------------------------------------

<<core/ebuffer.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Utils
open Efuns
open Text

<<constant Ebuffer.create_buf_hook>>
<<constant Ebuffer.modes_alist>>

<<function Ebuffer.create_syntax_table>>

<<constant Ebuffer.default_syntax_table>>

<<function Ebuffer.get_name>>

      
<<function Ebuffer.new_minor_mode>>
      
<<function Ebuffer.new_minor_mode (core/ebuffer.ml)>>

<<function Ebuffer.new_major_mode>>

<<constant Ebuffer.fondamental_mode>>
  
<<constant Ebuffer.tab_size>>

<<function Ebuffer.create>>

<<function Ebuffer.kill>>

open Options
  
<<constant Ebuffer.save_buffer_hooks>>
  
<<constant Ebuffer.saved_buffer_hooks>>

<<function Ebuffer.exec_named_buf_hooks>>

<<function Ebuffer.exec_named_buf_hooks_with_abort>>
      
<<function Ebuffer.save>>


<<exception Ebuffer.Found>>

  
<<function Ebuffer.read>>

<<function Ebuffer.default>>
      

<<function Ebuffer.compute_representation>>

<<exception Ebuffer.BufferAlreadyOpened>>

<<function Ebuffer.change_name>>
  
  
<<function Ebuffer.set_mark>>

<<function Ebuffer.get_mark>>

<<function Ebuffer.remove_mark>>

<<constant Ebuffer.modes_old>>
<<constant Ebuffer.regexp_alist>>

<<function Ebuffer.set_major_mode>>

<<function Ebuffer.set_minor_mode>>

<<function Ebuffer.del_minor_mode>>
  
<<function Ebuffer.modep>>

<<constant Ebuffer.suffix_reg>>
  
<<function Ebuffer.set_buffer_mode>>
      
<<function Ebuffer.get_binding>>

<<function Ebuffer.message>>

<<function Ebuffer.catch>>
          
      
<<toplevel Ebuffer._1>>
@


\subsection*{[[core/keymap.ml]]}


<<function Keymap.unbound_key>>=
let unbound_key buffer _ = raise UnboundKey
@


<<function Keymap.define_char_binding>>=
let define_char_binding map char (f : frame -> 'a) =
  add_binding map [NormalMap,Char.code char] f
@


%-------------------------------------------------------------

<<core/keymap.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

(*
La gestion des keymaps est inadapte'e a` la modification dynamique.
En effet, on aurait envie de pouvoir modifier les bindings selon divers
  crite`res, tels que le buffer (possible), le mode(pas possible).
*)


open Efuns

<<function Keymap.dummy_action>>
<<function Keymap.unbound_key>>

<<function Keymap.create>>


let keysym_to_name = []

<<function Keymap.print_key>>
            
<<function Keymap.print_key_list>>

<<function Keymap.print>>
    
<<function Keymap.get_binding>>
          
          
<<function Keymap.set_binding>>

<<function Keymap.add_binding>>
          

<<function Keymap.define_char_binding>>
    
<<constant Keymap.c_h>>
<<constant Keymap.c_x>>
<<constant Keymap.c_c>>
<<constant Keymap.n_5>>

<<function Keymap.all_bindings>>
  
<<function Keymap.interactive>>

<<function Keymap.add_interactive>>

<<function Keymap.add_global_key>>
<<function Keymap.add_local_key>>
<<function Keymap.add_minor_key>>
<<function Keymap.add_major_key>>
  
@


\subsection*{[[core/minibuffer.ml]]}

<<function Minibuffer.kill>>=
let kill mini_frame old_frame =
  let window = mini_frame.frm_window in
  let top_window = Window.top window in
  clear_message top_window;
  top_window.top_mini_buffers <- List.tl top_window.top_mini_buffers;
  if old_frame.frm_killed then
    Frame.unkill window old_frame;
  top_window.top_active_frame <- old_frame;
  Frame.kill mini_frame
@

<<function Minibuffer.return>>=
let return action old_frame mini_frame =
  let repstr = Text.to_string mini_frame.frm_buffer.buf_text in
  kill mini_frame old_frame;
  action old_frame repstr
@


<<function Minibuffer.create_return>>=
let create_return frame local_map request default action =
  let mini_frame = create frame local_map request in
  insert_string mini_frame default;
  Keymap.add_binding local_map [NormalMap, XK.xk_Return] 
    (return action frame);
  mini_frame
@

<<function Minibuffer.update_request>>=
let update_request frame request =
  let qlen = String.length request in
  let window = frame.frm_window in
  let top_window = Window.top window in
  let _mini_window = Window.create true window.win_up
      qlen window.win_ypos
      (top_window.top_width - qlen) 1
  in
  frame.frm_width <- top_window.top_width - qlen;
  frame.frm_xpos <- qlen;
  frame.frm_mini_buffer <- Some request;
  frame.frm_redraw <- true
@


%-------------------------------------------------------------

<<core/minibuffer.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Text
open Efuns
open Frame
open Ebuffer
open Top_window
open Simple


<<constant Minibuffer.charreprs>>
<<toplevel Minibuffer._1>>

<<function Minibuffer.buf_create>>


<<function Minibuffer.kill>>

<<function Minibuffer.return>>

<<function Minibuffer.create>>

<<function Minibuffer.create_return>>

<<function Minibuffer.update_request>>
  
@


\subsection*{[[core/window.ml]]}

<<function Window.xterm>>=
let backend top_window =
  match top_window.graphics with
    None -> raise Not_found
  | Some x -> x
@

<<function Window.display>>=
@




%-------------------------------------------------------------

<<core/window.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Efuns

<<function Window.create_at_top>>

<<function Window.create>>

<<function Window.top>>

<<function Window.iter>>

<<function Window.first>>

<<function Window.last>>

<<function Window.next>>
      
<<function Window.prev>>

<<function Window.xterm>>

<<function Window.display>>

<<function Window.get_font>>
        
<<function Window.get_color>>
        
@


\subsection*{[[core/frame.ml]]}

<<function Frame.print_list>>=
let rec print_list list =
  match list with
    [] -> ""
  | [ele] -> ele
  | ele :: ( (_ :: _) as tail) ->
      ele ^ " " ^ (print_list tail)
@


% Frame.create_without_top | one_frame | v_cut | ... -> <>
<<function Frame.install>>=
let install window frame =
  if window.win_mini = (frame.frm_mini_buffer = None) 
  then (kill frame; failwith "Cannot install in minibuffer");

  window |> Window.iter (fun f -> if not (f == frame) then kill f);
  window.win_down <- WFrame frame;

  frame.frm_xpos <- window.win_xpos;
  frame.frm_ypos <- window.win_ypos;
  frame.frm_width <- window.win_width;
  frame.frm_height <- window.win_height;
  frame.frm_window <- window;

  if frame.frm_cutline < max_int 
  then frame.frm_cutline <- window.win_width - 1;
  frame.frm_table <- (Array.init window.win_height (fun i -> 
        {
          repr_line = dummy_line;
          repr_y = 0;
          repr_x = 0;
          repr_offset = 0;
          repr_reprs = [];
          repr_prev_reprs = [];
          repr_prev_offset = 0;
        } ));
  frame.frm_redraw <- true
@

<<function Frame.resize>>=
let resize frame =
  let window = frame.frm_window in
  install window frame
@


<<constant Frame.dummy_mode>>=
let dummy_mode = Ebuffer.new_major_mode "" []
@


<<function Frame.active>>=
let active frame =
  let top_window = Window.top frame.frm_window in
  top_window.top_active_frame <- frame;
  match frame.frm_buffer.buf_filename with
    None -> ()
  | Some filename -> 
      frame.frm_location.loc_dirname <- Filename.dirname filename
@

<<function Frame.create>>=
let create window mini buf =
  let top_window = Window.top window in
  let frame = create_without_top top_window.top_location window mini buf in
  top_window.top_active_frame <- frame;
  frame
@

<<function Frame.create_inactive>>=
let create_inactive window buf =
  let top_window = Window.top window in
  let frame = create_without_top top_window.top_location window None buf in
  frame
@

<<function Frame.point_to_cursor>>=
let point_to_cursor buf point =
  let text = buf.buf_text in
  let line = Ebuffer.compute_representation buf (point_line text point) in
  let xpos = point_col text point in
  let rec iter reprs =
    match reprs with
      [] -> 0
    | repr :: tail ->
        if repr.repr_line_pos > xpos then
          iter tail
        else
          repr.repr_pos + repr.repr_charsize * (xpos - repr.repr_line_pos)
  in
  iter line.representation
@

<<function Frame.cursor_to_point>>=
let cursor_to_point frame x y =
  if (y < 0) || (x<0) ||
    (y >= frame.frm_height-1) || (x>frame.frm_cutline) then 
    raise Not_found
  else
  let line_repr = frame.frm_table.(y) in
  let y = line_repr.repr_y in
  let rec iter x reprs default =
    match reprs with
      [] -> default
    | repr :: tail -> 
        if repr.repr_size > x then
          repr.repr_line_pos + x / repr.repr_charsize
        else
          iter (x - repr.repr_size) tail 
            (repr.repr_line_pos + repr.repr_line_len)
  in
  let x = iter (x+frame.frm_x_offset+line_repr.repr_offset) 
    line_repr.repr_reprs 0 in
  x , y
@



<<[[Efuns.frame]] other fields>>=
mutable frm_cursor_x : int;
mutable frm_cursor_y : int;
mutable frm_cursor : string;
mutable frm_cursor_attr : Text.attribute;
@
% a frame has a cursor!


<<function Frame.set_cursor>>=
let set_cursor frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let x = point_to_cursor buf point in
  let line = Ebuffer.compute_representation buf (point_line text point) in
  
  try
    for i = 0 to frame.frm_height - 1 do
      let line_repr = frame.frm_table.(i) in
      if line_repr.repr_line == line then
        let x,y =
          if x = 0 then 0,i
          else
            ((x-1) mod frame.frm_cutline) + 1, i + (x-1) / frame.frm_cutline
        in
        frame.frm_cursor_x <- x;
        frame.frm_cursor_y <- y;
        raise Exit
    done;      
    (* insert cursor is not on frame *)
    frame.frm_cursor.[0] <- '\000'
    
  with
    Exit -> 
      let rec iter reprs =
        match reprs with
          [] -> 
            frame.frm_cursor.[0] <- ' '
        | repr :: tail ->
            let point_x = point_col text point in
            if repr.repr_line_pos <= point_x &&
              repr.repr_line_pos + repr.repr_line_len > point_x then
              let pos =
                repr.repr_pos + repr.repr_charsize * 
                (point_x - repr.repr_line_pos)
              in
              frame.frm_cursor.[0] <- line.repr_string.[pos];
              frame.frm_cursor_attr <- repr.repr_attr;
            else
              iter tail
      in
      let repr_line = frame.frm_table.(frame.frm_cursor_y)
      in
      iter repr_line.repr_reprs
@



<<exception Frame.BufferKilled>>=
exception BufferKilled
@

<<function Frame.unkill>>=
let unkill window frame =
  let buf = frame.frm_buffer  in
  if buf.buf_shared < 0 then raise BufferKilled;
  let text = buf.buf_text in
  install window frame;
  frame.frm_start <- Text.dup_point text buf.buf_start;
  frame.frm_end <- Text.dup_point text buf.buf_start;
  frame.frm_point <- Text.dup_point text buf.buf_point;
  frame.frm_y_offset <- 0;
  buf.buf_shared <- buf.buf_shared + 1;
  frame.frm_killed <- false
@

<<function Frame.move_point>>=
let move_point frame point x y =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let x, y = cursor_to_point frame (x - frame.frm_xpos) (y - frame.frm_ypos) in
  goto_line text point y;
  fmove text point x |> ignore
@

<<function Frame.current_dir>>=
let current_dir frame =
  let buf = frame.frm_buffer in
  match buf.buf_filename with
    Some filename -> Filename.dirname filename ^ "/"
  | None -> buf.buf_location.loc_dirname ^ "/"
@

<<exception Frame.FoundFrame>>=
exception FoundFrame of frame
@

<<function Frame.find_buffer_frame>>=
let find_buffer_frame location buf =
  try
    List.iter (fun top_window ->
        Window.iter (fun frame -> 
            if frame.frm_buffer == buf then raise (FoundFrame frame))
        top_window.window
    ) location.top_windows;
    raise Not_found
  with
    FoundFrame frame -> frame
@







%-------------------------------------------------------------

<<core/frame.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)
open Common

open Options
open Text
open Efuns
open Ebuffer

<<constant Frame.status_format>>

<<function Frame.status_print>>


<<function Frame.status_modified>>

<<function Frame.status_col>>

<<function Frame.print_list>>

<<function Frame.status_major_mode>>

<<function Frame.status_line>>

<<function Frame.status_name>>

<<function Frame.kill>>

<<function Frame.kill_all>>

<<function Frame.install>>

<<function Frame.resize>>

<<constant Frame.editname>>
<<constant Frame.dummy_mode>>
  
<<function Frame.create_without_top>>

<<function Frame.active>>
      
      
<<function Frame.create>>

<<function Frame.create_inactive>>


<<function Frame.point_to_cursor>>

<<function Frame.cursor_to_point>>


<<function Frame.update_line>>

<<function Frame.set_cursor>>

<<function Frame.update_table>>


<<function Frame.update>>

<<exception Frame.BufferKilled>>
<<function Frame.unkill>>

<<function Frame.move_point>>

<<function Frame.current_dir>>


<<exception Frame.FoundFrame>>

<<function Frame.find_buffer_frame>>

<<constant Frame.change_buffer_hooks>>

<<function Frame.exec_named_hooks>>

<<function Frame.exec_named_hooks_with_abort>>

<<function Frame.load_file>>

  
<<function Frame.change_buffer>>

<<function Frame.save_buffer>>

<<function Frame.bindings_help>>
  
@


\section{[[features/]]}

\subsection*{[[features/simple.ml]]}

<<function Simple.string_to_modifier>>=
let string_to_modifier s =  
  let mask = ref 0 in
  for i = 0 to String.length s - 1 do
    mask := !mask lor (match s.[i] with
      | 'C' -> controlMask
      | 'A' -> mod1Mask
      | 'M' -> mod1Mask
      | '1' -> mod1Mask
      | _ -> 0
    )
  done;
  !mask
@

<<function Simple.modifier_to_string>>=
let modifier_to_string mask = 
  let s = if mask land shiftMask = 0 then "" else "S" in
  let s = if mask land controlMask = 0 then s else "C" ^ s in
  let s = if mask land mod1Mask = 0 then s else "M" ^ s in
  let s = if mask land mod2Mask = 0 then s else "2" ^ s in
  let s = if mask land mod3Mask = 0 then s else "3" ^ s in
  let s = if mask land mod4Mask = 0 then s else "4" ^ s in
  let s = if mask land mod5Mask = 0 then s else "5" ^ s in
  s
@

<<constant Simple.name_to_keysym>>=
let name_to_keysym = 
  ("Button1", XK.xk_Pointer_Button1) ::
  ("Button2", XK.xk_Pointer_Button2) ::
  ("Button3", XK.xk_Pointer_Button3) ::
  ("Button4", XK.xk_Pointer_Button4) ::
  ("Button5", XK.xk_Pointer_Button5) ::
  XK.name_to_keysym
@

<<function Simple.value_to_keysym>>=
let value_to_keysym v =
  match v with
    Value v -> List.assoc v name_to_keysym
  | _ -> raise Not_found
@

<<function Simple.keysym_to_value>>=
let keysym_to_value k =
  Value (List.assoc k XK.keysym_to_name)
@

<<function Simple.value_to_key>>=
(* form: SC-Button1 *)
let value_to_key v =
  match v with 
    Value s -> 
      let key, mods = 
        try
          let index = String.index s '-' in
          let mods = String.sub s 0 index in
          let key = String.sub s (index+1) (String.length s - index - 1) in
          key, mods
        with _ -> s, ""
      in
      let key = List.assoc key name_to_keysym in
      let mods = string_to_modifier mods in
      let map = 
        if mods land (controlMask lor mod1Mask) = (controlMask lor mod1Mask)
        then ControlMetaMap else
        if mods land controlMask <> 0 then ControlMap else
        if mods land mod1Mask <> 0 then MetaMap else NormalMap
      in
      map, key
      
  | _ -> raise Not_found
@

<<function Simple.key_to_value>>=
let key_to_value k = Value (Keymap.print_key k)
@



<<function Simple.insert_string>>=
let insert_string frame str =
  let text = frame.frm_buffer.buf_text in
  let point = frame.frm_point in
  Text.insert text point str |> ignore;
  Text.fmove text point (String.length str) |> ignore
@




<<function Simple.previous_char>>=
let previous_char frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  if bmove_res text point 1 = 0 then raise Not_found;
  let c = get_char text point in
  fmove text point 1 |> ignore;
  c
@

<<function Simple.unset_attr>>=
let unset_attr frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  Text.unset_attr text
@

<<function Simple.insert_at_place>>=
let insert_at_place frame char =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let c = get_char text point in
  if c = '\n' then
    insert_char frame char
  else
  let _sessionTODOBUG = start_session text in
  Text.delete text point 1 |> ignore;
  single_char.[0] <- char;    
  Text.insert text point single_char |> ignore;
  fmove text point 1 |> ignore
@

<<constant Simple.overwrite_mode>>=
let overwrite_mode = Ebuffer.new_minor_mode "Over" []
@

<<function Simple.self_insert_command>>=
let self_insert_command frame =
  let char = Char.chr !keypressed in
  let buf = frame.frm_buffer in
  if Ebuffer.modep buf overwrite_mode then 
    insert_at_place frame char
  else
    insert_char frame char
@

<<function Simple.char_insert_command>>=
let char_insert_command char frame =
  let buf = frame.frm_buffer in
  if Ebuffer.modep buf overwrite_mode then 
    insert_at_place frame char
  else
    insert_char frame char
@


<<function Simple.begin_to_point>>=
let begin_to_point frame =
  let text = frame.frm_buffer.buf_text in
  let point = frame.frm_point in
  Text.point_to_bol text point
@

<<function Simple.point_to_end>>=
let point_to_end frame =
  let text = frame.frm_buffer.buf_text in
  let point = frame.frm_point in
  Text.point_to_eol text point
@

<<function Simple.line_size>>=
let line_size frame =
  (point_to_end frame) + (point_to_end frame)
@



<<constant Simple.kill_size>>=
let kill_size = ref 0
@

<<constant Simple.kill_max>>=
let kill_max = 10
@


<<constant Simple.last_kill>>=
let last_kill = ref None
@


<<function Simple.kill_string>>=
let kill_string str =
  Array.blit kill_ring 0 kill_ring 1 (kill_max - 1);
  incr kill_size;
  kill_ring.(0) <- str
@

<<function Simple.kill_text>>=
let kill_text text point len =
  let point,str = Text.delete_res text point len in
  match !last_kill with
  | Some (oldtext,oldpoint) when
    oldpoint = point && oldtext == text ->
      kill_ring.(0) <- kill_ring.(0)^str
  | _ ->
      last_kill := Some (text,point);
      kill_string str
@


<<function Simple.kill_eol>>=
let kill_eol buf point =
  let text = buf.buf_text in
  let eol = point_to_eol text point in
  let len =
    if eol = 0 then 1 else eol
  in
  kill_text text point len
@

<<function Simple.kill_bol>>=
let kill_bol buf point =
  let text = buf.buf_text in
  let len = point_to_bol text point in
  if len > 0 then
    ( bmove text point len;
      kill_text text point len)
@


<<function Simple.format_to>>=
let format_to frame =
  let point = frame.frm_point in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  Format.set_formatter_output_functions 
    (fun str pos len ->
      let s = String.sub str pos len in
      Text.insert text point s |> ignore;
      Text.fmove text point len)
  (fun () -> ())
@

<<function Simple.format_to_string>>=
let format_to_string () =
  let string = ref "" in
  Format.set_formatter_output_functions 
    (fun str pos len ->
      let s = String.sub str pos len in
      string := !string ^ s)
  (fun () -> ());
  string
@

<<function Simple.in_next_word>>=
let in_next_word text mark syntax =
  while (not syntax.(Char.code (get_char text mark))) &&
    fmove_res text mark 1 = 1 do () done
@

<<function Simple.in_prev_word>>=
let in_prev_word text mark syntax =
  while bmove_res text mark 1 = 1 &&
    (not syntax.(Char.code (get_char text mark)))
  do () done
@

<<function Simple.to_begin_of_word>>=
let to_begin_of_word text mark syntax =
  if bmove_res text mark 1 = 1 then
    begin
      while syntax.(Char.code (Text.get_char text mark)) &&
        (bmove_res text mark 1) <> 0 do ()
      done;
      if not syntax.(Char.code (Text.get_char text mark)) then
        (fmove text mark 1)
    end
@

<<function Simple.to_end_of_word>>=
let to_end_of_word text mark syntax =
  while syntax.(Char.code (get_char text mark)) &&
    (fmove_res text mark 1) <> 0 do ()
  done
@

<<function Simple.to_frame>>=
let to_frame f frame =
  f frame.frm_buffer frame.frm_point
@


<<function Simple.beginning_of_word>>=
let beginning_of_word buf point =
  let text = buf.buf_text in
  let syntax = buf.buf_syntax_table in
  let mark = dup_point text point in
  to_begin_of_word text mark syntax;
  let s = Text.region text mark point in
  Text.remove_point text mark;
  s
@

<<function Simple.end_of_word>>=
let end_of_word  buf point =
  let text = buf.buf_text in
  let syntax = buf.buf_syntax_table in
  let mark = dup_point text point in
  to_end_of_word text mark syntax;
  let s = Text.region text point mark in
  Text.remove_point text mark;
  s
@

<<function Simple.current_word>>=
let current_word buf point =
  let text = buf.buf_text in
  let syntax = buf.buf_syntax_table in
  let start = dup_point text point in
  to_begin_of_word text start syntax;
  let term = dup_point text point in
  to_end_of_word text term syntax;
  let word = Text.region text start term in
  remove_point text start;
  remove_point text term;
  word
@

<<function Simple.current_word (features/simple.ml)>>=
let current_word buf point =
  (beginning_of_word buf point) ^ (end_of_word buf point)
@

<<function Simple.dirname>>=
let dirname frame filename =
  let filename =
    if Filename.is_relative filename then
      Filename.concat (Frame.current_dir frame) filename
    else
      filename
  in
  Filename.dirname filename
@

<<function Simple.buffer_list>>=
let buffer_list frame =
  let top_window = Window.top frame.frm_window in
  let location = top_window.top_location in
  let list = ref [] in
  Hashtbl.iter (fun name _ -> list := name :: !list) location.loc_buffers;
  !list
@





<<function Simple.scroll_line>>=
let scroll_line frame n =
  frame.frm_force_start <- true;
  frame.frm_redraw <- true;
  frame.frm_y_offset <- frame.frm_y_offset + n
@

<<function Simple.recenter>>=
let recenter frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  frame.frm_force_start <- true;
  frame.frm_redraw <- true;
  goto_point text frame.frm_start frame.frm_point;
  frame.frm_y_offset <- - frame.frm_height/2
@






<<constant Simple.highlighted>>=
(* hightlighting of regions *)  
let highlighted = ref None
@

<<constant Simple.highlight_bit>>=
let highlight_bit = 1 lsl 24
@

<<function Simple.unhightlight_region>>=
let unhightlight_region buf debut fin =
  let text = buf.buf_text in
  let curseur = add_point text in
  let final = add_point text in
  set_position text curseur debut;
  set_position text final fin;
  let unhigh = lnot (1 lsl 24) in
  while curseur < final do
    let attr = get_attr text curseur in
    set_char_attr text curseur (attr land unhigh);
    fmove text curseur 1;
  done;
  remove_point text curseur;
  remove_point text final;
  buf.buf_modified <- buf.buf_modified + 1
@

<<function Simple.hightlight_region>>=
let hightlight_region buf debut fin =
  let text = buf.buf_text in
  let curseur = add_point text in
  let final = add_point text in
  set_position text curseur debut;
  set_position text final fin;
  let high = 1 lsl 24 in
  while curseur < final do
    let attr = get_attr text curseur in
    set_char_attr text curseur (attr lor high);
    fmove text curseur 1
  done;
  remove_point text curseur;
  remove_point text final;
  buf.buf_modified <- buf.buf_modified + 1
@

<<constant Simple.highlighted_chars>>=
let highlighted_chars = ref []
@

<<function Simple.unhightlight>>=
let unhightlight location =
    failwith "Simple.unhighlight: TODO"
(*
  List.iter (fun (buf,curseur,attr) ->
      let text = buf.buf_text in
      set_char_attr text curseur attr;
      buf.buf_modified <- buf.buf_modified + 1;
      remove_point text curseur
  ) !highlighted_chars;
  highlighted_chars := [];
    match !highlighted with
      None -> ()
    | Some (frame,debut,fin) -> 
        if !keypressed <> XK.xk_Pointer_Drag1 then
          let top_window = Window.top frame.frm_window in
          let xterm = Window.xterm top_window in
          highlighted := None;
          
          let buf = frame.frm_buffer in
          let text = buf.buf_text in
          let curseur = add_point text in
          let final = add_point text in
          set_position text curseur debut;
          set_position text final fin;
          let str = Text.region text curseur final in
          remove_point text curseur;
          remove_point text final;
          kill_string str;
          WX_xterm.set_cutbuffer xterm str;
          unhightlight_region buf debut fin
          *)
@

<<function Simple.highlight>>=
let highlight frame =
  let frame =
    match !highlighted with
      None -> frame
    | Some (frame,d,f) -> frame
  in    
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  let text = buf.buf_text in
  let mark = Ebuffer.get_mark buf point in
  let debut, fin =
    if point < mark then
      point,mark
    else
      mark,point
  in
  let pos1 = get_position text debut in
  let pos2 = get_position text fin in
  let debut,fin =
    match !highlighted with
      None -> pos1,pos2
    | Some (frame,d,f) ->
        if d < pos1 then    
          unhightlight_region buf d pos1; 
        if f > pos2 then
          unhightlight_region buf pos2 f;
        if pos1 < d then
          pos1,d
        else
        if pos2 > f then
          f, pos2
        else
          pos1,pos1
  in
  highlighted := Some (frame, pos1, pos2);
  hightlight_region buf debut fin
@

<<constant Simple.htmlp>>=
let htmlp = ref false
@

<<function Simple.is_paren_end>>=
let is_paren_end c = (c == '}') || (c == ']') || (c == ')')
  ||  (!htmlp && c == '>')
@

<<function Simple.is_paren_begin>>=
let is_paren_begin c = (c == '{') || (c == '[') || (c == '(')
  ||  (!htmlp && c == '<')
@

<<function Simple.highlight_paren>>=
let highlight_paren frame =
  htmlp := (!keypressed = Char.code '>');
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let curseur = dup_point text point in
  if bmove_res text curseur 1 = 0 then remove_point text curseur
  else
  let c = get_char text curseur in
  if not(is_paren_end c) then remove_point text curseur 
  else
  let rec iter stack =
    if bmove_res text curseur 1 = 0 then
      begin
        remove_point text curseur;
        Top_window.mini_message frame "No matching parenthesis"
      end
    else
    let d = get_char text curseur in
    if is_paren_end d then
      begin
        iter (d :: stack)
      end
    else
    if is_paren_begin d then
      match stack with
        [] -> (* found matching par *)
          let attr = get_attr text curseur in
          highlighted_chars := (buf,curseur,attr) :: !highlighted_chars;
          set_char_attr text curseur (attr lor (1 lsl 24));
          buf.buf_modified <- buf.buf_modified + 1
      | _ :: stack -> (* don't try to match *)
          iter stack
    else
      iter stack
  in
  iter []
@

<<function Simple.mouse_drag_region>>=
(* C'est tout simple. On arrive dans cette fonction quand on est en train
de bouger la souris avec le bouton appuyer. La frame courante est donc 
correcte. On peut utiliser la position de la souris pour trouver la 
nouvelle position du curseur dans la frame. Si on en sort, on peut
ou prendre la derniere position, ou la premiere.
*)
let mouse_drag_region frame =
  failwith "Simple.mouse_drag_region: TODO"
(*
  let top_window = Window.top frame.frm_window in
  let point = frame.frm_point in
  begin
    try
      move_point frame point !mouse_x !mouse_y
    with
      Not_found ->
        let buf = frame.frm_buffer in
        let text = buf.buf_text in
        let y = !mouse_y - frame.frm_ypos in
        if y < 0 then
          ( scroll_line frame (y-1);
            goto_point text point frame.frm_start;
            bmove text point 1; ())
        else
        if y >= frame.frm_height - 1 then
          (
            scroll_line frame (y - frame.frm_height + 2);
            goto_point text point frame.frm_end;
            fmove text point 1; ())
  end;
  highlight frame;
  let top_window = Window.top frame.frm_window in
  let xterm = top_window.top_term in
  Selection.setSelection xterm#display xterm#window XA.xa_primary
    (fun target ->
      if target = XA.xa_string then 
        match !highlighted with
          None -> raise Not_found
        | Some (frame,debut,fin) -> 
            let buf = frame.frm_buffer in
            let text = buf.buf_text in
            let curseur = add_point text in
            let final = add_point text in
            set_position text curseur debut;
            set_position text final fin;
            let str = Text.region text curseur final in
            remove_point text curseur;
            remove_point text final;
            
            1, str
      else raise Not_found
  ) !Eloop.event_time
*)
@



<<function Simple.next_buffer>>=
let next_buffer location buf =
  let buf_list = Utils.list_of_hash location.loc_buffers in
  let rec iter list =
    match list with
      [] -> raise Not_found 
    | (name,b) :: tail ->
        if b == buf then 
          match tail with
            [] -> snd (List.hd buf_list)
          | (_,b)::_ -> b
        else
          iter tail
  in
  iter buf_list
@


<<function Simple.color>>=
let color buf regexp strict attr =
  let text = buf.buf_text in
  let point = Text.add_point text in
  try
    while true do
      let len = Text.search_forward text regexp point in
      let before =
        if Text.bmove_res text point 1 = 1 then
          (let c = Text.get_char text point in
            Text.fmove text point (len+1);c)
        else
          (let c = Text.get_char text point in
            Text.fmove text point (len+1); c)
      in
      let after = Text.get_char text point in
      if not (strict && (buf.buf_syntax_table.(Char.code before) ||
            buf.buf_syntax_table.(Char.code after))) then
        begin
          bmove text point len;
          Text.set_attr text point len attr;
          fmove text point len;
          ()
        end
    done
  with
    Not_found -> 
      Text.remove_point text point;
      buf.buf_modified <- buf.buf_modified + 1
@

<<function Simple.point_at_mark>>=
let point_at_mark frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let mark = Ebuffer.get_mark buf point in
  let point_pos = get_position text point in
  goto_point text point mark;
  set_position text mark point_pos
@





<<function Simple.electric_insert_space>>=
let electric_insert_space frame =
  self_insert_command frame;
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let line_len = point_to_bol text point in
  if line_len > 75 then
    let mark = dup_point text point in
    (try
        while (backward_word buf mark;
            point_to_bol text mark > 75) do () done;
        forward_word buf mark; backward_word buf mark;
        Text.insert text mark "\n" |> ignore
    with Not_found -> ()
    );
    remove_point text mark
@

<<function Simple.simplify>>=
let simplify text start point =
  let start = dup_point text start in
  let rec iter last_c =
    if start < point then
      let c = get_char text start in
      if c = ' ' || c = '\n' || c = '\t' then
        ( delete text start 1 |> ignore;
          iter ' ')
      else
      if last_c = ' ' then
        ( insert text start " " |> ignore;
          fmove text start 2;
          iter 'a')
      else
        ( fmove text start 1;
          iter 'a')
  in
  iter 'a';
  remove_point text start
@

<<constant Simple.line_comment>>=
let line_comment = Local.create_abstr "Fill_mode.line_comment"
@


<<function Simple.set_indent>>=
(* modify the indentation of (point) line. Does not modify point *)
let set_indent text point offset = 
  let curseur = dup_point text point in
  bmove text curseur (point_to_bol text curseur);
  let rec iter offset =
    let c = get_char text curseur in
    if offset > 0 then
      if c = ' ' then
        (fmove text curseur 1; iter (offset - 1))
      else
      if c = '\t' then
        (delete text curseur 1 |> ignore;
         iter offset)
      else
        (Text.insert text curseur (String.make offset ' '))
    else
    if c = ' ' || c='\t' then
      (Text.delete text curseur 1;
        iter 0)
  in
  iter offset;
  remove_point text curseur
@

<<function Simple.insert_special_char>>=
let insert_special_char frame =
  let key = !keypressed in
  let char = Char.chr key in
  if char >= 'a' && char <= 'z' then
    insert_char frame (Char.chr (key - 97))
  else
    insert_char frame (Char.chr (key - 65))
@

<<function Simple.next_hole>>=
(* a hole is two consecutive '^' chars *)
let next_hole frame = 
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  let text = buf.buf_text in
  let curseur = dup_point text point in
  while 
    not ((get_char text curseur = '^') && (fmove_res text curseur 1 = 1) &&
      (get_char text curseur = '^')) && (fmove_res text curseur 1 = 1) do () done;
  if get_char text curseur = '^' then
    (bmove text curseur 1;
      delete text curseur 2;
      goto_point text point curseur);
  remove_point text curseur
@

<<function Simple.insert_structure>>=
let insert_structure s frame =
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  let text = buf.buf_text in
  insert text point s;
  next_hole frame
@

<<function Simple.install_structures>>=
let install_structures buf list =
  List.iter (
    fun (key, s) ->
      Keymap.add_binding buf.buf_map key (insert_structure s)
  ) list
@

<<type Simple.parameter>>=
type parameter =   (string * ((string -> Obj.t) * (Obj.t -> string) * 
      Obj.t option_record))
@

<<constant Simple.parameters_var>>=
let parameters_var = Local.create_abstr "parameters"
@

<<function Simple.add_parameter>>=
let add_parameter location (name : string) (input : string -> 'a) 
  (print : 'a -> string) (param : 'a option_record) =
  let (input : string -> Obj.t) = Obj.magic input in
  let (print : Obj.t -> string) = Obj.magic print in
  let (param : Obj.t option_record) = Obj.magic param in
  set_global location parameters_var (
    (name, (input, print, param)) :: 
    (try get_global location parameters_var with _ -> []))
@

<<function Simple.add_option_parameter>>=
let add_option_parameter location option =
  add_parameter location (shortname option)
  (fun s -> from_value (get_class option) (Value s))
  (fun v -> 
      match to_value (get_class option) v with
        Value s -> s
      | _ -> failwith "Unable to print option") option
@

<<constant Simple.all_params>>=
let all_params = ref None
@

<<function Simple.all_parameters>>=
let all_parameters frame _ =
  let parameters = try get_global frame.frm_location parameters_var with _ -> []
  in
  match !all_params with
    Some (f,l) when f == parameters -> l
  | _ ->
      let list = List.map fst parameters in
      all_params := Some (parameters, list);
      list
@

<<toplevel Simple._1>>=
let _ =
  define_buffer_action "overwrite_mode" 
    (fun buf -> 
      let mode = overwrite_mode in
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode);

  Efuns.add_start_hook (fun location ->
      let gmap = location.loc_map in
      (* unhightlight region *)
      add_hook location Top_window.handle_key_start_hook unhightlight;      
      (* standard chars *)
      for key = 32 to 127 do
        Keymap.add_binding gmap [NormalMap, key] self_insert_command
      done;
      (* special for AZERTY keyboards *)
      Array.iter (fun (key, char) ->
          Keymap.add_binding gmap [NormalMap, key] (char_insert_command char)
      ) [| 
(*
        (XK.xk_eacute, '');
        (XK.xk_egrave, '');
        (XK.xk_ccedilla, '');
        (XK.xk_agrave, '');
        (XK.xk_ugrave, '');
        (XK.xk_mu, ''); 
        (XK.xk_sterling, '');
        (XK.xk_section, '');
        (XK.xk_degree,  '');
*)
        |];
      let c_q = (ControlMap, Char.code 'q') in
      (* Keymap.add_prefix gmap [c_q]; *)
      for key = 65 to 65+25 do
        Keymap.add_binding gmap [c_q;ControlMap, key] insert_special_char;
      done;
      for key = 97 to 97+25 do
        Keymap.add_binding gmap [c_q;ControlMap, key] insert_special_char;
      done;
      Keymap.add_binding gmap [NormalMap, XK.xk_Pointer_Drag1]
        mouse_drag_region;
      Keymap.add_interactive (location.loc_map) "fondamental-mode" 
        (fun frame -> Ebuffer.set_major_mode frame.frm_buffer 
            Ebuffer.fondamental_mode);
      set_global location line_comment ""
  )
@


%-------------------------------------------------------------

<<features/simple.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Options
open Xtypes
open Efuns
open Text
open Frame
open Top_window

<<function Simple.string_to_modifier>>
  
<<function Simple.modifier_to_string>>
      
<<constant Simple.name_to_keysym>>
  
<<function Simple.value_to_keysym>>
      
<<function Simple.keysym_to_value>>
  
<<function Simple.value_to_key>>
  
<<function Simple.key_to_value>>
      
<<constant Simple.key_option>>

<<constant Simple.binding_option>>

<<function Simple.insert_string>>

  
<<constant Simple.single_char>>
<<function Simple.insert_char>>

<<function Simple.insert_return>>

<<function Simple.previous_char>>

<<function Simple.unset_attr>>
  
<<function Simple.insert_at_place>>


<<constant Simple.overwrite_mode>>
  
  
<<function Simple.self_insert_command>>
    
<<function Simple.char_insert_command>>

<<function Simple.move_backward>>

<<function Simple.move_forward>>

<<function Simple.begin_to_point>>

<<function Simple.point_to_end>>

<<function Simple.line_size>>

<<function Simple.beginning_of_line>>

<<function Simple.end_of_line>>

<<function Simple.forward_line>>

<<function Simple.backward_line>>


<<constant Simple.kill_size>>
<<constant Simple.kill_max>>
<<constant Simple.kill_ring>>
<<constant Simple.last_kill>>
<<constant Simple.last_insert>>

<<function Simple.kill_string>>


<<function Simple.kill_text>>

<<function Simple.kill_end_of_line>>

<<function Simple.kill_eol>>

<<function Simple.kill_bol>>

<<function Simple.insert_killed>>

<<function Simple.insert_next_killed>>

<<function Simple.format_to>>

<<function Simple.format_to_string>>


<<function Simple.in_next_word>>

<<function Simple.in_prev_word>>


<<function Simple.to_begin_of_word>>

<<function Simple.to_end_of_word>>

<<function Simple.to_frame>>

<<function Simple.backward_word>>

<<function Simple.forward_word>>

<<function Simple.beginning_of_word>>

<<function Simple.end_of_word>>

<<function Simple.current_word>>

<<function Simple.current_word (features/simple.ml)>>

  
  
<<function Simple.dirname>>

<<function Simple.buffer_list>>


<<function Simple.delete_char>>

<<function Simple.delete_backspace_char>>

<<function Simple.hungry_char>>

<<function Simple.hungry_electric_delete>>

(*
     let move_backward frame =
   Functions.move_backward frame 1; ()

let move_forward frame = 
  Functions.move_forward frame 1; () 
*) 
  
<<function Simple.forward_screen>>

<<function Simple.backward_screen>>

<<function Simple.scroll_line>>

<<function Simple.recenter>>

<<function Simple.end_of_file>>

<<function Simple.begin_of_file>>

<<function Simple.delete_backward_word>>

<<function Simple.delete_forward_word>>

<<function Simple.undo>>

<<function Simple.kill_region>>


<<function Simple.mouse_set_frame>>
 
<<constant Simple.highlighted>>
<<constant Simple.highlight_bit>>

<<function Simple.unhightlight_region>>

<<function Simple.hightlight_region>>

<<constant Simple.highlighted_chars>>

<<function Simple.unhightlight>>
  
<<function Simple.highlight>>


<<constant Simple.htmlp>>
<<function Simple.is_paren_end>>
<<function Simple.is_paren_begin>>

<<function Simple.highlight_paren>>
  
  
<<function Simple.mouse_drag_region>>

<<function Simple.mouse_yank_at_click>>


<<function Simple.mouse_save_then_kill>>

<<function Simple.next_buffer>>

<<function Simple.kill_buffer>>

<<function Simple.color>>

<<function Simple.point_at_mark>>


<<function Simple.on_word>>
  
<<function Simple.transpose_words>>


<<function Simple.transpose_chars>>


<<function Simple.backward_paragraph>>

<<function Simple.forward_paragraph>>


<<function Simple.electric_insert_space>>

<<function Simple.simplify>>

<<constant Simple.line_comment>>

<<function Simple.fill_paragraph>>
  
<<function Simple.set_indent>>

<<function Simple.insert_special_char>>

<<function Simple.next_hole>>

<<function Simple.insert_structure>>

<<function Simple.install_structures>>
  
open Options

<<type Simple.parameter>>
  
<<constant Simple.parameters_var>>
  
<<function Simple.add_parameter>>

<<function Simple.add_option_parameter>>
  
<<constant Simple.all_params>>
<<function Simple.all_parameters>>

  
<<toplevel Simple._1>>
  
@

%  (*
%external id : 'a -> 'a = "%identity"
%let add_string_parameter location name param = 
%  add_parameter location name id id param
%let add_int_parameter location name param = 
%  add_parameter location name int_of_string string_of_int param
%let add_float_parameter location name param = 
%  add_parameter location name float_of_string string_of_float param
%let add_bool_parameter location name param = 
%  add_parameter location name bool_of_string string_of_bool param
%    *)



\subsection*{[[features/complexe.ml]]}
% used to be complex.ml, but conflict with stdlib

<<function Complex.save_buffers_and_action>>=
let rec save_buffers_and_action frame buffers action =
  match buffers with
    [] -> let () = action frame in ()
  | (_,buf) :: buffers ->
      let text = buf.buf_text in
      if buf.buf_last_saved = version text  ||
        buf.buf_name.[0] = '*'
      then
        save_buffers_and_action frame buffers action
      else
      let map = Keymap.create () in
      let request = Printf.sprintf "Save buffer %s ? (y,n,!,a)" buf.buf_name
      in
      let yes mini_frame =
        Minibuffer.kill mini_frame frame;
        Ebuffer.save buf;
        save_buffers_and_action frame buffers action
      in
      let no mini_frame =
        Minibuffer.kill mini_frame frame;
        save_buffers_and_action frame buffers action; ()
      in
      let action_immediately mini_frame = 
        Minibuffer.kill mini_frame frame;
        let () = action mini_frame in ()
      in
      let abort mini_frame =
        Minibuffer.kill mini_frame frame
      in
      Keymap.add_binding map [NormalMap, Char.code 'y'] yes;
      Keymap.add_binding map [NormalMap, Char.code 'Y'] yes;
      Keymap.add_binding map [NormalMap, Char.code 'n'] no;
      Keymap.add_binding map [NormalMap, Char.code 'N'] no;
      Keymap.add_binding map [NormalMap, Char.code '!'] action_immediately;
      Keymap.add_binding map [NormalMap, Char.code 'a'] abort;
      Keymap.add_binding map [NormalMap, Char.code 'A'] abort;
      Keymap.add_binding map [ControlMap, Char.code 'g'] abort;
      Minibuffer.create frame map request |> ignore
@

<<constant Complex.buf_mtime>>=
let buf_mtime = Local.create "buf_mtime" string_of_float float_of_string
@

<<function Complex.update_time>>=
let update_time buf =
  try
    match buf.buf_filename with
      None -> ()
    | Some file ->
        let st = Unix.lstat file in
        if st.st_kind = S_REG then begin
            set_local buf buf_mtime st.st_mtime;
          end
  with _ -> ()
@

<<function Complex.reload>>=
let reload frame = 
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  match buf.buf_filename with
    None -> ()
  | Some file ->
      let inc = open_in file in
      let s = read_string inc in
      close_in inc;
      let point = frame.frm_point in
      let pos = Text.get_position text point in
      Text.clear buf.buf_text;
      Text.insert_at_end text s;
      Text.set_position text point pos;
      List.iter (fun f -> f buf) buf.buf_major_mode.maj_hooks;
      List.iter (fun minor_mode -> List.iter
          (fun f -> f buf) minor_mode.min_hooks) buf.buf_minor_modes;
      Frame.status_modified frame false 
@

<<function Complex.check_file>>=
let check_file frame =
  try
    let buf = frame.frm_buffer in
    match buf.buf_filename with
      None -> ()
    | Some file ->
        let st = Unix.lstat file in
        if st.st_kind = S_REG then
          try
            let time = get_local buf buf_mtime in
            set_local buf buf_mtime st.st_mtime;
            if time <> st.st_mtime then
              ignore (select_yes_or_no frame 
                  (Printf.sprintf 
                    "%s changed on disk; reload (y/n) ?" 
                    buf.buf_name) (fun bool ->
                    if bool then reload frame else
                      Frame.status_modified frame true
                      ))
          with _ -> 
              set_local buf buf_mtime st.st_mtime
  with _ -> ()
@









<<function Complex.change_font>>=
let change_font frame =
  Minibuffer.create_return 
    frame (Keymap.create ()) "Find font: " "fixed"
    (fun old_frame name ->
      let window = frame.frm_window in
      let _top_window = Window.top window in
      (*WX_xterm.change_font xterm name*)
      failwith "Complex.change_font: TODO"
  ) |> ignore
@

<<function Complex.color>>=
let color buf regexp strict attr =
  let text = buf.buf_text in
  let point = Text.add_point text in
  try
    while true do
      let len = Text.search_forward text regexp point in
      let before =
        if Text.bmove_res text point 1 = 1 then
          (let c = Text.get_char text point in
            Text.fmove text point (len+1);c)
        else
          (let c = Text.get_char text point in
            Text.fmove text point (len+1); c)
      in
      let after = Text.get_char text point in
      if not (strict && (buf.buf_syntax_table.(Char.code before) ||
            buf.buf_syntax_table.(Char.code after))) then
        begin
          bmove text point len;
          Text.set_attr text point len attr;
          fmove text point len;
          ()
        end
    done
  with
    Not_found -> 
      Text.remove_point text point;
      buf.buf_modified <- buf.buf_modified + 1
@

<<constant Complex.display_hist>>=
(*let display_hist = ref []*)
@

<<function Complex.open_display>>=
let open_display frame =
failwith "Complex.open_display: TODO"
(*
  select frame "open_display :" display_hist ""
    (fun _ -> [])
  (fun s -> s)
  (fun name -> 
      let top_window = Window.top frame.frm_window in
      let location = top_window.top_location in
      let dpy_oo = new WX_display.t name in
      let root_oo = new WX_root.t dpy_oo 0 in
      let display = WX_xterm.create_display root_oo
          location.loc_colors_names location.loc_fonts_names
        in
      Top_window.create location display |> ignore
   )
*)
@



<<function Complex.get_pos>>=
let get_pos frame =
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  let text = buf.buf_text in
  let top_window = Window.top frame.frm_window in
  Top_window.message top_window 
    (Printf.sprintf "Char position %d" 
      (get_position text point))
@


<<constant Complex.umask>>=
let umask = 
  let old = Unix.umask 0 in 
  Unix.umask old |> ignore;
  old
@

<<constant Complex.file_perm>>=
let file_perm = Local.create "file_perm" string_of_int int_of_string
@

<<function Complex.mkdir>>=
let mkdir frame =
  select_filename frame "Make directory: "
    (fun str -> 
      let file_perm = try get_var frame.frm_buffer file_perm with _ -> 
            0x1ff land (lnot umask) in
      Unix.mkdir str file_perm)
@


<<constant Complex.variable_hist>>=
let variable_hist = ref []
@

<<constant Complex.value_hist>>=
let value_hist = ref []
@

<<constant Complex.all_vars>>=
let all_vars = ref None
@

<<function Complex.all_variables>>=
let all_variables frame _ =
  let buf = frame.frm_buffer in
  let location = buf.buf_location in
  match !all_vars with
    Some (f,l) when f == frame -> l
  | _ ->
      let list = (Local.list buf.buf_vars) @ (Local.list location.loc_vars) in
      all_vars := Some (frame, list);
      list
@

<<function Complex.set_local_variable>>=
let set_local_variable frame = 
  Select.select frame "set-local-variable : " variable_hist
    "" (all_variables frame) (fun s -> s) (fun variable ->
      Select.select_string frame (Printf.sprintf "%s : " variable)
      value_hist "" (fun value ->
          Local.input frame.frm_buffer.buf_vars variable value))
@

<<function Complex.set_global_variable>>=
let set_global_variable frame =
  Select.select frame "set-global-variable : " variable_hist
    "" (all_variables frame) (fun s -> s) (fun variable ->
      Select.select_string frame (Printf.sprintf "%s : " variable)
      value_hist "" (fun value ->
          Local.input frame.frm_location.loc_vars variable value))
@

<<function Complex.get_variable>>=
let get_variable frame = 
  Select.select frame "get-variable : " variable_hist
    "" (all_variables frame) (fun s -> s) (fun variable ->
      Top_window.mini_message frame 
        (Printf.sprintf "%s : %s" variable (
          let buf = frame.frm_buffer in
          try
            Local.print buf.buf_vars variable
          with _ ->
              Local.print buf.buf_location.loc_vars variable)))
@

<<constant Complex.parameters_hist>>=
let parameters_hist = ref []
@

<<function Complex.set_parameter>>=
let set_parameter frame = 
  let parameters = get_global frame.frm_location parameters_var in
  Select.select frame "set-parameter : " parameters_hist
    "" (all_parameters frame) (fun s -> s) (fun variable ->
      Select.select_string frame (Printf.sprintf "%s : " variable)
      value_hist "" (fun value ->
          let (input,print,param) = List.assoc variable parameters
          in
          param =:= input value))
@

<<function Complex.get_parameter>>=
let get_parameter frame =
  let parameters = get_global frame.frm_location parameters_var in  
  Select.select frame "get-parameter : " parameters_hist
    "" (all_parameters frame) (fun s -> s) (fun variable ->
      Top_window.mini_message frame 
        (Printf.sprintf "%s : %s" variable (
          let (input,print,param) = List.assoc variable parameters
          in
          print !!param)))
@


<<toplevel Complex._1>>=
let _ =
  Efuns.add_start_hook (fun location ->
      Keymap.add_interactive location.loc_map "make-directory" mkdir;
      Keymap.add_interactive location.loc_map "set-local-variable" 
        set_local_variable;
      Keymap.add_interactive location.loc_map "set-global-variable" 
        set_global_variable;
      Keymap.add_interactive location.loc_map "get-variable" get_variable;
      Keymap.add_interactive location.loc_map "set-parameter" set_parameter;
      Keymap.add_interactive location.loc_map "get-parameter" get_parameter;
      
  )
@


%-------------------------------------------------------------

<<features/complexe.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Unix
open Utils
open Efuns
open Text
open Frame
open Simple
open Select
open Interactive

<<function Complex.save_buffers_and_action>>

<<constant Complex.buf_mtime>>

<<function Complex.update_time>>
      
<<function Complex.reload>>
      
<<function Complex.check_file>>
    
<<function Complex.exit_efuns>>

<<function Complex.save_some_buffers>>

<<function Complex.load_buffer>>

<<function Complex.insert_file>>

<<function Complex.write_buffer>>

<<function Complex.save_buffer>>

<<function Complex.window_load_buffer>>

<<function Complex.change_buffer>>

<<function Complex.window_change_buffer>>

<<function Complex.change_font>>

<<function Complex.color>>

<<constant Complex.display_hist>>
<<function Complex.open_display>>

<<function Complex.goto_line>>

<<function Complex.goto_char>>


<<function Complex.get_pos>>

<<function Complex.mark_at_point>>

<<constant Complex.umask>>
  
<<constant Complex.file_perm>>
<<function Complex.mkdir>>

<<constant Complex.eval_history>>
<<function Complex.eval>>

<<constant Complex.variable_hist>>
<<constant Complex.value_hist>>
  
<<constant Complex.all_vars>>
<<function Complex.all_variables>>
  
<<function Complex.set_local_variable>>
  
<<function Complex.set_global_variable>>
  
<<function Complex.get_variable>>

open Options
  
<<constant Complex.parameters_hist>>
  
<<function Complex.set_parameter>>
  
<<function Complex.get_parameter>>

<<constant Complex.up_buffer>>
  
<<function Complex.down_buffer>>
<<function Complex.up_buffer>>
  
<<function Complex.left_buffer>>

<<function Complex.right_buffer>>
  
  
<<toplevel Complex._1>>
  
@


\subsection*{[[features/system.ml]]}

<<function System.open_process>>=
let open_process cmd =
  let (in_read, in_write) = pipe() in
  let (out_read, out_write) = pipe() in
  let inchan = in_channel_of_descr in_read in
  let outchan = out_channel_of_descr out_write in
  match fork() with
    0 ->
      if out_read <> stdin then begin
          dup2 out_read stdin; close out_read end;
      if in_write <> Unix.stdout ||  in_write <> Unix.stderr then begin
          if in_write <> Unix.stdout then dup2 in_write stdout;
          if in_write <> Unix.stderr then dup2 in_write stderr; 
          close in_write end;
      List.iter close [in_read;out_write];
      execv "/bin/sh" [| "/bin/sh"; "-c"; cmd |];
      exit 127
  | pid -> 
      Unix.close out_read;
      Unix.close in_write;
      (pid,inchan, outchan)
@

<<[[Efuns.buffer]] other fields>>=
mutable buf_sync : bool;
@

<<[[Frame.update()]] if buf sync>>=
if buf.buf_sync && buf.buf_modified <> frame.frm_last_buf_updated 
then Text.set_position text point (Text.size text); 
@

<<function System.system>>=
let system buf_name location cmd end_action =
  let (pid,inc,outc) = open_process cmd in
  let text = Text.create "" in
  let curseur = Text.add_point text in
  let buf = Ebuffer.create location buf_name None text (Keymap.create ()) in
  buf.buf_sync <- true;
  let _ins = Unix.descr_of_in_channel inc in
  let _tampon = String.create 1000 in
  let active = ref true in
(*
  Thread.add_reader ins
    (function () ->
        let pos,str = Text.delete_res text curseur
            (Text.point_to_eof text curseur) in
        let len = input inc tampon 0 1000 in
        Mutex.lock location.loc_mutex;
        if len = 0 then
          let pid,status = waitpid [WNOHANG] pid in
          begin
            match status with 
              WEXITED s -> Text.insert_at_end text 
                  (Printf.sprintf "Exited with status %d\n" s); 
                close_in inc;
                close_out outc;
                (try end_action buf s with _ -> ())
            | _ -> Text.insert_at_end text "Broken pipe" 
          end;
          Text.set_position text curseur (Text.size text);
          active := false;
          (* redraw screen *)
          update_display location;
          WX_xterm.update_displays ();
          Mutex.unlock location.loc_mutex;
          Thread.remove_reader ins; (* Kill self *)
        else
          Text.insert_at_end text (String.sub tampon 0 len);
        Text.set_position text curseur (Text.size text);
        Text.insert text curseur str;
        buf.buf_modified <- buf.buf_modified +1;
        (* redraw screen *)
        update_display location;
        WX_xterm.update_displays ();
        Mutex.unlock location.loc_mutex
  );
*)
  failwith "System.system: TODO";
  let lmap = buf.buf_map in
  Keymap.add_binding lmap [NormalMap, XK.xk_Return]
    (fun frame ->
      let point = frame.frm_point in
      Text.insert text point "\n";
      Text.fmove text point 1;
      if !active then (* to avoid a segmentation fault in Ocaml *)
        let str = Text.sub text curseur 
            (Text.point_to_eof text curseur) in
        Text.set_position text curseur (Text.size text);
          (* synchronize viewpoint *)
        output outc str 0 (String.length str);
        flush outc
  );
  buf.buf_finalizers <- 
    (fun () -> 
      (try 
          Unix.kill pid Sys.sigkill;
          let _,_ = waitpid [] pid in ()
        with _ -> ());
      (*Concur.Thread.remove_reader ins*) failwith "System.system: TODO 2"
    )
  :: buf.buf_finalizers;
  buf
@

<<function System.start_command>>=
let start_command buf_name window cmd =
  let top_window = Window.top window in
  let location = top_window.top_location in
  let buf = system buf_name location cmd (fun buf status -> ()) in
  let frame = Frame.create window None buf in
  frame
@

<<constant System.shell_hist>>=
let shell_hist = ref []
@



%-------------------------------------------------------------

<<features/system.ml>>=
open Efuns
open Unix
(*open Concur*)
(*open ThreadUnix*)
open Select
open Simple
open Top_window
open Multi_frames

<<function System.open_process>>

<<function System.system>>

<<function System.start_command>>

<<constant System.shell_hist>>
<<function System.shell_command>>
  
@


\subsection*{[[features/select.ml]]}

<<[[Efuns.top_window]] other fields>>=
mutable top_second_cursor : frame option;
@

<<function Select.select_yes_or_no>>=
let select_yes_or_no frame request action =
  let top_window = Window.top frame.frm_window in
  let map = Keymap.create () in
  let yes_reply mini_frame = 
    Minibuffer.kill mini_frame frame;
    top_window.top_second_cursor <- None;
    action true
  in
  let no_reply  mini_frame = 
    Minibuffer.kill mini_frame frame;
    top_window.top_second_cursor <- None;
    action false
  in
  Keymap.add_binding map [NormalMap, Char.code 'y'] yes_reply;
  Keymap.add_binding map [NormalMap, Char.code 'Y'] yes_reply;
  Keymap.add_binding map [NormalMap, Char.code 'n'] no_reply;
  Keymap.add_binding map [NormalMap, Char.code 'N'] no_reply;
  let mini = Minibuffer.create frame map request in
  mini.frm_buffer.buf_map_partial <- false;
  mini
@

<<function Select.find_completion_frame>>=
let find_completion_frame frame =
  let location = frame.frm_buffer.buf_location in
  let buf = Ebuffer.default location "*Completions*" in
  Frame.find_buffer_frame location buf
@

<<function Select.display_completions>>=
let display_completions frame list =
  let top_window = Window.top frame.frm_window in
  if list = [] then
    Top_window.message top_window "No Completions"
  else
  let location = top_window.top_location in
  let rec iter list s =
    match list with
      [] -> s
    | [f] -> Printf.sprintf "%s\n%s" s f
    | f1::f2::tail  ->
        iter tail (Printf.sprintf "%s\n%-40s%s" s f1 f2)
  in
  let buf = Ebuffer.default location "*Completions*" in
  let text = buf.buf_text in
  Text.update text (iter list "Completions :");
  (try Frame.find_buffer_frame location buf
  with Not_found -> Frame.create_inactive (cut_frame frame) buf
  ) |> ignore
@

<<function Select.remove_completions>>=
let remove_completions frame =
  try
    let frame = find_completion_frame frame in
    remove_frame frame
  with
    Not_found -> ()
@

<<function Select.set_history>>=
let set_history map string history =
  let current = ref 0 in
  Keymap.add_binding map [NormalMap, XK.xk_Up]
    (fun mini_frame ->
      if !current = List.length !history then
        mini_message mini_frame "No previous line in history"
      else
      let ele = list_nth !current !history in
      incr current;
      let buf = mini_frame.frm_buffer in
      let text = buf.buf_text in
      Text.clear text;
      string := ele;
      insert_string mini_frame ele; ()
  );      
  Keymap.add_binding map [NormalMap, XK.xk_Down]
    (fun mini_frame ->
      if !current < 1 then
        mini_message mini_frame "No other line in history"
      else
        begin
          decr current;
          let ele = list_nth !current !history in
          let buf = mini_frame.frm_buffer in
          let text = buf.buf_text in
          Text.clear text;
          string := ele;
          insert_string mini_frame ele; ()
        end
  )
@

<<function Select.incremental_mini_buffer>>=
let incremental_mini_buffer frame ismap request default
    incremental_action action =
  let top_window = Window.top frame.frm_window in
  let incremental mini_frame =
    incremental_action frame (Text.to_string mini_frame.frm_buffer.buf_text)
  in
  let incremental_insert mini_frame =
    self_insert_command mini_frame;
    incremental mini_frame
  in
  for key = 32 to 127 do
    Keymap.add_binding ismap [NormalMap, key] incremental_insert
  done;
  Keymap.add_binding ismap [NormalMap, XK.xk_BackSpace] 
    (fun mini_frame -> 
      delete_backspace_char mini_frame;
      incremental mini_frame);
  top_window.top_second_cursor <- Some frame;
  Minibuffer.create_return frame ismap request default
    (fun frame str -> 
      top_window.top_second_cursor <- None;
      action frame str
  )
@

<<function Select.select>>=
let select frame request history start completion_fun prefix_fun action =
  let map = Keymap.create () in
  let string = ref "" in
  Keymap.add_binding map [ControlMap, Char.code 'g']
    (fun mini_frame -> 
      remove_completions mini_frame;
      Minibuffer.kill mini_frame frame);
  let completion = ref "_*NoCompletion*_" in
  let completions = ref [] in
  Keymap.add_binding map [NormalMap, XK.xk_Tab]
    (fun mini_frame ->
      if not(!completion == !string) then
        let text = mini_frame.frm_buffer.buf_text in
        completions := completion_fun !string;
        let suffix, n  = common_suffix
            !completions
            (prefix_fun !string) 
        in
        completion := !string;
        Text.insert text mini_frame.frm_point suffix;
        Text.fmove text mini_frame.frm_point (String.length suffix);
        (if n>1 then
            display_completions frame
              (Utils.completion !completions (prefix_fun !string));
        )
      else
(* can be improved, by displaying another part of the completion buffer *)
        display_completions frame
          (Utils.completion !completions (prefix_fun !string))
  );
  set_history map string history;
  let _ = 
    incremental_mini_buffer frame map request start
    (fun frame str -> 
        string := str;
    )
    (fun old_frame str -> 
        (match !history with
            hd :: _ when hd = str -> ()
          | _ ->
              if str <> "" then
                history := str :: !history);
        remove_completions frame;
        action str
    ) in
  ()
@

<<constant Select.file_hist>>=
let file_hist = ref []
@

<<constant Select.dont_complete>>=
let dont_complete = define_option ["avoid_filenames"] ""
    (list_option string_option) 
  [ ".*\\.o"; ".*\\.cm.";".*\\.cmxa";".*~";".*\\.a";"core";"\\..*"]
@

<<constant Select.dont_complete_regexps>>=
let dont_complete_regexps = ref ([],Str.regexp "")
@

<<function Select.dont_complete_regexp>>=
let dont_complete_regexp () =
  let (old,reg) = !dont_complete_regexps in
  if old == !!dont_complete then
    reg
  else
  let reg = Str2.regexp_from_list !!dont_complete in
  dont_complete_regexps := (!!dont_complete, reg);
  reg
@

<<function Select.avoid_completion>>=
let avoid_completion s =
  let bad_regexp = dont_complete_regexp () in
  not (Str.string_match bad_regexp s 0)
@

<<function Select.is_userdir>>=
let is_userdir string =
  let n = String.length string in
  (n > 1) && (string.[0] = '~') &&
  (try
      String.rindex string '/' |> ignore;
      false
   with Not_found -> true
   )
@

<<function Select.complete_filename>>=
let complete_filename frame good_file filename =
  if is_userdir filename 
  then (* Parse_file.users *) failwith "Select.complete_filename: TODO"
  else
  let filename = string_to_filename filename in
  let dirname = dirname frame filename in
  let file_list = Utils.file_list dirname in
  match file_list with
    a::b::_ -> 
      begin
        match 
          List.fold_left (fun list ele ->
              if good_file ele then ele :: list else list
          ) [] file_list
        with
          [] -> file_list 
            (* if no completion is OK, return files that should have 
          been avoided *)
        | list -> list
      end
  | _ -> file_list
@

<<function Select.select_file>>=
let select_file frame request history start action =
  let map = Keymap.create () in
  let string = ref "" in
  Keymap.add_binding map [ControlMap, Char.code 'g']
    (fun mini_frame -> 
      remove_completions mini_frame;
      Minibuffer.kill mini_frame frame);
  let completion = ref "_*NoCompletion*_" in
  let completions = ref [] in
  Keymap.add_binding map [NormalMap, XK.xk_Tab]
    (fun mini_frame ->
      if not(!completion = !string) then
        let text = mini_frame.frm_buffer.buf_text in
        completions := complete_filename frame avoid_completion !string;
        let suffix, n  = Utils.common_suffix
            !completions
            (Filename.basename !string) 
        in
        let suffix = 
          let s = !string ^ suffix in
          let len = String.length s in
          if len>0 && s.[len - 1] <> '/' then
            try
              let filename = string_to_filename s in
              let dirname = dirname frame filename in
              let basename = Filename.basename filename in
              let stat = Unix.stat (Filename.concat dirname basename) in
              match stat.Unix.st_kind with
                Unix.S_DIR -> suffix ^ "/"
              | _ -> suffix
            with
              _ -> suffix
          else
            suffix
        in
        completion := !string;
        Text.insert text mini_frame.frm_point suffix;
        Text.fmove text mini_frame.frm_point (String.length suffix);
        string := Text.to_string text;
        (if n>1 then
            display_completions frame
              (Utils.completion !completions (Filename.basename !string)))
      else
(* can be improved, by displaying another part of the completion buffer *)
        display_completions frame
          (Utils.completion !completions (Filename.basename !string))
  );
  set_history map string history;
  let _ = incremental_mini_buffer frame map request start
    (fun frame str -> 
      string := str;
  )
  (fun old_frame str -> 
      history := str :: !history;
      remove_completions frame;
      let str = string_to_filename str in
      action str
  ) in
  Keymap.add_binding map [NormalMap, XK.xk_Prior]
    (fun frame ->
      let frame = find_completion_frame frame in
      backward_screen frame);
  Keymap.add_binding map [NormalMap, XK.xk_Next]
    (fun frame ->
      let frame = find_completion_frame frame in
      forward_screen frame);
  Keymap.add_binding map [NormalMap, Char.code '~']
    (fun frame ->
      let buf = frame.frm_buffer in
      let text = buf.buf_text in
      let point = frame.frm_point in
      kill_bol buf point;
      self_insert_command frame;      
      string := to_string text
  );
  Keymap.add_binding map [NormalMap, Char.code '/']
    (fun frame ->
      let buf = frame.frm_buffer in
      let text = buf.buf_text in
      let point = frame.frm_point in
      if bmove_res text point 1 = 1 then
        ( let c = get_char text point in
          fmove text point 1;
          if c = '/' then
            kill_bol buf point);
      self_insert_command frame;
      string := to_string text            
  );
  ()
@

<<function Select.select_filename>>=
let select_filename frame request action =
  let curdir = Frame.current_dir frame in
  select_file frame request file_hist (Utils.filename_to_string curdir) action
@

<<constant Select.prev_buffers>>=
let prev_buffers = ref []
@

<<constant Select.next_default>>=
let next_default = ref ""
@

<<function Select.set_previous_frame>>=
let set_previous_frame frame = 
  let name = frame.frm_buffer.buf_name in
  next_default := name;
  prev_buffers := name :: (Utils.list_removeq !prev_buffers name)
@

<<function Select.get_previous_frame>>=
let get_previous_frame () = !next_default
@

<<constant Select.buf_hist>>=
let buf_hist = ref []
@

<<function Select.select_buffer>>=
let select_buffer frame request default action =
  select frame (request^"(default :"^ default ^ ") ") buf_hist ""
    (fun _ -> buffer_list frame) (fun s ->s) 
  (fun str ->
      let str = 
        if str = "" then default else str in
      action str)
@

<<function Select.select_string>>=
let select_string frame request history default action =
  let map = Keymap.create () in
  let string = ref "" in
  set_history map string history;
  Minibuffer.create_return frame map request default
    (fun _ str -> 
      (match !history with
          hd :: _ when hd = str -> ()
        | _ -> if str <> "" then
              history := str :: !history);
      action str
    ) |> ignore
@

<<function Select.simple_select>>=
let simple_select frame request action =
  let map = Keymap.create () in
  Minibuffer.create_return frame map request "" (fun _ str -> action str) 
   |> ignore
@


%-------------------------------------------------------------

<<features/select.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Options
open Efuns
open Text
open Frame
open Simple
open Top_window
open Multi_frames
open Utils

let string_to_filename str = str

<<function Select.select_yes_or_no>>

<<function Select.find_completion_frame>>

<<function Select.display_completions>>

<<function Select.remove_completions>>

<<function Select.set_history>>

<<function Select.incremental_mini_buffer>>

<<function Select.select>>
  
  (****************************************************
  
               Filename selection
  
  ****************************************************)

<<constant Select.file_hist>>

<<constant Select.dont_complete>>
  
<<constant Select.dont_complete_regexps>>
<<function Select.dont_complete_regexp>>

<<function Select.avoid_completion>>

<<function Select.is_userdir>>

<<function Select.complete_filename>>

<<function Select.select_file>>

<<function Select.select_filename>>


  (****************************************************
  
               Other selection
  
  ****************************************************)

<<constant Select.prev_buffers>>
<<constant Select.next_default>>
<<function Select.set_previous_frame>>
<<function Select.get_previous_frame>>

<<constant Select.buf_hist>>
<<function Select.select_buffer>>



<<function Select.select_string>>


<<function Select.simple_select>>
  
  
@


\subsection*{[[features/search.ml]]}

<<toplevel Search._1>>=
(*let _ = Time.init ()*)
@

<<constant Search.case_fold>>=
let case_fold = ref false
@

<<function Search.to_regexp>>=
let to_regexp flag str =
  match flag with
    Regexp ->
      (if !case_fold then
          Str.regexp_case_fold 
        else
          Str.regexp) str
  | RegexpString ->
      (if !case_fold then
          Str.regexp_string_case_fold
        else
          Str.regexp_string) str
@

<<type Search.query>>=
type query = NoQuery | Query of frame * string
@

<<function Search.replace>>=
let replace flag frame query str repl =
  let top_window = Window.top frame.frm_window in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let regexp = to_regexp flag str in
  let session = start_session text in
  let n = ref 0 in
  try
    let last_pos = ref (Text.get_position text point) in
    match flag,query with
      Regexp, NoQuery ->
        while not (check_abort frame) do
          let len = Text.search_forward text regexp point in
          let pos = Text.get_position text point in
          if pos = !last_pos then 
            (if Text.fmove_res text point 1 = 0 then raise Exit)
          else begin
              last_pos := pos;
              let result = Text.replace_matched text repl in
              let (_,_matched) = delete_res text point len in
              insert text point result;
              fmove text point (String.length result);
              n := !n + 1
            end
        done
    | RegexpString, NoQuery ->
        let delta = String.length repl in
        while not (check_abort frame) do
          let len = Text.search_forward text regexp point in
          let pos = Text.get_position text point in
          if pos = !last_pos then 
            (if Text.fmove_res text point 1 = 0 then raise Exit)
          else begin
              last_pos := pos;
              delete text point len;
              insert text point repl;
              Text.fmove text point delta;
              n := !n + 1
            end
        done
    | Regexp, Query (frame,request) ->
        let top_window = Window.top frame.frm_window in
        let rec iter () =
          let len = Text.search_forward text regexp point in
          let pos = Text.get_position text point in
          if pos = !last_pos then begin
              (if Text.fmove_res text point 1 = 0 then raise Exit);
              iter ();
            end
          else begin
              last_pos := pos;
              top_window.top_second_cursor <- Some frame;
              let _ = select_yes_or_no frame request 
                  (fun yes ->
                    if yes then
                      begin
                        let result = Text.replace_matched text repl in
                        let (_,_matched) = delete_res text point len in
                        insert text point result;
                        fmove text point (String.length result);
                        n := !n + 1
                      end;
                    iter ()) in
              ()
            end
        in
        iter ()
    | RegexpString, Query (frame,request) ->
        let delta = String.length repl in
        let top_window = Window.top frame.frm_window in
        let rec iter () =
          let len = Text.search_forward text regexp point in
          let pos = Text.get_position text point in
          if pos = !last_pos then begin
              (if Text.fmove_res text point 1 = 0 then raise Exit);
              iter ();
            end
          else begin
              last_pos := pos;
              top_window.top_second_cursor <- Some frame;
              let _ = select_yes_or_no frame request 
                  (fun yes ->
                    if yes then
                      begin
                        delete text point len;
                        insert text point repl;
                        Text.fmove text point delta;
                        n := !n + 1
                      end;
                    iter ()) 
              in
              ()
            end
        in
        iter ()
  with
    Not_found ->
      commit_session text session;
      Top_window.message top_window
        ("Replace "^(string_of_int !n)^" occurences")
  | _ ->
      commit_session text session
@

<<function Search.no_query>>=
let no_query f = f true
@

<<function Search.query>>=
let query frame request f =
  let top_window = Window.top frame.frm_window in
  top_window.top_second_cursor <- Some frame;
  select_yes_or_no frame request f |> ignore
@

<<constant Search.string_history>>=
let string_history = ref []
@

<<function Search.select_replace>>=
let select_replace frame request action =
  select_string frame request string_history "" action 
@


<<constant Search.library_regexp>>=
let library_regexp = Str.regexp ".*\\.cm[oa]"
@

<<function Search.library_file>>=
let library_file str =
  Str.string_match library_regexp str 0
@

<<function Search.select_lib_filename>>=
let select_lib_filename frame request action =
  select frame request file_hist (current_dir frame)
  (complete_filename frame library_file)
  Filename.basename action
@


%-------------------------------------------------------------

<<features/search.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Top_window
open Efuns
open Text
open Frame
open Simple
open Select
    
<<toplevel Search._1>>

<<constant Search.case_fold>>
<<function Search.to_regexp>>

<<type Search.query>>

<<function Search.replace>>


<<function Search.no_query>>
<<function Search.query>>

<<constant Search.string_history>>
<<function Search.select_replace>>

<<function Search.replace_string>>

<<function Search.query_replace_string>>

<<function Search.replace_regexp>>

<<function Search.query_replace_regexp>>

<<constant Search.library_regexp>>
<<function Search.library_file>>

<<function Search.select_lib_filename>>

<<constant Search.last_search>>
<<function Search.isearch>>




<<constant Search.isearch_forward_regexp>>
<<constant Search.isearch_forward>>
<<constant Search.isearch_backward>>
<<constant Search.isearch_backward_regexp>>
  
@


\subsection*{[[features/interactive.ml]]}




<<function Interactive.exec_interactive>>=
let exec_interactive interactives frame name =
  try
    let f, key = List.assoc name interactives in
    begin
      match key with
        None -> ()
      | Some key_list ->
          let top_window = Window.top frame.frm_window in
          Top_window.message top_window
            ("you can run "^name^" by typing "^
              (Keymap.print_key_list (List.rev key_list)))
    end;
    f frame
  with
    Not_found -> 
      let top_window = Window.top frame.frm_window in
      Top_window.message top_window ("No interactive command "^name)
@



%-------------------------------------------------------------

<<features/interactive.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Efuns
open Text
open Frame
open Simple
open Select
open Keymap

  
<<function Interactive.create_bindings>>

<<constant Interactive.meta_hist>>

<<function Interactive.buf_interactives>>
  
<<function Interactive.exec_interactive>>
      
<<function Interactive.call_interactive>>
@


\subsection*{[[features/abbrevs.ml]]}

%-------------------------------------------------------------

<<features/abbrevs.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

(*
Expansion des abbreviations: 
deux fonctions principales: 
- "dabbrev_expand": expansion des mots a partir de mots trouves dans les
     buffers (binding normap "M-/").
- "expand_sabbrev": expansion des mots a partir d'abbreviations trouvees
    dans des tables associees au buffer (variable "abbrev_table") 
    (binding normal: un caractere de fin de mot (espace,newline,..))
*)

open Efuns
open Text
open Frame
open Simple
open Interactive

<<function Abbrevs.escaped>>
  
<<constant Abbrevs.dabbrev_buf>>
<<function Abbrevs.dabbrev_expand>>

<<constant Abbrevs.abbrev_table>>
  
<<function Abbrevs.expand_sabbrev>>

<<toplevel Abbrevs._1>>
  
@


\subsection*{[[features/multi_frames.ml]]}

<<function Multi_frames.cut_frame>>=
let cut_frame frame =
  let window = frame.frm_window in
  if window.win_height > 3 then
    let h = window.win_height / 2 in
    let w1 = Window.create false
        (Window window) window.win_xpos window.win_ypos
        window.win_width h in
    let w2 = Window.create false (Window window) window.win_xpos 
        (window.win_ypos + h) 
      window.win_width (window.win_height - h) in
    window.win_down <- VComb (w1,w2);
    Frame.install w1 frame;
    w2 
  else
    window
@

<<function Multi_frames.remove_frame>>=
let remove_frame frame =
  if frame.frm_mini_buffer = None then
    let window = frame.frm_window in
    match window.win_up with
      TopWindow _ -> ()
    | Window upwin ->
        Window.prev (Frame.install upwin) window
@


%-------------------------------------------------------------

<<features/multi_frames.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)


open Efuns
open Text
open Frame
open Top_window
  

<<function Multi_frames.cut_frame>>

<<function Multi_frames.remove_frame>>

<<function Multi_frames.v_cut_frame>>

<<function Multi_frames.h_cut_frame>>

<<function Multi_frames.delete_frame>>

<<function Multi_frames.one_frame>>
      
      
<<function Multi_frames.next_frame>>
@


\subsection*{[[features/compil.ml]]}

<<constant Compil.compilation_frame>>=
let compilation_frame = ref None
@

<<type Compil.error>>=
type error = {
(* error location *)    
    err_filename : string;
    err_line : int;
    err_begin : int;
    err_end : int;
(* error message *)
    err_msg : int;
  }
@

<<constant Compil.c_error_regexp>>=
let c_error_regexp = define_option ["compil"; "error_regexp"] "" regexp_option
  (string_to_regex "^\\([^:\n]+\\):\\([0-9]+\\):.*$")
@
%$

<<function Compil.c_find_error>>=
let c_find_error text error_point =
  let groups = 
    Text.search_forward_groups text (snd !!c_error_regexp)
      error_point 2 in
  let error =
    {  
      err_msg = Text.get_position text error_point;
      err_filename = groups.(0);
      err_line = (int_of_string groups.(1)) - 1;
      err_begin = 0;
      err_end = 0;
    } in
  Text.fmove text error_point 1;
  error
@

<<constant Compil.find_error>>=
let find_error = Local.create_abstr "find_error"
@

<<constant Compil.default_error>>=
let default_error = ref c_find_error
@


<<constant Compil.compile_find_makefile>>=
let compile_find_makefile = define_option ["compil";"find_makefile"] ""
    bool_option true
@

<<constant Compil.make_command>>=
let make_command = define_option ["compil";"make_command"] ""
    string_option "make -k"
@

<<constant Compil.make_hist>>=
let make_hist = ref [!!make_command]
@


<<function Compil.set_compilation_buffer>>=
let set_compilation_buffer frame comp_buf cdir =
  (*let error_point = add_point comp_buf.buf_text in*)
  let window =
    match !compilation_frame with
      None -> 
        cut_frame frame
    | Some (frame,point, _) ->
        remove_point frame.frm_buffer.buf_text point;  
        if frame.frm_killed 
        then cut_frame frame 
        else frame.frm_window
  in
  let error_point = add_point comp_buf.buf_text in
  let comp_frame = Frame.create window None comp_buf in
  compilation_frame := Some (comp_frame, error_point, cdir)
@

<<constant Compil.grep_command>>=
let grep_command = define_option ["compil"; "grep_command"] "" string_option
    "grep -n"
@

<<constant Compil.grep_hist>>=
let grep_hist = ref [""]
@



%-------------------------------------------------------------

<<features/compil.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Options
open Efuns
open Text
open Frame
open Simple
open Select
open Multi_frames  

<<constant Compil.compilation_frame>>

<<type Compil.error>>

<<constant Compil.c_error_regexp>>

<<function Compil.c_find_error>>

<<constant Compil.find_error>>
<<constant Compil.default_error>>
  
<<function Compil.next_error>>

<<constant Compil.compile_find_makefile>>
  
<<constant Compil.make_command>>
  
<<constant Compil.make_hist>>
<<function Compil.compile>>

<<function Compil.set_compilation_buffer>>
  
<<constant Compil.grep_command>>
  
<<constant Compil.grep_hist>>
<<function Compil.grep>>
@


\section{[[graphics/]]}

\subsection*{[[graphics/top_window.ml]]}


<<function Top_window.dummy_action>>=
let dummy_action frame = ()
@

<<[[Efuns.frame]] other fields>>=
mutable frm_prefix : key list;
mutable frm_repeat_action : int;
mutable frm_last_action : action;
@
% for undo?

<<[[Top_window.try_map()]] set repeat action>>=
frame.frm_repeat_action <- 
  if (f == frame.frm_last_action) 
  then frame.frm_repeat_action + 1
  else 0;
@

<<[[Top_window.try_map()]] set last action>>=
frame.frm_last_action <- f
@


<<function Top_window.set_cursor_on>>=
let set_cursor_on top_window frame = 
  Frame.set_cursor frame;
  if frame.frm_cursor.[0] <> '\000' then
    let graphic = Window.backend top_window in
    graphic.Xdraw.draw_string
      (frame.frm_xpos + frame.frm_cursor_x-frame.frm_x_offset)
    (frame.frm_ypos + frame.frm_cursor_y) 
    frame.frm_cursor 0 1 Text.inverse_attr
@

<<function Top_window.set_cursor_off>>=
let set_cursor_off top_window frame =
  if frame.frm_cursor.[0] <> '\000' then
    let graphic = Window.backend top_window in
    graphic.Xdraw.draw_string
      (frame.frm_xpos + frame.frm_cursor_x) 
      (frame.frm_ypos + frame.frm_cursor_y) 
      frame.frm_cursor 0 1 frame.frm_cursor_attr
@





<<function Top_window.resize_window>>=
let rec resize_window window xpos ypos width height =
  let old_width = window.win_width in
  let old_height = window.win_height in
  window.win_xpos <- xpos;
  window.win_ypos <- ypos;
  window.win_width <- width;
  window.win_height <- height;
  match window.win_down with
    WFrame frame -> Frame.install window frame
  | NoFrame () -> assert false
  | HComb (w1,w2) ->
      let wi1 = w1.win_width * width / old_width in
      resize_window w1 xpos ypos wi1 height;
      resize_window w2 (xpos + wi1) ypos (width - wi1) height
  | VComb (w1,w2) ->
      let he1 = w1.win_height * height / old_height in
      resize_window w1 xpos ypos width he1;
      resize_window w2 xpos (ypos + he1) width (height - he1)
@

<<function Top_window.find_frame>>=
let rec find_frame window x y =
  match window.win_down with
    NoFrame () -> assert false
  | WFrame frame -> frame
  | HComb (w1,w2) -> 
      if w2.win_xpos > x then find_frame w1 x y
      else find_frame w2 x y
  | VComb (w1,w2) ->
      if w2.win_ypos > y then find_frame w1 x y
      else find_frame w2 x y
@



<<function Top_window.find_selected_frame>>=
let find_selected_frame top_window =
  let x = !mouse_x in
  let y = !mouse_y in
  let frame = 
    if y > top_window.top_height - 2 then
      match top_window.top_mini_buffers with
        [] -> raise Not_found
      | mini_frame :: _ -> mini_frame
    else
      find_frame top_window.window x y
  in
  Frame.active frame;
  frame
@

<<function Top_window.mouse_set_active>>=
let mouse_set_active top_window =
  let x = !mouse_x in
  let y = !mouse_y in
  let frame = find_selected_frame top_window in
  Frame.move_point frame frame.frm_point x y;
  frame
@

<<function Top_window.mini_message>>=
let mini_message frame msg =
  let top_window = Window.top frame.frm_window in
  message top_window msg
@


<<constant Top_window.meta>>=
let meta = ref Xtypes.mod1Mask
@


<<function Top_window.wrap>>=
let wrap top_window f () = 
  let location = top_window.top_location in
  Mutex.lock location.loc_mutex;  
  clean_display location;    
  clear_message top_window;
  keypressed := XK.xk_Menu;
  exec_hooks
    (try get_global location handle_key_start_hook with _ -> []) location;    
  begin
    try f top_window with e ->   
        message top_window 
          (Printf.sprintf "Uncaught exception %s" (Utils.printexn e))
  end;
  exec_hooks 
    (try get_global location handle_key_end_hook with _ -> []) location;    
  update_display top_window.top_location;
  let graphic = Window.backend top_window in
  graphic.Xdraw.update_displays ();
  Mutex.unlock top_window.top_location.loc_mutex
@

<<function Top_window.wrap_item>>=
let wrap_item top_window (n,f) =
  n, wrap top_window (fun top_window -> f top_window.top_active_frame)
@


<<constant Top_window.buffers_menu>>=
let buffers_menu = ref 
  (fun (top_window : top_window) (button : (*WX_button.t*) unit) ()
  -> ())
@

<<function Top_window.scroll_to_frame>>=
let scroll_to_frame ady top_window =
  let frame = top_window.top_active_frame in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let pos_start = Text.get_position text frame.frm_start in
  let _size = Text.size text in
  Common.pr2 "ady#get_pos size";
  let y = 1
(*    ady#get_pos size  *)
  in
  if abs (y - pos_start) > 80 then
  (* the position has changed *)
    begin
      frame.frm_force_start <- true;
      frame.frm_redraw <- true;
      Text.set_position text frame.frm_start y
    end
@

<<constant Top_window.menus>>=
(*
    Text.set_position text point y;
      let point = Text.add_point text in
      let curline = Text.point_line text frame.frm_start in
      let newline = Text.point_line text point in
      Text.remove_point text point;
    frame.frm_y_offset <- frame.frm_y_offset + (newline - curline);
  *)

let menus = define_option ["menus"] ""
    (list_option (tuple2_option (string_option, list_option string2_option)))
  []
@




<<constant Top_window.check_abort>>=
let check_abort = ref 0
@

<<constant Top_window.check_abort_delay>>=
let check_abort_delay = ref 100
@

<<function Top_window.check_abort>>=
let check_abort frame =
  failwith "Top_window.check_abort: TODO"
(*
  incr check_abort; 
  if !check_abort mod !check_abort_delay = 0 then
    let top_window = Window.top frame.frm_window in
    let xterm = top_window.top_term in
    xterm#check_abort
  else false
*)
@


%-------------------------------------------------------------

<<graphics/top_window.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Options

open Xtypes

open Efuns
open Window

  
<<function Top_window.message>>

<<function Top_window.clear_message>>

<<function Top_window.dummy_action>>

<<function Top_window.try_map>>

<<function Top_window.set_cursor_on>>

<<function Top_window.set_cursor_off>>

<<function Top_window.cursor_on>>

<<function Top_window.cursor_off>>


<<function Top_window.update_display>>

<<function Top_window.clean_display>>

<<function Top_window.resize_window>>

<<function Top_window.find_frame>>

<<constant Top_window.keypressed>>
<<constant Top_window.mouse_x>>
<<constant Top_window.mouse_y>>

<<function Top_window.find_selected_frame>>


<<function Top_window.mouse_set_active>>


<<function Top_window.mini_message>>

<<constant Top_window.handle_key_start_hook>>
<<constant Top_window.handle_key_end_hook>>
  
<<constant Top_window.meta>>
  
<<function Top_window.handle_key>>

  (* We can receive events from different sources. In particular, some of
  them can be received during the painting (scrollbar ...)
  *)
  
<<function Top_window.wrap>>

<<function Top_window.wrap_item>>
        
<<function Top_window.handler>>


<<constant Top_window.buffers_menu>>

<<function Top_window.scroll_to_frame>>
<<constant Top_window.menus>>
<<constant Top_window.file_menu>>
<<constant Top_window.edit_menu>>
<<constant Top_window.help_menu>>

  
  
<<function Top_window.create>>

<<function Top_window.delete_window>>
    
    

        
<<constant Top_window.check_abort>>
<<constant Top_window.check_abort_delay>>

  (* This function should be used in loops that could be interrupted by
  the user. It returns "true" if the user pressed C-g, and false
  in other cases. *)
  
<<function Top_window.check_abort>>
@


\section{[[./]]}

\subsection*{[[std_efunsrc.ml]]}

<<function Std_efunsrc.save_options>>=
let save_options frame = Options.save ()
@


<<constant Std_efunsrc.n_5>>=
let n_5 = (NormalMap, Char.code '5') 
@

<<toplevel Std_efunsrc._5>>=
let _ =
  Efuns.add_start_hook (fun location ->
      add_option_parameter location compile_find_makefile;
      add_option_parameter location Text.add_amount;
      init_global_map location
  )
@


%-------------------------------------------------------------

<<std_efunsrc.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Utils
open Options

open Interactive
open Efuns
open Keymap
open Simple
open Select
open Search
open Compil
open Abbrevs
open Complexe
open System
open Multi_frames
open Top_window
(*open Eval*)
  

<<constant Std_efunsrc.grep_hist>>

<<function Std_efunsrc.save_options>>
<<function Std_efunsrc.fondamental_mode>>

<<function Std_efunsrc.compile>>

<<function Std_efunsrc.select_open_file>>

  
<<toplevel Std_efunsrc._1>>
  
  
<<constant Std_efunsrc.global_map>>

<<constant Std_efunsrc.interactives_map>>

<<constant Std_efunsrc.c_h>>
<<constant Std_efunsrc.c_x>>
<<constant Std_efunsrc.c_c>>
<<constant Std_efunsrc.n_5>>

<<toplevel Std_efunsrc._2>>
    
<<function Std_efunsrc.init_global_map>>
  
(*open WX_filesel*)
 
<<toplevel Std_efunsrc._4>>
  
<<toplevel Std_efunsrc._5>>
@


\subsection*{[[main.ml]]}

%let dpy_oo = new WX_display.t !displayname
%let root_oo = new WX_root.t dpy_oo 0
%let display = WX_xterm.create_display root_oo
%  location.loc_colors_names location.loc_fonts_names 
%
%let top_window = Top_window.create location display
%let _ =
%  WX_xterm.setHighlight display 2;
%  Dyneval.init true;
%  Eval.load top_window "Efunsrc";
%  Efuns.init location; (* launch second hooks *)
%  let _ = Interactive.create_bindings location in
%(* open the fisrt buffers *)
%  List.iter (fun name ->
%    let _ = Frame.load_file top_window.window name in ()) 
%  !init_files;
%  List.iter 
%    (fun str -> let top_window = Top_window.create top_window.top_location
%          (Window.display top_window) in
%      let _ = Frame.load_file top_window.window str in ()) !init_frames;
%  Top_window.update_display location;
%
%  
%  if not (Sys.file_exists (Filename.concat Utils.homedir ".efunsrc")) then
%    begin
%      Printf.printf "Saving .efunsrc after install"; print_newline ();
%      Options.save ();
%    end;
%
%  if !check then exit 0;  
%  (* Main loop *)
%  let rec loop () =
%    try
%      WX_types.loop ()
%    with
%      SigInt -> loop ()
%  in
%  loop ()


%-------------------------------------------------------------

<<main.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)
open Options
open Efuns
  
<<constant Main.location>>

<<exception Main.SigInt>>
<<toplevel Main._1>>

<<constant Main.highlight_color>>
  
<<toplevel Main._2>>

<<toplevel Main._3>>

<<toplevel Main._4>>
@


\section{[[major_modes/]]}

\subsection*{[[major_modes/dired.ml]]}

<<function Dired.update>>=
let update buf =
  let filename = match buf.buf_filename with
      None -> failwith "Not a directory"
    | Some filename -> filename in
  let s = Utils.load_directory filename in
  let text = buf.buf_text in
  Text.update text s;
  buf.buf_last_saved <- Text.version text
@

<<constant Dired.file_reg>>=
let file_reg = Str.regexp ".* \\([^ ]+\\)$"
@
%$

<<function Dired.get_file_line>>=
let get_file_line frame =
  (match frame.frm_buffer.buf_filename with
      None -> ()
    | Some filename -> 
        frame.frm_location.loc_dirname <- Filename.dirname filename);
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let start_point = Text.dup_point text point in
  let before = Text.point_to_bol text point in
  let after = Text.point_to_eol text point in
  Text.bmove text start_point before;
  let line = Text.sub text start_point (before + after) in
  Text.remove_point text start_point;
  line
@

<<function Dired.select_file>>=
let select_file line =
  if line.[0] = ' ' then
    if Str.string_match file_reg line 0 then
      Str.matched_group 1 line else
      String.sub line 60 (String.length line - 60)
  else
    failwith "Dired: not a file line"
@

<<function Dired.dirname>>=
let dirname frame =
  match frame.frm_buffer.buf_filename with
    None -> "."
  | Some dirname -> dirname 
@

<<function Dired.fullname>>=
let fullname frame filename = 
  Filename.concat (dirname frame) filename
@

<<function Dired.open_file>>=
let open_file frame =
  let filename = fullname frame (select_file (get_file_line frame)) in
  let location = frame.frm_location in
  let buf = Ebuffer.read location filename (Keymap.create ()) in
  let frame = Frame.create  frame.frm_window None buf in
  Frame.active frame
@

<<function Dired.remove>>=
let remove frame =
  let line = get_file_line frame in   
  let filename = select_file line in
  let _ = 
    Select.select_yes_or_no frame (Printf.sprintf "Remove %s ? (y/n)" filename)
    (fun b -> if b then
          if line.[1] = 'd' then Unix.rmdir filename else
          Unix.unlink filename;
        update frame.frm_buffer) in
  ()
@

<<constant Dired.view_list>>=
let view_list = ref []
@

<<constant Dired.old_view_list>>=
let old_view_list = ref []
@

<<constant Dired.compiled_view_list>>=
let compiled_view_list = ref []
@

<<function Dired.fast_view>>=
let fast_view frame filename =
  if not (!old_view_list == !view_list) then
    begin
      compiled_view_list := List.map 
        (fun (file_reg, appli) ->
          Str.regexp file_reg, appli) !view_list;
      old_view_list := !view_list
    end;
  try
    List.iter (fun (regexp, viewer) ->
        if Str.string_match regexp filename 0 then
          try
            Unix.chdir (dirname frame);
            viewer frame filename;
            raise Exit
          with
            _ -> raise Exit
    ) !compiled_view_list;
    let _ = 
      Select.select_yes_or_no frame (Printf.sprintf "Open %s ? (y/n)" filename)
      (fun b -> if b then
            open_file frame) in
      ()

  with
    Exit -> ()      
@

<<function Dired.open_view>>=
let open_view frame =
  let filename = select_file (get_file_line frame) in
  fast_view frame filename
@

<<function Dired.mkdir>>=
let mkdir frame =
  failwith "Dired.mkdir: TODO"
(*
  Select.select_filename frame "Make directory: "
    (fun str -> 
      let file_perm = try get_var frame.frm_buffer file_perm with _ -> 
            0x1ff land (lnot umask) in
      Unix.mkdir str file_perm;
      update frame.frm_buffer)
*)
@

<<function Dired.install>>=
let install buf = 
  match buf.buf_filename with
    None -> 
      failwith "Dired: Not a directory"
  | Some filename ->
      if not (Utils.is_directory filename) then 
        failwith (Printf.sprintf "Dired: %s not a directory" filename);
      update buf
@

<<constant Dired.mode>>=
let mode = Ebuffer.new_major_mode "Dired" [install]
@

<<constant Dired.map>>=
let map = mode.maj_map
@

<<function Dired.viewer>>=
let viewer commande frame filename =
  Sys.command (Printf.sprintf "(%s %s) &" commande filename) |> ignore
@

<<function Dired.commande>>=
let commande commande frame filename =
  Sys.command (Printf.sprintf commande filename) |> ignore;
  failwith  (Printf.sprintf commande filename)
@

<<function Dired.unzip_and_view>>=
let unzip_and_view frame filename =
  let new_filename = Printf.sprintf "/tmp/efuns-view-%s" (
      Filename.chop_extension filename) in
  let res = Sys.command (
      Printf.sprintf "gzip -cd %s > %s" filename new_filename)
  in
  if res = 0 then fast_view frame new_filename
@

<<toplevel Dired._1>>=
let _ = 
  interactive map [NormalMap, XK.xk_Return] "dired-open-file" open_file;
  interactive map [NormalMap, Char.code 'g'] "dired-update" 
  (fun frame -> update frame.frm_buffer);  
  interactive map [NormalMap, Char.code 'v'] "dired-view-file" open_view;  
  interactive map [NormalMap, Char.code '+'] "dired-make-directory" 
    mkdir;  
  interactive map [NormalMap, Char.code '-'] "dired-remove-entry" 
    remove;  
  
  view_list := [
    ".*\\(\\.jpg\\|\\..gig\\|\\.xpm\\|\\.ppm\\)",viewer "xv";
    ".*\\(\\.ps\\|\\.PS\\)",viewer "gv";
    ".*\\(\\.dvi\\)",viewer "xdvi";
    ".*\\(\\.gz\\|\\.Z\\|\\.z\\)",unzip_and_view; 
    ".*\\.tgz", commande "xterm -e sh -c \"tar zvtf %s | less\"";
    ".*\\.tar", commande "xterm -e sh -c \"tar vtf %s | less\"";
    ".*\\.tar", commande "xterm -e sh -c \"tar vtf %s | less\"";
    ];
  
  Efuns.add_start_hook (fun location ->
      add_interactive (location.loc_map) "dired-mode" 
        (fun frame -> 
          Ebuffer.set_major_mode frame.frm_buffer mode);
      set_global location Ebuffer.modes_alist ((".*/$",mode) :: 
        (get_global location Ebuffer.modes_alist));      
  )   
@
%$


%-------------------------------------------------------------

<<major_modes/dired.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                             ____                                    *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Text
open Keymap
open Efuns
open Simple
open Compil
(*open Complex*)
open Window

<<function Dired.update>>

<<constant Dired.file_reg>>
  
<<function Dired.get_file_line>>
    
<<function Dired.select_file>>

<<function Dired.dirname>>
      
<<function Dired.fullname>>
      
<<function Dired.open_file>>
  
<<function Dired.remove>>

<<constant Dired.view_list>>
<<constant Dired.old_view_list>>
<<constant Dired.compiled_view_list>>
  
<<function Dired.fast_view>>
  
<<function Dired.open_view>>
  
<<function Dired.mkdir>>
          
<<function Dired.install>>
      
<<constant Dired.mode>>

<<constant Dired.map>>
  

<<function Dired.viewer>>

<<function Dired.commande>>
  
<<function Dired.unzip_and_view>>
    
<<toplevel Dired._1>>
@


\section{[[minor_modes/]]}

\subsection*{[[minor_modes/minor_mode_sample.ml]]}

%-------------------------------------------------------------

<<minor_modes/minor_mode_sample.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Text
open Simple
open Efuns
open Top_window
          
<<constant Minor_mode_sample.minor_mode_name>>

<<function Minor_mode_sample.install>>

<<function Minor_mode_sample.minor_mode_fun>>
  
<<constant Minor_mode_sample.mode>>

<<toplevel Minor_mode_sample._1>>

<<toplevel Minor_mode_sample._2>>
    
    
@


\subsection*{[[minor_modes/abbrevs_mode.ml]]}

<<constant Abbrevs_mode.abbreviations>>=
let abbreviations = define_option ["abbrevs_mode"; "abbrevs"] ""
    (list_option string2_option) []
@

<<constant Abbrevs_mode.abbrevs>>=
let abbrevs = Hashtbl.create 11
@

<<toplevel Abbrevs_mode._1>>=
let _ =
  Utils.hash_add_assoc abbrevs !!abbreviations
@

<<function Abbrevs_mode.install>>=
let install buf =
  try
    ignore (get_local buf abbrev_table)
  with _ -> 
      set_local buf abbrev_table abbrevs
@

<<constant Abbrevs_mode.mode>>=
let mode = Ebuffer.new_minor_mode "abbrevs" [install]
@

<<constant Abbrevs_mode.abbrevs_chars>>=
let abbrevs_chars = define_option ["abbrevs_mode"; "abbrevs_chars"] ""
    string_option " "
@

<<function Abbrevs_mode.find_matching>>=
let find_matching  frame = self_insert_command frame; highlight_paren frame
@

<<function Abbrevs_mode.char_expand_abbrev>>=
let char_expand_abbrev frame =
  expand_sabbrev frame; self_insert_command frame
@

<<toplevel Abbrevs_mode._2>>=
let _ = 
  let chars = !!abbrevs_chars in
  for i = 0 to String.length chars - 1 do
    Keymap.add_binding mode.min_map [NormalMap, Char.code chars.[i]]
      char_expand_abbrev
  done
@

<<toplevel Abbrevs_mode._3>>=
let _ = 
  define_action "abbrevs_mode" 
    (fun frame -> 
      let buf = frame.frm_buffer in
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode)
@


%-------------------------------------------------------------

<<minor_modes/abbrevs_mode.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Options
open Abbrevs
open Text
open Simple
open Efuns
open Top_window

<<constant Abbrevs_mode.abbreviations>>
  
<<constant Abbrevs_mode.abbrevs>>
<<toplevel Abbrevs_mode._1>>
  
<<function Abbrevs_mode.install>>

<<constant Abbrevs_mode.mode>>

<<constant Abbrevs_mode.abbrevs_chars>>
  
<<function Abbrevs_mode.find_matching>>
<<function Abbrevs_mode.char_expand_abbrev>>
  
<<toplevel Abbrevs_mode._2>>

<<toplevel Abbrevs_mode._3>>
    
    
@


\subsection*{[[minor_modes/accents_mode.ml]]}

<<function Accents_mode.accent>>=
let accent frame =
  let key = !keypressed in
  let c = previous_char frame in
  try
    let key = 
      if key = XK.xk_grave then
        match c with
        | 'e' -> XK.xk_egrave
        | 'a' -> XK.xk_agrave
        | 'i' -> XK.xk_igrave 
        | 'o' -> XK.xk_ograve 
        | 'u' -> XK.xk_ugrave
        | 'A' -> XK.xk_Agrave
        | 'E' -> XK.xk_Egrave
        | 'I' -> XK.xk_Igrave
        | 'O' -> XK.xk_Ograve
        | 'U' -> XK.xk_Ugrave 
        | _ -> raise Not_found
      else 
      if key = XK.xk_apostrophe then
        match c with
        | 'e' -> XK.xk_eacute
        | 'E' -> XK.xk_Eacute
        
        | 'a' -> XK.xk_aacute
        | 'i' -> XK.xk_iacute
        | 'o' -> XK.xk_oacute
        | 'u' -> XK.xk_uacute
        | 'A' -> XK.xk_Aacute
        | 'I' -> XK.xk_Iacute
        | 'O' -> XK.xk_Oacute
        | 'U' -> XK.xk_Uacute
        
        | _ -> raise Not_found
      else
      if key = XK.xk_semicolon then
        match c with
          'c' -> XK.xk_ccedilla
        | _ -> raise Not_found
      else
      if key = XK.xk_asciicircum then
        match c with
        | 'e' -> XK.xk_ecircumflex
        | 'a' -> XK.xk_acircumflex 
        | 'i' -> XK.xk_icircumflex
        | 'o' -> XK.xk_ocircumflex
        | 'u' -> XK.xk_ucircumflex
        | 'A' -> XK.xk_Acircumflex
        | 'E' -> XK.xk_Ecircumflex
        | 'I' -> XK.xk_Icircumflex
        | 'O' -> XK.xk_Ocircumflex
        | 'U' -> XK.xk_Ucircumflex 
        | _ -> raise Not_found
      else              
      if key = XK.xk_quotedbl then
        match c with
        | 'e' -> XK.xk_ediaeresis
        | 'a' -> XK.xk_adiaeresis 
        | 'i' -> XK.xk_idiaeresis
        | 'o' -> XK.xk_odiaeresis
        | 'u' -> XK.xk_udiaeresis
        | 'A' -> XK.xk_Adiaeresis
        | 'E' -> XK.xk_Ediaeresis
        | 'I' -> XK.xk_Idiaeresis
        | 'O' -> XK.xk_Odiaeresis
        | 'U' -> XK.xk_Udiaeresis 
        | _ -> raise Not_found
      else              
      if key = XK.xk_asciitilde then
        match c with
        | 'n' -> XK.xk_ntilde
        | 'a' -> XK.xk_atilde
        | 'o' -> XK.xk_otilde
        | 'A' -> XK.xk_Atilde
        | 'N' -> XK.xk_Ntilde
        | 'O' -> XK.xk_Otilde 
        | _ -> raise Not_found
      else              
        raise Not_found
    in
    bmove frame.frm_buffer.buf_text frame.frm_point 1;
    insert_at_place frame (Char.chr key)
  with
    Not_found ->
      try
        let c = Char.code c in
        let c = 
          if key = XK.xk_grave then
            if c = XK.xk_egrave then 'e' else
            if c = XK.xk_agrave then 'a' else
            if c = XK.xk_igrave then 'i' else 
            if c = XK.xk_ograve then 'o' else 
            if c = XK.xk_ugrave then 'u' else
            if c = XK.xk_Agrave then 'A' else
            if c = XK.xk_Egrave then 'E' else
            if c = XK.xk_Igrave then 'I' else
            if c = XK.xk_Ograve then 'O' else
            if c = XK.xk_Ugrave then 'U' else 
              raise Not_found
          else 
          if key = XK.xk_apostrophe then
            if c = XK.xk_eacute then 'e' else
            if c = XK.xk_Eacute then 'E' else
            if c = XK.xk_aacute then 'a' else
            if c = XK.xk_iacute then 'i' else
            if c = XK.xk_oacute then 'o' else
            if c = XK.xk_uacute then 'u' else
            if c = XK.xk_Aacute then 'A' else
            if c = XK.xk_Iacute then 'I' else
            if c = XK.xk_Oacute then 'O' else
            if c = XK.xk_Uacute then 'U' else
              raise Not_found
          else
          if key = XK.xk_semicolon then
            if c = XK.xk_ccedilla then 'c' else
              raise Not_found
          else
          if key = XK.xk_asciicircum then
            if c = XK.xk_ecircumflex then 'e' else
            if c = XK.xk_acircumflex then 'a' else 
            if c = XK.xk_icircumflex then 'i' else
            if c = XK.xk_ocircumflex then 'o' else
            if c = XK.xk_ucircumflex then 'u' else
            if c = XK.xk_Acircumflex then 'A' else
            if c = XK.xk_Ecircumflex then 'E' else
            if c = XK.xk_Icircumflex then 'I' else
            if c = XK.xk_Ocircumflex then 'O' else
            if c = XK.xk_Ucircumflex then 'U' else 
              raise Not_found
          else              
          if key = XK.xk_quotedbl then
            if c = XK.xk_ediaeresis then 'e' else
            if c = XK.xk_adiaeresis then 'a' else 
            if c = XK.xk_idiaeresis then 'i' else
            if c = XK.xk_odiaeresis then 'o' else
            if c = XK.xk_udiaeresis then 'u' else
            if c = XK.xk_Adiaeresis then 'A' else
            if c = XK.xk_Ediaeresis then 'E' else
            if c = XK.xk_Idiaeresis then 'I' else
            if c = XK.xk_Odiaeresis then 'O' else
            if c = XK.xk_Udiaeresis then 'U' else 
              raise Not_found
          else              
          if key = XK.xk_asciitilde then
            if c = XK.xk_ntilde then 'n' else
            if c = XK.xk_atilde then 'a' else
            if c = XK.xk_otilde then 'o' else
            if c = XK.xk_Atilde then 'A' else
            if c = XK.xk_Ntilde then 'N' else
            if c = XK.xk_Otilde then 'O' else 
              raise Not_found
          else              
            raise Not_found
        in
        bmove frame.frm_buffer.buf_text frame.frm_point 1;
        insert_at_place frame c;
        insert_char frame (Char.chr key)
      with
        Not_found ->
          insert_char frame (Char.chr key)
@

<<function Accents_mode.install>>=
let install buf =
  List.iter (fun key ->
      buf.buf_syntax_table.(key) <- true)
  [ XK.xk_egrave; XK.xk_agrave; XK.xk_igrave; XK.xk_ograve; XK.xk_ugrave;
    XK.xk_Agrave; XK.xk_Egrave; XK.xk_Igrave; XK.xk_Ograve; XK.xk_Ugrave;
    XK.xk_eacute; XK.xk_aacute; XK.xk_iacute; XK.xk_oacute; XK.xk_uacute;
    XK.xk_Aacute; XK.xk_Eacute; XK.xk_Iacute; XK.xk_Oacute; XK.xk_Uacute;
    XK.xk_ccedilla;
    XK.xk_ecircumflex; XK.xk_acircumflex; XK.xk_icircumflex;
    XK.xk_ocircumflex; XK.xk_ucircumflex; XK.xk_Acircumflex;
    XK.xk_Ecircumflex; XK.xk_Icircumflex; XK.xk_Ocircumflex;
    XK.xk_Ucircumflex;
    XK.xk_ediaeresis; XK.xk_adiaeresis; XK.xk_idiaeresis; XK.xk_odiaeresis;
    XK.xk_udiaeresis; XK.xk_Adiaeresis; XK.xk_Ediaeresis; XK.xk_Idiaeresis;
    XK.xk_Odiaeresis; XK.xk_Udiaeresis;
    XK.xk_ntilde; XK.xk_atilde; XK.xk_otilde;
    XK.xk_Atilde; XK.xk_Ntilde; XK.xk_Otilde; ]
@

<<constant Accents_mode.mode>>=
let mode = Ebuffer.new_minor_mode  "accents" [install]
@

<<toplevel Accents_mode._1>>=
let _ = 
  List.iter
    (fun key -> 
      Keymap.add_binding mode.min_map [NormalMap, key] accent
  )
  [ XK.xk_apostrophe; XK.xk_grave; XK.xk_semicolon; XK.xk_asciicircum;
    XK.xk_quotedbl; XK.xk_asciitilde]
@

<<toplevel Accents_mode._2>>=
let _ = 
  define_buffer_action "accents_mode" 
    (fun buf -> 
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode)
@


%-------------------------------------------------------------

<<minor_modes/accents_mode.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Text
open Simple
open Efuns
open Top_window
  
  (* franc;ais strict *)
<<function Accents_mode.accent>>
          
          
<<function Accents_mode.install>>
  
<<constant Accents_mode.mode>>

<<toplevel Accents_mode._1>>

<<toplevel Accents_mode._2>>
    
    
@


\subsection*{[[minor_modes/fill_mode.ml]]}

<<constant Fill_mode.minor_mode_name>>=
let minor_mode_name = "fill"
@

<<function Fill_mode.install>>=
let install buf = ()
@

<<constant Fill_mode.fill_line_len>>=
let fill_line_len = define_option ["fill_line_len"] "" int_option 80
@

<<constant Fill_mode.mode>>=
let mode = Ebuffer.new_minor_mode minor_mode_name [install]
@

<<constant Fill_mode.fill_on_char>>=
let fill_on_char = define_option ["fill_on_char"] "" string_option " "
@

<<toplevel Fill_mode._1>>=
let _ =
  let fill_on_char = !!fill_on_char in
  for i = 0 to String.length fill_on_char - 1 do 
      Keymap.add_binding mode.min_map [NormalMap, Char.code fill_on_char.[i]] 
        electric_insert_space
  done
@

<<toplevel Fill_mode._2>>=
let _ = 
  define_buffer_action (minor_mode_name ^ "_mode")
    (fun buf -> 
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode);
@


%-------------------------------------------------------------

<<minor_modes/fill_mode.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)
open Options
open Text
open Simple
open Efuns
open Top_window
          
<<constant Fill_mode.minor_mode_name>>
  
<<function Fill_mode.install>>

<<constant Fill_mode.fill_line_len>>
  
<<constant Fill_mode.mode>>

<<constant Fill_mode.fill_on_char>>
  
<<toplevel Fill_mode._1>>
  
<<toplevel Fill_mode._2>>
    
    
@


\subsection*{[[minor_modes/paren_mode.ml]]}

<<constant Paren_mode.mode>>=
let mode = Ebuffer.new_minor_mode "paren" []
@

<<function Paren_mode.find_matching>>=
let find_matching  frame = self_insert_command frame; highlight_paren frame
@

<<toplevel Paren_mode._1>>=
let _ = 
  List.iter
    (fun key -> 
      Keymap.add_binding mode.min_map [NormalMap, Char.code key] find_matching
  ) [ ')'; '}'; ']' ]
@

<<toplevel Paren_mode._2>>=
let _ = 
  define_buffer_action "paren_mode" 
    (fun buf -> 
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode)
@


%-------------------------------------------------------------

<<minor_modes/paren_mode.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Text
open Simple
open Efuns
open Top_window

<<constant Paren_mode.mode>>

<<function Paren_mode.find_matching>>
  
<<toplevel Paren_mode._1>>

<<toplevel Paren_mode._2>>
@


\subsection*{[[minor_modes/tab_mode.ml]]}

<<constant Tab_mode.mode>>=
let mode = Ebuffer.new_minor_mode "tab" []
@

<<function Tab_mode.insert_tab>>=
let insert_tab frame = ignore (insert_string frame "\t")
@

<<toplevel Tab_mode._1>>=
let _ = 
  Keymap.add_binding mode.min_map [NormalMap, XK.xk_Tab] insert_tab
@

<<toplevel Tab_mode._2>>=
let _ = 
  define_buffer_action "tab_mode" 
    (fun buf -> 
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode);
  define_action "insert_tab" insert_tab
@

%-------------------------------------------------------------

<<minor_modes/tab_mode.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Text
open Simple
open Efuns
open Top_window

<<constant Tab_mode.mode>>
  
<<function Tab_mode.insert_tab>>
  
<<toplevel Tab_mode._1>>

<<toplevel Tab_mode._2>>
@

\section{[[prog_modes/]]}

\subsection*{[[prog_modes/makefile_mode.ml]]}

<<constant Makefile_mode.mkfile_vars>>=
let mkfile_vars= Str.regexp "\\(\\$([a-zA-Z0-9_]*)\\)\\|\\([a-zA-Z0-9_]+=\\)"
@
%$

<<constant Makefile_mode.mkfile_target>>=
let mkfile_target= Str.regexp "^.*:"
@

<<constant Makefile_mode.mkfile_rules>>=
let mkfile_rules= Str.regexp "^\t.*$"
@
%$

<<constant Makefile_mode.rules_color>>=
let rules_color = define_option ["makefile_mode";"rules_color"] "" 
  string_option "red"
@

<<constant Makefile_mode.target_color>>=
let target_color = define_option ["makefile_mode"; "target_color"] ""
    string_option "cadetblue"
@

<<constant Makefile_mode.vars_color>>=
let vars_color = define_option ["makefile_mode"; "vars_color"] ""
    string_option "blue"
@

<<function Makefile_mode.makefile_color>>=
let makefile_color buf =
  let location = buf.buf_location in
  color buf mkfile_rules false
    (make_attr (get_color location !!rules_color) 1 0 false);
  color buf mkfile_target false 
    (make_attr (get_color location !!target_color) 1 0 false);
  color buf mkfile_vars false 
    (make_attr (get_color location !!vars_color) 1 0 false)
@

<<constant Makefile_mode.c_c>>=
let c_c = (ControlMap,Char.code 'c')
@

<<function Makefile_mode.install>>=
let install buf =
  makefile_color buf;
  execute_buffer_action "tab_mode" buf
@

<<constant Makefile_mode.mode>>=
let mode = Ebuffer.new_major_mode "Makefile" [makefile_color]
@

<<constant Makefile_mode.local_map>>=
let local_map = define_option ["makefile_mode"; "local_map"] ""
    (list_option binding_option) []
@

<<constant Makefile_mode.interactives_map>>=
let interactives_map = define_option ["makefile_mode"; "interactives_map"] ""
    (list_option string2_option) 
  []
@

<<toplevel Makefile_mode._1>>=
(* let insert_tab frame = ignore (insert_string frame "\t") *)
  
let _ =
  if !!local_map = [] then
    local_map =:= [
      [c_c; ControlMap, Char.code 'c'], "makefile_mode.compile";    
      [ControlMap, Char.code 'l'], "makefile_mode.color_buffer";
     (*  [NormalMap, XK.xk_Tab], "insert_tab"; *)
    ];
  if !!interactives_map = [] then 
        interactives_map =:= [
          "compile", "makefile_mode.compile";
          "color_buffer", "makefile_mode.color_buffer";
      ]
@

<<function Makefile_mode.makefile_mode>>=
let makefile_mode frame = Ebuffer.set_major_mode frame.frm_buffer mode
@

<<toplevel Makefile_mode._2>>=
let _ = 
  define_action "makefile_mode.compile" (compile c_find_error);
  define_action "makefile_mode.color_buffer" 
    (fun frame -> makefile_color frame.frm_buffer);
(*  define_action "insert_tab" insert_tab; *)
  define_action "makefile_mode" makefile_mode;
  ()
@

<<toplevel Makefile_mode._3>>=
let _ =
  let map = mode.maj_map in
  List.iter (fun (keys, action) ->
      try
        Keymap.add_binding map keys (execute_action action)
      with e ->
          Log.printf "Error for action %s" action;
          Log.exn "%s\n" e;
  
  ) !!local_map;
  List.iter (fun (name, action) ->
      try
        add_interactive map name (execute_action action)
      with e ->
          Log.printf "Error for action %s" action;
          Log.exn "%s\n" e;
          
  ) !!interactives_map;
  ()
@

<<toplevel Makefile_mode._4>>=
let _ = 
  (* Keymap.add_prefix mode.maj_map [c_c];   *)
  Efuns.add_start_hook (fun location ->
      let alist = get_global (location) Ebuffer.modes_alist in
      set_global location Ebuffer.modes_alist 
        ((".*/[Mm]akefile.*",mode)
        :: alist);
      add_option_parameter location vars_color;
      add_option_parameter location target_color;
      add_option_parameter location rules_color;
      )   
@


%-------------------------------------------------------------

<<prog_modes/makefile_mode.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Options
open Text
open Keymap
open Efuns
open Simple
open Compil
open Complex
open Window

<<constant Makefile_mode.mkfile_vars>>
<<constant Makefile_mode.mkfile_target>>
<<constant Makefile_mode.mkfile_rules>>

<<constant Makefile_mode.rules_color>>
<<constant Makefile_mode.target_color>>
<<constant Makefile_mode.vars_color>>
  
<<function Makefile_mode.makefile_color>>
 
<<constant Makefile_mode.c_c>>

<<function Makefile_mode.install>>
  
<<constant Makefile_mode.mode>>
  

<<constant Makefile_mode.local_map>>

<<constant Makefile_mode.interactives_map>>

<<toplevel Makefile_mode._1>>

<<function Makefile_mode.makefile_mode>>
        
<<toplevel Makefile_mode._2>>

<<toplevel Makefile_mode._3>>

  
<<toplevel Makefile_mode._4>>
@


\subsection*{[[prog_modes/ocaml_toplevel.ml]]}

<<function Ocaml_toplevel.type_buffer>>=
let type_buffer buf =
  let text = buf.buf_text in
  let start_point = Text.add_point text in
  let end_point = Text.add_point text in
  set_position text end_point (size text);
  let lexbuf = lexing text start_point end_point in
  try  
    let (str, env) = Type.type_buffer buf.buf_name lexbuf !!ocaml_path in
    remove_point text start_point;
    remove_point text end_point;
    (str,env)
  with x ->
      remove_point text start_point;
      remove_point text end_point;
      raise x
@

<<constant Ocaml_toplevel.compiled_idents>>=
let compiled_idents = Local.create_abstr "compiled_idents"
@

<<function Ocaml_toplevel.all_idents>>=
let all_idents buf =
  try
    let (ids, version) = Local.get buf.buf_vars compiled_idents in
    if Text.version buf.buf_text = version then ids else raise Not_found
  with
    _ -> 
      let _, (str,env) = Utils.do_and_format type_buffer buf in
      let ids = Type.iter_structure str [] GlobalDefined in
      set_local buf compiled_idents (ids, Text.version buf.buf_text);
      ids      
@

<<function Ocaml_toplevel.find_value_type>>=
let find_value_type sign names =
  let rec solv sign names =
    match names with
      [] -> raise Not_found
    | name :: names ->
        let rec find sign =
          match sign with
            [] -> raise Not_found
          | sg :: sign ->
              match sg with
                Tsig_value (ident,vd) 
                when Ident.name ident = name ->
                  vd.val_type
              | Tsig_module (ident,Tmty_signature sign ) 
                when Ident.name ident = name ->
                  solv sign names
              | _ -> find sign
        in
        find sign
  in
  solv sign names
@

<<function Ocaml_toplevel.print_type>>=
let print_type frame = 
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  let top_window = Window.top frame.frm_window in
  try
    let ids = all_idents buf in
    let text = buf.buf_text in
    let pos = get_position text point in
    List.iter (fun (p,l,t,w) ->
        if l.loc_start-1 <= pos && l.loc_end+1 >= pos then
          Top_window.message top_window 
            (Utils.format_to_string 
              (fun () -> 
                printtyp_path p;
                Format.print_string " : ";
                printtyp_type_expr t
            ) ())
    ) ids
  with
    _ ->
  let name = find_long_word buf point in
  let names = parse_name name in
  let test_name modname names =
    try    
      let ps = Ocaml_env.find_pers_struct !!ocaml_path modname in
      let typ = find_value_type ps.ps_sig names in
      let styp = format_to_string () in
      Format.print_string modname;
      let rec iter list =
        match list with
          [] -> ()
        | name :: tail -> 
            Format.print_string ".";
            Format.print_string name;
            iter tail
      in
      iter names;
      Format.print_string ": ";
      printtyp_type_expr typ;
      Format.print_flush ();
      Top_window.message top_window !styp    
    with
      Env.Error e ->
        let m,s1,s2,s3 =
          match e with    
            Not_an_interface s -> "Not_an_interface",s,"",""
          | Corrupted_interface s -> "Corrupted_interface",s,"",""
          | Illegal_renaming (s1 , s2) ->
              "Illegal_renaming",s1,s2,"" 
          | Inconsistent_import (s1,s2,s3) ->
              "Inconsistent_import",s1,s2,s3
        in
        Top_window.message top_window 
          (Printf.sprintf "Env error: %s %s %s %s" m s1 s2 s3)
  in
  try
    match names with
      modname :: names when modname = String.capitalize modname -> 
        test_name modname names
    | _ -> raise Not_found
  with
    Not_found ->
      let rec iter env =
        match env with
          [] -> failwith "Can not find type"
        | modname :: env ->
            try
              test_name modname names
            with
              Not_found -> iter env
      in
      iter (find_env buf point)
@

<<constant Ocaml_toplevel.back_list>>=
let back_list = ref []
@

<<function Ocaml_toplevel.find_implementation>>=
let find_implementation frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let word = find_long_word buf point in
  let ids = all_idents buf in
  let pos = get_position text point in
  try
    List.iter (fun (pp,l,t,w) ->
        if l.loc_start-1 <= pos && l.loc_end+1 >= pos then
          begin
            List.iter (fun (p,l,t,w) ->
                if p = pp && (w <> Type.Used)then
                  (Text.set_position text frame.frm_point l.loc_start;
                    raise Exit)
            ) ids;  
            match pp with
              Path.Pdot (Path.Pident id,name,pos) when Ident.persistent id ->
              (* Look in another file ... *)
                let ident = Ident.name id in
                let file = ident ^ ".ml" in
                file.[0] <- Char.lowercase file.[0];
                let filename = 
                  try
                    Utils.find_in_path !!ocaml_path file
                  with _ -> failwith (Printf.sprintf "No %s in path" file)
                in 
                let location = frame.frm_location in
                let buf = Ebuffer.read location filename (Keymap.create ()) in
                let text = buf.buf_text in
                let frame = try
                    Frame.find_buffer_frame location buf
                  with Not_found ->
                      Frame.create frame.frm_window None buf
                in
                Frame.active frame;
                let ids = all_idents buf in
                List.iter (fun (p,l,t,w) ->
                    match p with
                      Path.Pident id ->
                        if Ident.name id = name && w = Type.GlobalDefined then
                          (Text.set_position text frame.frm_point l.loc_start;
                            raise Exit)
                    | _ -> ()
                ) ids;
            | _  -> ()
          end
    
    ) ids;
  with
    Exit -> 
      let filename = 
        match buf.buf_filename with
          None -> buf.buf_name
        | Some filename -> filename
      in
      back_list := (filename,Text.get_position text point) :: !back_list
@

<<function Ocaml_toplevel.backward_implementation>>=
let rec backward_implementation frame =
  match !back_list with
    [] -> failwith "No more buffers in history"
  | (filename, pos) :: tail ->
      back_list := tail;
      let location = frame.frm_location in
      let buf = Ebuffer.read location filename (Keymap.create ()) in
      let frame = Frame.create frame.frm_window None buf in
      Frame.active frame
@

<<function Ocaml_toplevel.mouse_find_implementation>>=
let mouse_find_implementation frame =
  let frame = Top_window.mouse_set_active (Window.top frame.frm_window) in
  find_implementation frame
@

<<constant Ocaml_toplevel.mode>>=
let mode = Ebuffer.new_minor_mode "compiler" []
@

<<constant Ocaml_toplevel.local_map>>=
let local_map = define_option ["ocaml_compiler_mode"; "local_map"] ""
    (list_option binding_option) []
@

<<toplevel Ocaml_toplevel._1>>=
let _ = 
  if !!local_map = [] then 
    local_map =:= [
      [c_c; ControlMap, Char.code 'i'] , "ocaml_mode.find_implementation";
      [c_c; ControlMap, XK.xk_BackSpace], "ocaml_mode.backward_implementation";
      [c_c; ControlMap, Char.code 't'], "ocaml_mode.print_type";
    ];
  Keymap.add_binding mode.min_map [ControlMap, XK.xk_Pointer_Button1]
    mouse_find_implementation
@

<<toplevel Ocaml_toplevel._2>>=
let _ = 
  define_buffer_action "ocaml_compiler_mode" 
    (fun buf -> 
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode);
  define_action "ocaml_compiler_mode.find_implementation" find_implementation;
  define_action "ocaml_compiler_mode.backward_implementation" backward_implementation;
  define_action "ocaml_compiler_mode.print_type" print_type;
@


%-------------------------------------------------------------

<<prog_modes/ocaml_toplevel.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                             Efuns                                   *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Ocaml_mode
open Options
open Text
open Efuns
open Interactive
open Simple
open Select
open Compil
open Eval
open Complex
open Abbrevs  
open Env
open Types
open Keymap
open Window
open Location
open Compat_comp
open Type
open Ocaml_env
  
<<function Ocaml_toplevel.type_buffer>>

<<constant Ocaml_toplevel.compiled_idents>>

<<function Ocaml_toplevel.all_idents>>

<<function Ocaml_toplevel.find_value_type>>
    
<<function Ocaml_toplevel.print_type>>

<<constant Ocaml_toplevel.back_list>>
          
<<function Ocaml_toplevel.find_implementation>>

<<function Ocaml_toplevel.backward_implementation>>
      
<<function Ocaml_toplevel.mouse_find_implementation>>
  
  

<<constant Ocaml_toplevel.mode>>

<<constant Ocaml_toplevel.local_map>>
<<toplevel Ocaml_toplevel._1>>

<<toplevel Ocaml_toplevel._2>>

@

\section{[[ipc/]]}

\subsection*{[[ipc/server.ml]]}

<<constant Server.efuns_property>>=
let efuns_property = "_EFUNS_SERVER"  
@

<<constant Server.user>>=
let user = try Sys.getenv "USER" with _ -> "noname"
@

<<constant Server.socket_name>>=
let socket_name = (Printf.sprintf "/tmp/efuns-server.%s.%s:0" user !displayname)
@

<<constant Server.started>>=
let started = ref false
@

<<type Server.proto>>=
type proto =
  LoadFile of string * int * string
@

<<function Server.read_command>>=
let read_command fd frame =
  let inc = in_channel_of_descr fd in
  try
    let cmd = input_value inc in
    match cmd with
      LoadFile (name,pos,str) ->
        let window = frame.frm_window in
        let top_window = Window.top window in
        wrap top_window (fun top_window ->
            let frame = Frame.load_file window name in
            if pos <> 0 then
              let buf = frame.frm_buffer in
              let text = buf.buf_text in
              let point = frame.frm_point in
              try
                if str = "" then raise Not_found else                  
                let regexp = Str.regexp_string str in
                let len = Text.search_forward text regexp point in
                ()
              with
                Not_found -> 
                  Text.set_position text point pos
        ) ()
  with
    _ -> Concur.Thread.remove_reader fd 
@

<<function Server.module_accept>>=
let module_accept s frame = 
  let fd,_ = accept s in
  Unix.set_close_on_exec fd;
  Concur.Thread.add_reader fd (fun _ -> read_command fd frame)
@

<<function Server.start>>=
let start frame =
  if not !started then
  let top_window = Window.top frame.frm_window in
  Utils.catchexn "Efuns server:" (fun _ ->
      let s = Unix.socket PF_UNIX SOCK_STREAM 0 in
      if Sys.file_exists socket_name then Unix.unlink socket_name;
      Unix.bind s (ADDR_UNIX socket_name);
      Unix.listen s 254;
      Unix.set_nonblock s;
      Unix.set_close_on_exec s;
      let display = top_window.top_root#display  in
        Concur.Thread.add_reader s (fun _ -> 
            started := true;
            module_accept s frame);
      let atom = X.internAtom display efuns_property false in
      X.changeProperty display top_window.top_root#window 
        PropModeReplace atom XA.xa_string 1 socket_name;
  )  
@
% todo: no M-x server-start?

%-------------------------------------------------------------

<<ipc/server.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                             ____                                    *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Efuns
open Xtypes
open Unix  
open Top_window
  
<<constant Server.efuns_property>>
<<constant Server.user>>
<<constant Server.socket_name>>

<<constant Server.started>>
  
<<type Server.proto>>
  
<<function Server.read_command>>
  
<<function Server.module_accept>>
  
<<function Server.start>>
  

@


\subsection*{[[ipc/efuns_client.ml]]}

<<constant Efuns_client.pos>>=
let pos = ref 0
@

<<constant Efuns_client.string>>=
let string = ref ""
@

<<constant Efuns_client.filename>>=
let filename = ref None
@

<<toplevel Efuns_client._1>>=
let _ = Arg.parse [
    "-pos", Arg.Int (fun i -> pos := i)," <int>: set position";
    "-str", Arg.String (fun s -> string := s)," <string>: search string";
  ] (fun name -> filename := Some name)
  "efuns_server: connect to efuns"
@

<<constant Efuns_client.pos (client/efuns_client.ml)>>=
let pos = !pos    
@

<<constant Efuns_client.filename (client/efuns_client.ml)>>=
let filename = match !filename with
    None -> failwith "efuns_server: filename missing"
  | Some s -> s
@

<<constant Efuns_client.string (client/efuns_client.ml)>>=
let string = !string
@

<<constant Efuns_client.filename (client/efuns_client.ml)2>>=
let filename = if is_relative filename then 
    concat (getcwd ()) filename else filename
@

<<constant Efuns_client.efuns_property>>=
let efuns_property = "_EFUNS_SERVER"  
@

<<constant Efuns_client.display>>=
let display = Xlib.openDisplay ""
@

<<constant Efuns_client.root>>=
let root = display.dpy_roots.(0).scr_root
@

<<constant Efuns_client.atom>>=
let atom = X.internAtom display efuns_property false
@

<<constant Efuns_client.socket_name>>=
let socket_name = (Xlib.getWholeProperty display root atom).gp_value
@

<<toplevel Efuns_client._2>>=
let _ =  if not (Sys.file_exists socket_name) then raise Not_found
@

<<toplevel Efuns_client._3>>=
let _ =  
  output_value outc (LoadFile (filename,pos,string)); flush outc
@


%-------------------------------------------------------------

<<ipc/efuns_client.ml>>=
open Server  
open Xtypes
open Unix
open Sys
open Filename
  
<<constant Efuns_client.pos>>
<<constant Efuns_client.string>>
<<constant Efuns_client.filename>>
  
<<toplevel Efuns_client._1>>
  
<<constant Efuns_client.pos (client/efuns_client.ml)>>
<<constant Efuns_client.filename (client/efuns_client.ml)>>
<<constant Efuns_client.string (client/efuns_client.ml)>>
    
<<constant Efuns_client.filename (client/efuns_client.ml)2>>
    
<<constant Efuns_client.efuns_property>>

<<constant Efuns_client.display>>
<<constant Efuns_client.root>>
<<constant Efuns_client.atom>>
<<constant Efuns_client.socket_name>>
<<toplevel Efuns_client._2>>
let (inc,outc) = open_connection (ADDR_UNIX socket_name)
<<toplevel Efuns_client._3>>
  
@


\section{[[dynamic/]]}

\subsection*{[[dynamic/eval.ml]]}

<<function Eval.try_load>>=
let try_load top_window f =
  try
    f (); 
    Efuns.init top_window.top_location
  with
    Dynlink.Error error ->
      Top_window.message top_window (Dynlink.error_message error)
  | e -> 
      Top_window.message top_window
        (Printf.sprintf "Exception %s" (Printexc.to_string e))
@

<<function Eval.load>>=
let load top_window mod_name =
  try_load top_window (fun () -> load_module mod_name)
@

<<function Eval.load_library>>=
let load_library frame =
  select_lib_filename frame "Load library: " 
    (fun str ->
      let top_window = Window.top frame.frm_window in
      try_load top_window (fun () -> load_file str))
@

<<function Eval.eval_buffer>>=
let eval_buffer frame =
  let top_window = Window.top frame.frm_window in
  let location = top_window.top_location in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let filename = Filename.temp_file "buffer" ".ml" in
  let outc = open_out filename in
  Text.save buf.buf_text outc;
  close_out outc;
  let cmd = "ocamlc -c -I " ^ Version.efuns_lib ^ " " ^ filename in 
  let end_action buf status =
    match status with
      0 -> try_load top_window 
          (fun _ -> 
            let fl =  ((Filename.chop_suffix filename ".ml") ^ ".cmo") 
            in 
            load_file fl;
            Efuns.init top_window.top_location)
    | _ -> 
        set_compilation_buffer frame buf (Filename.dirname filename);
        Top_window.message top_window "Error while compiling buffer"
  in
  System.system "*Eval*" location cmd end_action |> ignore
@


%-------------------------------------------------------------

<<dynamic/eval.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)


open Efuns
open Text
open Frame
open Simple
open Select
open Search
open Compil

  (*
let rec load_module mod_name =
  let filename = (String.uncapitalize mod_name) ^ ".cmo" in
  try
    let filename = Utils.find_in_path !Efuns.load_path filename in
    load_file filename
  with
    Not_found -> failwith ("Can't find file "^filename)

and load_file filename =
  try
    Dynlink.loadfile filename
  with
    Dynlink.Error (Dynlink.Unavailable_unit mod_name) -> 
      load_interface mod_name;
      load_file filename
  | Dynlink.Error (
    Dynlink.Linking_error (_, Dynlink.Undefined_global mod_name)) ->
      load_module mod_name;
      load_file filename

and load_interface mod_name =
  try
    Dynlink.add_interfaces [mod_name] !Efuns.load_path; ()
  with
    Not_found ->
      failwith (Printf.sprintf "No interface for %s" mod_name)
      *)

open Dyneval

<<function Eval.try_load>>

<<function Eval.load>>

<<function Eval.load_library>>

  
<<function Eval.eval_buffer>>
@


\section{[[misc/]]}

\subsection*{[[misc/efuns_filebrowser.ml]]}

<<constant Efuns_filebrowser.argv>>=
let argv = Array.to_list Sys.argv
@

<<constant Efuns_filebrowser.regexps>>=
let regexps = List.map (fun str -> str, 
      Str.regexp (Utils.glob_to_regexp str)) (
    match argv with
      program :: dirname :: strs -> strs
    | _ -> failwith "Usage: efuns_filebrowser dirname [regexps]")
@

<<constant Efuns_filebrowser.dirname>>=
let dirname = ref (if Filename.is_relative Sys.argv.(1) then
      Filename.concat (Sys.getcwd ()) Sys.argv.(1) else Sys.argv.(1))
@

<<constant Efuns_filebrowser.display>>=
let display = new WX_display.t ""
@

<<constant Efuns_filebrowser.root>>=
let root = new WX_root.t display 0
@

<<constant Efuns_filebrowser.top>>=
let top = new WX_appli.t root [MinWidth 10; MinHeight 10; MaxHeight (root#height - 200)]
@

<<constant Efuns_filebrowser.adx>>=
let adx = new WX_adjust.t ()
@

<<constant Efuns_filebrowser.ady>>=
let ady = new WX_adjust.t ()
@

<<constant Efuns_filebrowser.hbar>>=
let hbar = new WX_bar.h top#container []
@

<<constant Efuns_filebrowser.viewport>>=
let viewport = new WX_viewport.t hbar#container adx ady []
@

<<constant Efuns_filebrowser.scrollbar>>=
let scrollbar = new WX_scrollbar.v hbar#container ady []
@

<<constant Efuns_filebrowser.tree>>=
let tree = new WX_tree.t viewport#container []
@

<<function Efuns_filebrowser.load>>=
let load filename =
  Sys.command(Printf.sprintf "efuns_server %s &" filename) |> ignore
@

<<function Efuns_filebrowser.iter_load>>=
let rec iter_load closed dirname basename container =
  try
    let dirname = Filename.concat dirname basename in
    let filenames = Sort.list (<=) (Utils.list_dir dirname) in
    let subdirs = List.fold_left (fun files filename ->
          if filename <> "." && filename <> ".." then
            let fullname = Filename.concat dirname filename in
            let stats = lstat fullname in
            if stats.st_kind = S_DIR then filename::files else
              files
          else files
      ) [] filenames in
    let file_lists = List.fold_left (fun lists (name,regexp) ->
          let newlist = List.rev (List.fold_left (fun files filename ->
                if Str.string_match regexp filename 0 then filename :: files
                else files
              ) [] filenames) in
          let rec iter pos newlist addlist lists =
            match newlist with
            | ele :: tail -> 
                if pos mod 15 = 0 then
                  iter 1 tail [] (((
                        Printf.sprintf "%s[to %s]" name ele), (ele::addlist)) :: lists)
                else
                  iter (pos+1) tail (ele::addlist) lists
            |   [] -> match addlist with [] -> lists | _ -> 
                    (name,addlist) :: lists
          in
          let newlists = iter 1 newlist [] [] in
          match newlists with
            [] -> lists
          | _ -> (List.rev newlists) @ lists
      ) [] regexps in
    (List.map (fun subdir ->
          let label = new WX_label.t container subdir [] in
          let tree  = new WX_tree.t container [] in
          tree#set_desc (iter_load true dirname subdir tree#container);
          branch true label#contained tree#contained
      ) subdirs) @ (
      List.map (fun (name,files) -> 
          let label = new WX_label.t container name [] in
          let tree  = new WX_tree.t container [] in
          tree#set_desc (List.map (fun filename ->
                let label = new WX_button.with_label tree#container filename 
                  [IpadX 0; IpadY 0] 
                  in
                label#set_action (fun () -> 
                    load (Filename.concat dirname filename));                
                leaf 0 label#contained
            ) (List.rev files));
            branch true label#contained tree#contained         
      ) file_lists
    )
  with
    _ -> []
@

<<constant Efuns_filebrowser.file_menu>>=
let file_menu = [|
    "Open", (fun _ -> 
        let info = {
            filter = Filename.concat !dirname  "*";
            current_selection= !dirname;
            predicat = (fun _ -> true);
            action = (fun s -> 
                tree#destroy_desc;
                dirname := s;
                tree#set_desc (
                  iter_load false (Filename.dirname s) (Filename.basename s)
                  tree#container));
            cancel = (fun _ -> ());
          }    in
        let filesel = new WX_filesel.t root info [] in
        filesel#show
        );
    "Quit", (fun _ -> exit 0);
  |]
@

<<toplevel Efuns_filebrowser._1>>=
let _ =
  tree#set_desc (iter_load false (Filename.dirname Sys.argv.(1))
    (Filename.basename Sys.argv.(1))
    tree#container);
  top#container_add hbar#contained;
  hbar#container_add_s [viewport#contained; scrollbar#contained];
  viewport#container_add tree#contained;
  top#setWM_NAME (Printf.sprintf "File Browser: %s" Sys.argv.(1));
  top#add_menu "File" file_menu;
  top#show;
  loop ()
@


%-------------------------------------------------------------

<<misc/efuns_filebrowser.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                             ____                                    *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Xtypes
open WX_types
open WX_tree
open Unix

<<constant Efuns_filebrowser.argv>>
<<constant Efuns_filebrowser.regexps>>

<<constant Efuns_filebrowser.dirname>>
  
<<constant Efuns_filebrowser.display>>
<<constant Efuns_filebrowser.root>>
<<constant Efuns_filebrowser.top>>
<<constant Efuns_filebrowser.adx>>
<<constant Efuns_filebrowser.ady>>
<<constant Efuns_filebrowser.hbar>>
<<constant Efuns_filebrowser.viewport>>
<<constant Efuns_filebrowser.scrollbar>>
<<constant Efuns_filebrowser.tree>>

<<function Efuns_filebrowser.load>>

<<function Efuns_filebrowser.iter_load>>

open WX_filesel
  
<<constant Efuns_filebrowser.file_menu>>
  
<<toplevel Efuns_filebrowser._1>>
@


\subsection*{[[misc/efuns_texbrowser.ml]]}

<<constant Efuns_texbrowser.display>>=
let display = new WX_display.t ""
@

<<constant Efuns_texbrowser.root>>=
let root = new WX_root.t display 0
@

<<constant Efuns_texbrowser.top>>=
let top = new WX_appli.t root [MinWidth 10; MinHeight 10]
@

<<constant Efuns_texbrowser.tree>>=
let tree = new WX_tree.t top#container []
@

<<constant Efuns_texbrowser.regexp>>=
let regexp = Str.regexp "\\(\\input\\|\\section\\|\\subsection\\|\\subsubsection\\|\\chapter\\)[*]?{\\([^}]+\\)}"
@

<<function Efuns_texbrowser.load>>=
let load filename pos all =
  let _ = Sys.command(Printf.sprintf "efuns_server %s -pos %d -str \"%s\" &" filename pos all)
  in ()
@

<<constant Efuns_texbrowser.filename>>=
let filename = ref (if Array.length Sys.argv = 2 then
      Sys.argv.(1) else 
      failwith "Usage: efuns_texbrowser filename")
@

<<constant Efuns_texbrowser.dirname>>=
let dirname = ref (Filename.dirname !filename)
@

<<constant Efuns_texbrowser.path>>=
let path = ref [ !dirname ]
@

<<function Efuns_texbrowser.iter_load>>=
let rec iter_load closed filename container =
  let label = new WX_button.with_label container filename [] in
  try
    let filename = try
        Utils.find_in_path !path filename
      with Not_found -> 
          Utils.find_in_path !path (filename^".tex")
    in
    label#set_action (fun () -> load filename 0 "");
    let inc = open_in filename in
    let s = Utils.read_string inc in
    close_in inc;
    let rec iter_search pos list = 
      try
        let newpos = Str.search_forward regexp s pos in
        let keyword = Str.matched_group 1 s in
        let all = Str.matched_group 0 s in
        iter_search (newpos+String.length keyword) (
          (all, keyword,Str.matched_group 2 s,newpos)::list)
      with
        _ -> List.rev list
    in
    let list =  iter_search 0 [] in
    if list = [] then leaf 0 label#contained else
    let tree2 = new WX_tree.t container [] in
    tree2#set_desc (List.map (
        fun (all,keyword,name,pos) -> 
          match keyword with
            "input" -> iter_load true name tree2#container
          | _ ->
              let (offset,prefix) =
                match keyword with
                  "section" -> 0, "s:"
                | "subsection" -> 10, "ss:"
                | "subsubsection" -> 20, "sss:"
                | _ -> 30,""
              in
              leaf offset (
                  let button = new WX_button.with_label tree2#container (
                      prefix^name) [] 
                  in
                  button#set_action (fun () -> load filename pos all);
                  button#contained
                  )
      ) list);
    branch closed label#contained tree2#contained
  with
    _ -> 
      leaf 0 label#contained
@

<<constant Efuns_texbrowser.file_menu>>=
let file_menu = [|
    "Open", (fun _ -> 
        let info = {
            filter = Filename.concat !dirname  "*.tex";
            current_selection= !dirname;
            predicat = (fun _ -> true);
            action = (fun s -> 
                tree#destroy_desc;
                filename := s;
                dirname := Filename.dirname s;
                top#setWM_NAME (Printf.sprintf "LaTeX Browser: %s" !filename);
                tree#set_desc [iter_load false s tree#container]);
            cancel = (fun _ -> ());
          }    in
        let filesel = new WX_filesel.t root info [] in
        filesel#show              
        );
    "Quit", (fun _ -> exit 0);
  |]
@

<<toplevel Efuns_texbrowser._1>>=
let _ =
  tree#set_desc [iter_load false Sys.argv.(1) tree#container];
  top#setWM_NAME (Printf.sprintf "LaTeX Browser: %s" !filename);
  top#container_add tree#contained;
  top#add_menu "File" file_menu;
  top#add_button "Reload" (fun _ () ->
      tree#destroy_desc;
      tree#set_desc [iter_load false !filename tree#container];      
  );
  top#add_separator;
  top#show;
  loop ()
@


%-------------------------------------------------------------

<<misc/efuns_texbrowser.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                             ____                                    *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Xtypes
open WX_types
open WX_tree


<<constant Efuns_texbrowser.display>>
<<constant Efuns_texbrowser.root>>
<<constant Efuns_texbrowser.top>>
<<constant Efuns_texbrowser.tree>>

<<constant Efuns_texbrowser.regexp>>

<<function Efuns_texbrowser.load>>

<<constant Efuns_texbrowser.filename>>
  
<<constant Efuns_texbrowser.dirname>>
<<constant Efuns_texbrowser.path>>
  
<<function Efuns_texbrowser.iter_load>>

open WX_filesel
  
<<constant Efuns_texbrowser.file_menu>>

<<toplevel Efuns_texbrowser._1>>
@


