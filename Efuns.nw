\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history:
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - better decomposition than simple.ml, complex.ml, good TOC
% - removed deadcode (frm_force_point, frm_force_cursor, loc_counter, 
%    resname, buf_history, line_hlt and its huge compute_representation code,
%    repr_x)
% - cleaner conventions and field names between point and position, no more
%   let point = point.point uglyness
% - use global for location instead of all those fields
% - removed useless opti around representation, and rename line_repr,
%   repr_line; use boxes instead. 'repr' was used for too many things.

%thx to codemap/codegraph/scheck:
% - SEMI use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - SEMI use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand Emacs:
% - the minibuffer is really a buffer/frame like the other :)
% - the modeline is actually associated with each window
% - representation string vs original string, tabs and ^M display handling
% - TODO how the mark get changed when you do big move?
% - TODO the global vs local variables, I always get confused about
%    local variables

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO action
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the Extra section in the main file
% - SEMI understand main(), LP split main, improve TOC
% - SEMI understand main functions, LP split, cluster, improve TOC
% - SEMI LP split the structures, use datalog for flow to field info
% - TODO aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for redundant copyrights, pad special keybindings

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: The Text Editor Efuns
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Fabrice Le Fessant
}


\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2015 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a text editor.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% I chose efuns, an emacs clone, simple, elegant. Also different language
% than previous books. Written in ocaml! more high level than C, and while
% you want to write a kernel in C, it makes more sense for an app
% to use a higher level language like ocaml!

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item emacs
%too big, xdisp.c is a single file of 30 000 LOC ... more than the whole
% efuns
%todo: look at emacs lisp manual, and emacs manual to see the concepts
\item microemacs
% the source of many forks apparently, so maybe the code is cleaner?
% uemacs, one of them, used by torvalds, is 20 000 LOC so not bad
\item qemacs
% size? unicode support! complex html/css visualization, multi fonts
\item mg
%mg, micro gnu emacs, 20 000 LOC
%http://homepage.boetes.org/software/mg/
\end{itemize}

% see Editor.nw for more choices

% vs emacs:
%  - see http://www.emacswiki.org/emacs/EfunsEditor
%  - no extension language (lisp) to extend the editor with plugins.
%    It made sense for Emacs because the implementation language
%    was C, which is more error prone than lisp, but by using OCaml
%    for the implementation language we don't need so much another 
%    language to extend the core. You can just add a module! Yes you need
%    to recompile, but so what? less dynamic, but anyway
%    in emacs case I usually do it via modifying my .emacs and
%    very often reloading my emacs (buy maybe I'm not a good dynamic
%    programmer)
%  - easier to debug! can use ocamldebug, no more -debug-on-error
%    and binary search in .emacs when have a paren pb
%  - easier to program, ocaml > lisp! can also use ocamlyacc, my
%    pfff real parsers. More colors. More structure.

% see also other ocaml editors?
%  - https://github.com/diml/zed (seems just an "engine")

\section{Getting started}

\section{Requirements}

\section{About this document}
#include "docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from INRIA, so
those parts are copyright by INRIA.
The prose is mine and is licensed under the GNU Free Documentation
License.

<<copyright header efuns>>=
(***********************************************************************)
(*                                                                     *)
(*                             Efuns                                   *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)
@

\ifallcode
<<copyright header>>=
(***********************************************************************)
(*                                                                     *)
(*                             ____________                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)
@

<<copyright header2>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)
@
\fi

\section{Acknowledgments}

I would like to thank of course Fabrice Le Fessant,
the main author of Efuns.

\chapter{Overview}

\section{Text editor principles}

% as opposed to ed, can actually see the content! and update it
% and get feedback in real-time. wysiwyg!

% navigating in file (fast, different granularities), random access!
% editing (inserting/deleting/moving/cut-copy-paste/transposing)
% search/replace

% special chars (^M, Tabs), overflow (80 cols)

% efficient keyboard! combination of keys, macros! M-x, C-x o
% everything with keyboard!

% undo! multi steps undo! redo! sessions so have also "macro-level" undo
% multi files/buffers, opening/saving/killing switching
% multi windows (a kind of window manager!) so can see different parts at
%  the same time

% specialised "major" modes: color!, font, indentation, navigating
%todo: semantic editing/visualizing!

% "Emacs is the extensible, customizable, self-documenting real-time
% display editor."

% "everything is a buffer!"
% When I needed to implement a shell/terminal, well
% a lot of what a terminal does is managing input, let user edit
% the line, and this is for free in a buffer! want to move around
% at the end of the line, bol, again, free or have all the building blocks!
% Want completion, can reuse dabbrev!
% Also everything is a buffer with a customizable keymap! so can
% have TAB, return, C-a, etc means different things in different modes!

%emacs:
% extensible => open source, external commands
% customizable => configuration file
% self-documenting => not really yet? M-x a bit. Have Efuns.nw though :)

% interactive! (useful for .e.g C-h v)

% see <<actions definitions>>, pretty good overview of functionalities

% actions activated by = 
% - keyboard (self insert, keybinding, M-x)
% - mouse (menu, window clicks to quickly navigate)

\section{[[efuns]] services}

% ./efuns foo.txt

<<constant Efuns.usage_str>>=
let usage_str =
 "A small editor entirely written in Objective Caml 
by Fabrice LE FESSANT, INRIA Rocquencourt, FRANCE
http://pauillac.inria.fr/efuns
Options:
"
@

\section{Code organization}

%from guide.txt:

%Internals:
%text.ml: The GAP buffer (self-contained)
%efuns.ml: Types and basic values
%main.ml: The main() function ...
%buffer.ml: Functions to handle buffer structures internals
%window.ml: Handling of simulated text windows
%frame.ml: Functions to handle frame structures internals
%top_window.ml: Communication with the Xterm widget
%keymap.ml: Functions to handle keyboard mappings
%minibuffer.ml: Minibuffer functions
%%NOMORE misc.ml: Useful functions
%str2.ml: Addons to the Str module (replace_matched)
%
%Functions:
%simple.ml: Basic functions (insertion, etc ...)
%complex.ml: More complex functions (with minibuffer)
%interactive.ml: Interactive functions handling (M-x)
%abbrevs.ml: Static and Dynamic abbrevs
%system.ml:  Functions to handle external processes
%compile.ml: Functions for error search after compilation
%search.ml: Searchs and replacements
%time.ml: Time functions
%select.ml: Useful functions to ask the user in the minibuffer
%eval.ml: Dynamic load of external modules (Dynlink)
%multi_frames.ml: Handling of multiple text windows in one Xterm widget
%
%parsers.mly: Various useful parsers (/etc/passwd)
%lexers.mll: Various useful lexers (/etc/passwd, filenames)
%
%Major modes:
%ocaml_mode.mll: The Ocaml mode
%?? WHERE? ocamlc.ml:  Functions to read .cmi data from the Ocaml compiler
%?? WHERE?  printtyp.ml: The type pretty printer from the Ocaml compiler
%tex_mode.mll: The TeX mode
%c_mode.mll: The C mode
%lisp_mode.ml: The Lisp mode (is this really useful ? yes, I use GWM as
%  window-manager :)
%html_mode.mll: The HTML mode
%makefile_mode.ml: The Makefile mode (Tabulation)
%
%Minor modes:
%accents_mode.ml: Accents for QWERTY keyboards (e' => é, e'' => e', ...)
%
%Config:
%std_efunsrc.ml: Standard bindings (except those defined in other modules)


\section{Software architecture}

%TODO: figure: show graphical window first! so can see concepts
% of frames, status line, minibuffer (which don't have status lines), etc!
% can actually show 2 windows, so can see 2 status line.

% the world (Location) that encapsulates
%  Windows/Frames, with then Buffers, with then Text inside
%
% Event loop with keyboard dispatch to the right action and
% right focused frame, taking itself the frame in parameter
%
% redisplay engine (actually incremental line oriented display)
% triggered after each event.


\section{Trace of a file loading}

% scenario

\section{Trace of a line rendering}

% also important is the flow from the text string to the screen:
% data -> 
% text_string -> 
% text_newlines ->
%   boxes + repr_string to handle special chars ->
% frm_table ->
%   boxes + frm_line that handles overflow lines ->
% screen

\section{Trace of a key press}

% event, event loop, keyboard dispatch, 
% try_map, find right map
% action (e.g. RETURN), effect
% rerendering!

% so if do M->, this has for effect to change the point to the end,
% and after the event loop it will trigger a display() for all
% frames that then will realize it needs to redraw itself
% because the point is now far away.
% Cool thing is that the code of M->  just has to care about
% moving a point, the rest is then automatic!


%###############################################################################

\chapter{Core Data Structures}

% text -> buffer -> frame/window -> top_window

\section{[[Text]]}

% text -> string | lines -> ... box
% with attrs at different level (text_attr, box_attr)

<<type Text.text>>=
type text = {
    mutable text_string : string;
    mutable text_size : int; (* String.length text.text_string *)

    mutable text_newlines : line array;
    mutable text_nlines : int; (* Array.length text.text_newlines *)
    <<[[Text.text]] gap fields>>
    <<[[Text.text]] history fields>>
    <<[[Text.text]] attribute fields>>
    <<[[Text.text]] other fields>>
  } 
@
% could put text_attrs also here.
% actually text_nlines can be more than text_newlines when start
% to extend the gap buffer

% need line because a text editor is line oriented, column number display,
% line display, lots of things are important to do at line level.
%todo: actually the real question is why you need text_string?
% because the line will not contain the content? they will just
% be indexed over text_string? except for repr_string but this
% is only used as a "cache" for what is displayed on the screen.


<<type Text.position>>=
type position = int
@
% was not used in .ml, was used in .mli and made abstract, but now 
% I use it also in .ml.
%less: could rename charpos too


<<type Text.line>>=
and line = {
    mutable position : position; (* bol (beginning of line) *)

    <<[[Text.line]] representation fields>>
    <<[[Text.line]] other fields>>
  } 
@

%old: was Line.position type
%$<<type Text.direct>>=
%type direct = int
%@
% but can use position above



<<type Text.version>>=
type version = int
@

<<[[Text.text]] history fields>>=
mutable text_modified : version;
@

<<function Text.version>>=
let version tree = 
  let text = tree.tree_text in
  text.text_modified
@
%less: tree? because of wx_text stuff, could remove that no?
%note that this goes up most of the time except when start to
% do some undo operations



%ctor
<<function Text.create>>=
let create str =
  let newlines = compute_newlines str in
  let attrs = (Array.create (String.length str) direct_attr) in

  let text =
    {
      text_string = str;
      text_size = String.length str;

      text_newlines = newlines;
      text_nlines = Array.length newlines;

      text_attrs = attrs;

      text_points = [];
      (* no gap at the beginning *)
      gpoint = { pos = 0; line = 0 };
      gsize = 0;

      text_modified = 0;
      text_clean = false;
      text_history = [];
      text_readonly = false;
    }
  in
  make_text text (Array.copy newlines)
@
% was let rec text, weird

%less: make_text()? should be a noop actually, and we could remove
% the Array.copy


<<function Text.compute_newlines>>=
let compute_newlines string =
  let (nbr_newlines,_) = Utils.count_char string '\n' in
  let newlines = Array.create (nbr_newlines + 2) (mk_line_with_pos 0) in
  let curs = ref 0 in
  (* newlines.(0) is already set with 0 position for its bol *)
  for i = 1 to nbr_newlines do
    let pos = String.index_from string !curs '\n' in
    newlines.(i) <- mk_line_with_pos (pos+1);
    curs := pos + 1;
  done;
  newlines.(nbr_newlines+1) <- mk_line_with_pos (String.length string + 1);
  newlines
@
% we Array.create nbr_newlines + 2 because :
% - even if the string has no newline we still need a array[1] at least
% - we count the EOF has its own newline, a sentinel? maybe simpler
%   that way indeed, I remember I had many Commons.line_xxx functions
%   to handle those special cases.
%   For instance in compute_representation one can do:
%     let end_pos = text.text_newlines.(n+1).position - 1 in
%   without being scared of an array out of bound exception
% so an empty file will have first empty line, and then a line with just EOF.

<<function Text.nbre_lines>>=
let nbre_lines tree = 
  let text = tree.tree_text in
  text.text_nlines - 2
@
%less: rename? french name?

<<function Text.mk_line_with_pos>>=
let mk_line_with_pos pos = 
  {
   position = pos; 

   boxes = []; 
   repr_string = ""; 
   repr_len = 0; 
   line_modified = true; 
  }
@
% was line_modified = 0
% will see those fields later


\section{[[Buffer]]}

%"The buffer corresponds either to a file (thus to a filename) either to
%a virtual file (for example, compilation messages). The file text itself
%is stored in the Text.t type."

<<type Efuns.buffer>>=
(* a buffer containing a file in Text.t *)
and buffer =
  { 
    mutable buf_text : Text.t;

    mutable buf_name : string;
    mutable buf_filename : string option;

    <<[[Efuns.buffer]] current position fields>>
    <<[[Efuns.buffer]] history fields>>
    <<[[Efuns.buffer]] other fields>>
  } 
@
% string option because have some buffers like *Messages*
%  that are not connected to a file
% buf_name should be unique, because it's used as a key to
% the location.loc_buffers hashtbl (see also get_name())

% diff with Text? 
% - have a name, Text is really just the content. 
%   Here it's connected to a file. 
% - it has also a buf_point (and later a frame will have a cursor),
%   see below
% - it has a major mode, minor modes, a keymap, local variables
%   see in next chapters


% point is an important notion!
<<type Text.point>>=
and point = {
    mutable pos : position;
    mutable line : int;
  }
@
% the first field is a charpos, not a column. The additional .line(was y) is
% to quickly know the line number so can index in the text.text_newlines array
% and do certain stuff.
% Most of the time what you care is really point.pos though.

%old: was point.point and point.point_y but it was confusing as you
% would expect then a point_x which the first field is really not. It's more
% consistent to have point_line. It was also ugly to have point.point
% everywhere and code like let point = point.point. It was confusing
% two notions, a position and a point!

<<[[Efuns.buffer]] current position fields>>=
mutable buf_point : Text.point;
mutable buf_start : Text.point;
@
% current!
% which will be the saved value from frm_point
% when switch between buffers; the current frame is a view
% on different buffers, but when you go back to a buffer you
% want the cursor to be at the same position you used to be
% (and the screen start at the same starting point too).
% (hence the need for M-x pad-make-indirect-buffer)

% there are also a list of points maintained by the Text itself, why?
% because of gap things can move so you need to update all
% the points. See section on Points later.

<<[[Efuns.buffer]] history fields>>=
mutable buf_modified : int; (* version? *)
@
%less: diff with text_modified? seems to be about modification of the
% buffer property itself, not the underlying text


<<function Ebuffer.create>>=
let create name filename text local_map =
  let name = get_name name in
  let buf =
    { 
      buf_text = text;

      buf_name = name;
      buf_filename = filename;

      buf_point = Text.new_point text;
      buf_start = Text.new_point text;

      buf_last_saved = Text.version text;
      buf_modified = 0;

      buf_map = local_map;

      buf_syntax_table = default_syntax_table;
      buf_map_partial = true;
      buf_vars = Local.vars ();
      buf_minor_modes = [];
      buf_major_mode = fondamental_mode;

      buf_sync = false;
      buf_mark = None;
      buf_shared = 0;
      buf_finalizers = [];

      <<[[Ebuffer.create()]] buffer other fields setup>>

    } in
  <<[[Ebuffer.create()]] adjust location global fields>>
  <<[[Ebuffer.create()]] adjust charreprs>>
  <<[[Ebuffer.create()]] run hooks>>
  buf
@



\section{[[Frame]]}

% It's not frame in emacs terminology.
% It's really a window, but with not just
%  the geometric info, it packs together geometric info (window type)
%  and buffer info (buffer type)
% The cursor is here! not in the buffer.

% can have different windows/frames over a single buffer.
% convenient so can view different parts of the file at once.

% "A frame is a text window with a buffer inside."

<<type Efuns.frame>>=
(* a frame: a view of a buffer for a window *)
and frame  =
  {
    mutable frm_buffer : buffer;

    mutable frm_xpos : int;
    mutable frm_ypos : int;
    
    mutable frm_width : int;
    mutable frm_height : int; (* including status line *)

    <<[[Efuns.frame]] current position fields>>
    <<[[Efuns.frame]] window fields>>
    <<[[Efuns.frame]] decoration fields>>
    <<[[Efuns.frame]] status field>>
    <<[[Efuns.frame]] history fields>>
    <<[[Efuns.frame]] other fields>>
  } 
@
%dead: mutable frm_force_point : bool;
%dead: mutable frm_force_cursor : bool;
%less: coordinates? seems redundant with frm.frm_window info no?
% xpos are in line x col dimentions, same for width and height,
% not pixels!
%later: if decide to have variable size fonts we'll have to revisit
% this no? emacs 21 did that?

<<[[Efuns.frame]] current position fields>>=
(* insert point *)
mutable frm_point : Text.point; 
@
% current!
% cursor!
% if you change that in an action, then at the redisplay (end of
% event loop) the screen will move to that place if it's not visible
% => API for actions are simple, just set the position and
% the redisplay will be automatic.

<<[[Efuns.buffer]] other fields>>=
mutable buf_shared : int; (* number of frames for that buffer *)
@
%less: why need that? ocaml has a gc anyway ...

% Top_window.create | Frame.create | Frame.create_inactive -> <>
<<function Frame.create_without_top>>=
let create_without_top window mini buf =
  let text = buf.buf_text in

  let frm_start = Text.dup_point text buf.buf_start in
  let point     = Text.dup_point text buf.buf_point in
  let frm_end   = Text.dup_point text buf.buf_start in (* ?? *)

  buf.buf_shared <- buf.buf_shared + 1;

  <<[[Frame.create_without_top()]] let status>>

  let frame =
    { frm_buffer = buf;

      frm_window = window;
      frm_xpos = window.win_xpos;
      frm_ypos = window.win_ypos;
      frm_width = window.win_width;
      frm_height = window.win_height;

      frm_start = frm_start;
      frm_point = point;
      frm_end = frm_end;

      frm_x_offset = 0;
      frm_y_offset = 0;

      frm_cursor_x = 0;
      frm_cursor_y = 0;
      frm_cursor = String.make 1 ' ';
      frm_cursor_attr = Text.direct_attr;

      frm_last_text_updated = 0;
      frm_last_buf_updated = 0;

      frm_redraw = true;

      frm_has_scrollbar = 0;
      frm_has_status_line = 1;
      frm_status = status;
      frm_mini_buffer = mini;
      
      frm_prefix = [];
      
      frm_last_action = Keymap.dummy_action;

      frm_force_start = false;
      frm_cutline = window.win_width - 1;
      frm_killed = false;

      frm_table = [||];
    } 
  in
  <<[[Frame.create_without_top()]] adjust status of frame>>

  install window frame;
  frame
@
% many many fields ...
% install!!

\section{[[Window]]}

% It's a window in Emacs terminology. And it's really
% just the geometry part.

%todo: rename? frame_config? frame_window?

<<type Efuns.window>>=
and window =
  { 
    mutable win_xpos : int;
    mutable win_ypos : int;

    mutable win_width : int;
    mutable win_height : int; (* including status line *)

    <<[[Efuns.window]] other fields>>
  } 
@

<<[[Efuns.frame]] window fields>>=
mutable frm_window : window;
@
%less: why need that field in frame? frm_xpos not enough?


<<[[Efuns.window]] other fields>>=
mutable win_down : window_down;
mutable win_up : window_up;
@
%subtle: up is to allow access to upper window; it was used
% for access top_location (but now I use a global), but
% I think it's still useful for Window.next to know
% what is up and do things. Also in a multiple toplevel windows
% context, we need that I think, because we can't use
% a single top_window global.
% We will see later than the action type takes a frame as a parameter, and
% so each action must be able from a frame to access all 
% necessary information, hence the win_up field too.

<<type Efuns.window_down>>=
and window_down =
| WFrame of frame
| NoFrame of unit

| HComb of window * window 
| VComb of window * window
@
% that's the important part! 
%less: why of unit?

<<type Efuns.window_up>>=
and window_up =
  Window of window
| TopWindow of top_window
@
% this makes the structures mutually recursive!
% from a top_window -> window and can get back the top_window back


<<function Window.top>>=
let rec top window = 
  match window.win_up with
  | TopWindow top_window -> top_window
  | Window window -> top window
@
% often used then to access the location, but
% not sure why you need that since the location
% is also accessible in the frame and buffer
%less: make it a global?

<<function Window.create>>=
let create mini up_window xpos ypos width height =
  {
  win_xpos = xpos;
  win_ypos = ypos;

  win_width = width;
  win_height = height;

  win_down = NoFrame (); 
  win_up = up_window;

  win_mini = mini;
  }
@
% will see mini later


\section{The [[Top_window]]}
%todo: LPize Topwindow in window_up and put it here

%"The top_window structure corresponds to an Xterm widget (one X window).
%From the top_window structure, you have access to text windows (window type)
%displayed inside the Xterm widget. Windows are organized as a binary tree,
%where branchs are either horizontal or vertical combinaisons, and leaves are
%frames (frame window). A frame is a text window with a buffer inside."


<<type Efuns.top_window>>=
(* an xterm: a window containing some frames *)
and top_window = 
  { 
    mutable top_name : string;

    mutable top_width : int;
    mutable top_height : int; (* including minibuffer line *)

    mutable window : window;

    <<[[Efuns.top_window]] other fields>>
  } 
@
% diff with window? no xpos, ypos here
% old: used to have a top_windows with an 's' but a bit weird,
%  and also to use top_windows where really it's windows,
%  so I renamed this field 'window' even though then it
%  breaks the conventions of having those top_xxx prefix
% less: rename window to windows? after all this window has some win_down

<<[[Efuns.top_window]] other fields>>=
mutable graphics : Xdraw.graphics_backend option;
@
%(*
%mutable top_root : WX_root.t;
%mutable top_appli : WX_appli.t;
%mutable top_scrollbar : WX_adjust.t;
%mutable top_term : WX_xterm.t;
%top_attrs : WX_xterm.xterm_gc option array;
%*)

<<[[Efuns.top_window]] other fields>>=
mutable top_active_frame : frame;
@
%current!



\section{The world, [[Location]]}
% full state

%"All the editor information is organised inside one structure: the location.
%The location grants access to all other structures inside the editor. This
%is done to easily save the editor state after a session (or to move it
%from one editor to another)."
% called location in LeFessant's terminology. Why? jocaml ancestry I think.
% There is a "loc" keyword in jocaml, and efuns was originally a demo
% for jocaml.


%(* the world *)
<<type Efuns.location>>=
type location =
  { 
    (* key is buffer name *)
    mutable loc_buffers : (string, buffer) Hashtbl.t;
    (* key is filename *)
    mutable loc_files : (string, buffer) Hashtbl.t;

    (* list??*)
    mutable top_windows : top_window list;

    (* pwd of efuns when started *)
    mutable loc_dirname : string;

    (* general look, configurable via -xxx command line options or .efunsrc 
     * (dimension type is in characters)
     *)
    mutable loc_width : int;
    mutable loc_height : int;

    mutable loc_fg : string;
    mutable loc_bg : string;
    mutable loc_font : string;

    <<[[Efuns.location]] other fields>>
  } 
@
%(*    
% loc_vars_table : (string, (Obj.t -> string) * (string -> Obj.t)) Hashtbl.t;
% *)  
%dead: mutable loc_counter : int;
%old: was loc_windows, but it's really top_windows
%todo: put buffer_order stack here?

% head of list is current?


<<global Efuns.global_location>>=
let global_location = ref None
@

<<function Efuns.location>>=
let location () =
  match !global_location with
  | None -> failwith "no global location defined"
  | Some x -> x
@

<<[[Ebuffer.create()]] adjust location global fields>>=
Hashtbl.add (Efuns.location()).loc_buffers name buf;
@



%<<[[Efuns.buffer]] other fields>>=
%(*buf_location : location;*)
%@
%<<[[Efuns.frame]] other fields>>=
%(* mutable frm_location : location; *)
%@
%<<[[Efuns.top_window]] other fields>>=
%(* mutable top_location : location; *)
%@
%old: so can access the global world info from a frame
% but what if location was global, then even easier
% to access global info
%I think lefessant started it as a demo for jocaml, and so
% with migration idea of data, so he could not use
% globals so much, but I don't need jocaml or this feature.





%TODO: figure: showing relations between all of that.
% it's a bit complicated because of many fields that
% introduce cycles (mutually recursive data structures, e.g.
% with top_window pointer, with map with action),
% so does not only go down, it also can go back up.
% but maybe can restrict to the down path.

% note that it's hard to remove the recursion.
% For instance the keybinding have an action which takes a frame
% as a parameter, so bindings and frames are mutually recursive, as
% well as with buffer, window, and even top_window we
% need to go up sometimes. and a top window needs to know
% the active frame.

\section{[[Action]] and [[actions]]}

<<type Efuns.action>>=
and action = frame -> unit
@
% Is abstract in the .mli.
% This actually causes many types to be mutually recursive, 
% because the keyboard handling stuff depends on frame and buffers
% and vice versa.
%less: could instead use a string here? that would remove
% some mutual recursivity, and may also help for other things
% such as -debug, or the 'lastcmd' trick.
%note: it will be the active frame, the one with the cursor

% actions will be called from the keyboard event dispatcher.
% the only thing passed is the frame/window where the event
% occured (the active frame with the cursor), but sometimes an action
% then need to have global
% effects (in which case it can use location()), or the upper
% frames/windows, which means we need from the frame to be able
% to access lots of information, hence the introduction of
% certain fields in the frame data structure.

<<type Efuns.generic_action>>=
and generic_action =
| FrameAction of action
| BufferAction of (buffer -> unit)
@
% really need this BufferAction subtelity?
% We need a buffer action when something is done only once, e.g.
% setting up the major mode is a buffer operation and buffer property!
% A frame is more temporary.

<<global Efuns.actions>>=
let (actions : (action_name, generic_action) Hashtbl.t) = 
  Hashtbl.create 63
@
% global!!
% for M-x! and also so can use string in keybinding or mouse
% (but could maybe use dirrectly the ocaml action code)
%less: rename generic_actions then?


<<function Efuns.define_action>>=
let define_action action_name action_fun =
  <<sanity check action defined twice>>
  Hashtbl.add actions action_name (FrameAction action_fun)
@

<<function Efuns.define_buffer_action>>=
let define_buffer_action action_name action_fun =
  <<sanity check action defined twice>>
  Hashtbl.add actions action_name (BufferAction action_fun)
@

<<sanity check action defined twice>>=
(try 
    Hashtbl.find actions action_name |> ignore;
    error "action \"%s\" defined twice" action_name;
 with _ -> ()
);
@
%old had a sepater print_newline() but useless I think

%<<constant Efuns.no_action>>=
%let no_action = BufferAction (fun _ -> ())
%@
<<function Efuns.get_action>>=
let get_action action =
  try Hashtbl.find actions action 
  with Not_found ->
    error "Could not find action %s. Forgot define_action()?" action;
    BufferAction (fun _ -> ())
@

% ?? -> <> who will dispatch and know which frame?
% string -> ocaml code
<<function Efuns.execute_action>>=
let execute_action action = 
  match (get_action action) with
  | FrameAction f -> f 
  | BufferAction f -> (fun frame -> f frame.frm_buffer)
@
%note: it used to be let execute_action action frame = ...
% but then with that execute action return a closure each time,
% and then we can't in -debug find the action_name corresponding
% to an action in try_map, hence my rewrite.

% exec_named_buf_hooks -> <>
<<function Efuns.execute_buffer_action>>=
let execute_buffer_action action buf =
  match (get_action action) with
    BufferAction f -> f buf
  | FrameAction _f -> 
      error "Can't apply action %s on buffer" action
@


<<function Keymap.dummy_action>>=
let dummy_action frame = () 
@

%<<function Top_window.dummy_action>>=
%let dummy_action frame = ()
%@


%todo: I think we can merge this with the keyboard definitions
% at least add to interactive here.
<<toplevel Std_efunsrc._1>>=
let _ =
  <<actions definitions>>
  ()
@


<<actions definitions>>=
(* ----------------------------------------------------------- *)
(* Loading *)
(* ----------------------------------------------------------- *)
<<loading actions>>

(* ----------------------------------------------------------- *)
(* Navigating (in the file) *)
(* ----------------------------------------------------------- *)
<<navigating actions>>

define_action "scroll_up" Simple.scroll_up; 
define_action "scroll_down" Simple.scroll_down; 
define_action "scroll_other_up" Simple.scroll_other_up; 
define_action "scroll_other_down" Simple.scroll_other_down; 


(* ----------------------------------------------------------- *)
(* Editing *)
(* ----------------------------------------------------------- *)
(* ------------------------- *)
(* Inserting *)
(* ------------------------- *)
<<inserting actions>>
(* ------------------------- *)
(* Deleting *)
(* ------------------------- *)
<<deleting actions>>
(* ------------------------- *)
(* Moving (Cut, copy, paste) *)
(* ------------------------- *)
<<moving actions>>
(* ------------------------- *)
(* Transforming *)
(* ------------------------- *)
<<transforming actions>>
(* ------------------------- *)
(* Replacing *)
(* ------------------------- *)
<<replacing actions>>

(* ----------------------------------------------------------- *)
(* Searching *)
(* ----------------------------------------------------------- *)
<<searching actions>>

(* ----------------------------------------------------------- *)
(* Undoing *)
(* ----------------------------------------------------------- *)
<<undoing actions>>

(* ----------------------------------------------------------- *)
(* External commands *)
(* ----------------------------------------------------------- *)
<<external command actions>>

(* ----------------------------------------------------------- *)
(* Buffers/windows/frames *)
(* ----------------------------------------------------------- *)
<<buffer managment actions>>
<<buffer navigating actions>>

define_action "buffer_menu"  Buffer_menu.menu;
define_action "switch_to_other_buffer"  Multi_buffers.switch_to_other_buffer;

<<frame managment actions>>
<<frame navigation actions>>

(* ----------------------------------------------------------- *)
(* Meta *)
(* ----------------------------------------------------------- *)
<<meta actions>>

(* ----------------------------------------------------------- *)
(* Saving *)
(* ----------------------------------------------------------- *)
<<saving actions>>

(* ----------------------------------------------------------- *)
(* Major mode *)
(* ----------------------------------------------------------- *)
<<major mode actions>>

(* ----------------------------------------------------------- *)
(* Misc *)
(* ----------------------------------------------------------- *)
<<misc actions>>
@


%XXX
<<misc actions>>=
define_action "revert_buffer" Complexe.reload;
define_action "open_display" Complexe.open_display;
define_action "change_font"  Complexe.change_font;
@  
%(*  define_action "load_library" load_library;*)
%(*  define_action "start_server" Server.start;  *)


% a bit annoying, but ocaml is not a dynamic language with
% eval string, so have to do that. Maybe recent ocaml
% attribute could help.


\section{Keyboard [[Map]]}
% keyboard handling is important for an editor!
% different possibilities:
%  - emacs spirit: prefix map
%  - vi spirit: modes
%  - sam spirit: the mouse ...

%less: mv stuff in Keyboard section? what is necessary to see before?

% like for variables that we will see after, have different maps for
% different "scopes":
% - global
% - major mode
% - minor mode
% - buffer itself (useful for dynamic setting of keys e.g. C-g in minibuffer)
% good so that each mode can redefine bindings! specialized mode!
% specialized keys! For instance when TAB to offer completion
% in minibuffer mode, or semantic completion in C buffer, or just
% insert a TAB in makefile mode.


<<type Efuns.map>>=
type map =
  { 
    (* 256 array, one character simple key = one action *)
    char_map : binding array;
    (* complex key, possible sub maps *)
    mutable complex_bindings : (key * binding) list;

    <<[[Efuns.map]] other fields>>
  } 
@
% char_map is essentially an optimisation, so that simple key
% dispatching goes quickly

<<type Efuns.key>>=
and key = mod_ident * keySym
@

<<type Efuns.mod_ident>>=
and mod_ident = 
  NormalMap
| ControlMap
| MetaMap
| ControlMetaMap
@
% enough I think

%(*Xtypes.*)
<<type Efuns.keySym>>=
and keySym = int
@
% keySym = int (could be a Rune in plan9!)


<<type Efuns.binding>>=
and binding = 
  Function of action
| Prefix of map
| Unbound
@
% mutually recursive type! find map again

<<function Keymap.create>>=
let create () =
  { char_map = Array.create 256 Unbound;
    complex_bindings = [];
    interactives = [];
  } 
@
% will see interactives later

<<[[Efuns.buffer]] other fields>>=
buf_map : map;
@

<<[[Efuns.location]] other fields>>=
loc_map : map;
@
% will see 2 other maps later, for major and minor modes.

<<function Ebuffer.get_binding>>=
let get_binding buf keylist =
  let binding = ref Unbound in
  try
    <<[[Ebuffer.get_binding()]] minor mode key search>>
    <<[[Ebuffer.get_binding()]] major mode key search>>
    (let b = Keymap.get_binding buf.buf_map keylist in
      match b with
      | Prefix _map -> binding := b;
      | Function _f -> binding := b; raise Exit
      | Unbound -> ()
    );
    <<[[Ebuffer.get_binding()]] if partial map>>
    !binding
  with Exit -> !binding
@
% see Keymap.get_binding later *)


%\section{Partial maps}
<<[[Efuns.buffer]] other fields>>=
mutable buf_map_partial : bool;
@
% but always true no?
<<[[Ebuffer.get_binding()]] if partial map>>=
if buf.buf_map_partial then
  (let b = Keymap.get_binding (Efuns.location()).loc_map keylist in
    match b with
      Prefix map -> binding := b;
    | Function f -> binding := b; raise Exit
    | Unbound -> ()
  );
@


%less: maybe there are too many way to define key,
% add_binding, add_global_key, interactive, etc.


<<function Keymap.add_global_key>>=
let add_global_key = fun prefix string action ->
  interactive (Efuns.location()).loc_map prefix string action
@
<<function Keymap.add_local_key>>=
let add_local_key buf = 
  interactive buf.buf_map 
@
% each major mode can also use that to offer a specialized experience!
% (or use add_major_key).

% what about add_major_key? add_minor_key? will see later.


% add_local_key | add_global_key | add_major_key | add_minor_key -> <>?
<<function Keymap.interactive>>=
let interactive map =
 fun keylist name f ->
  <<[[Keymap.interactive()]] add keylist and name to interactives list>>
  add_binding map keylist f
@
%less: rename? add_key_binding_and_interactive_name?
% see Keymap.add_binding later *)








<<constant Std_efunsrc.global_map>>=
let global_map = define_option ["global_map"] "" 
  (list_option Simple.binding_option) []
@

<<constant Simple.binding_option>>=
let binding_option = tuple2_option (smalllist_option key_option, string_option)
@
<<constant Simple.key_option>>=
let key_option = define_option_class "Key" value_to_key key_to_value
@
% see configuration file library in appendix


<<toplevel Std_efunsrc._2>>=
let _ = 
  if !!global_map = [] then begin
      global_map =:= [
        <<[[global_map]] initial entries>>
      ]
    end;
  <<[[Std_efunsrc.toplevel]] set interactives_map>>
@

% a few important keys

%\section{[[C-h]]}
<<constant Keymap.c_h>>=
let c_h = (ControlMap, Char.code 'h')
@
%\section{[[C-x]]}
<<constant Keymap.c_x>>=
let c_x = (ControlMap, Char.code 'x')
@
%\section{[[C-c]]}
<<constant Keymap.c_c>>=
let c_c = (ControlMap, Char.code 'c')
@


<<[[global_map]] initial entries>>=
(* -------------------------------------------------------- *)
(* Loading *)
(* -------------------------------------------------------- *)
<<loading keys>>

(* -------------------------------------------------------- *)
(* Navigating (in the file) *)
(* -------------------------------------------------------- *)
<<navigating keys>>

(* -------------------------------------------------------- *)
(* Editing *)
(* -------------------------------------------------------- *)

(* ------------- *)
(* Inserting *)
(* ------------- *)
<<inserting keys>>
(* ------------- *)
(* Deleting *)
(* ------------- *)
<<deleting keys>>
(* ------------------------------ *)
(* Moving (Cut, copy, paste) *)
(* ------------------------------ *)
<<moving keys>>
(* ---------------------- *)
(* Transforming *)
(* ---------------------- *)
<<transforming keys>>

(* -------------------------------------------------------- *)
(* Search/replace *)
(* -------------------------------------------------------- *)
<<searching keys>>
<<replacing keys>>

(* -------------------------------------------------------- *)
(* Undoing *)
(* -------------------------------------------------------- *)
<<undoing keys>>

(* -------------------------------------------------------- *)
(* External commands *)
(* -------------------------------------------------------- *)
<<external commands keys>>

(* pad: *)
[MetaMap, XK.xk_Return], "compile";
[c_x;ControlMap, Char.code 'n' ], "next_error";

[c_x;NormalMap, Char.code '`' ], "next_error";

(* pad: *)
[MetaMap, Char.code '1'], "eshell_num";
[MetaMap, Char.code '2'], "eshell_num";
[MetaMap, Char.code '3'], "eshell_num";
[MetaMap, Char.code '4'], "eshell_num";
[MetaMap, Char.code '5'], "eshell_num";
[MetaMap, Char.code '9'], "eshell_num";
[MetaMap, Char.code '0'], "eshell_num";
[MetaMap, Char.code '-'], "eshell_num";
[MetaMap, Char.code '='], "eshell_num";

(* -------------------------------------------------------- *)
(* Buffers/windows/frames *)
(* -------------------------------------------------------- *)
<<buffer managment keys>>

<<buffer navigating keys>>
<<frame managment keys>>
<<frame navigation keys>>

(* pad: *)
[ControlMetaMap, XK.xk_Tab], "buffer_menu";
[ControlMetaMap, Char.code 'l'], "switch_to_other_buffer";
[ControlMap, XK.xk_Tab], "next_frame";

(* -------------------------------------------------------- *)
(* Meta *)
(* -------------------------------------------------------- *)
<<meta keys>>

(* -------------------------------------------------------- *)
(* Saving *)
(* -------------------------------------------------------- *)
<<saving keys>>

(* -------------------------------------------------------- *)
(* Misc *)
(* -------------------------------------------------------- *)
<<misc keys>>
@

%XXX
<<misc keys>>=
[NormalMap, XK.xk_Insert], "overwrite_mode";
[c_x; NormalMap, Char.code 'F'], "change_font";
@




% main -> Efuns.init -> List.iter f start_hooks -> <> 
%  (as ?? ?<- add_start_hook(<>) <- Std_efunsrc._5)
<<function Std_efunsrc.init_global_map>>=
let init_global_map () = 
  !!global_map |> List.iter (fun (keys, action) ->
      try
        Keymap.add_global_key keys action (execute_action action)
      with e ->
        Log.printf "Error for action %s" action;
        Log.exn "%s\n" e;
  );

  <<[[Std_efunsrc.init_global_map()]] add interactives from interactives_map>>
    
  (* standard keys *)

  (* Mouse *)
  <<[[Std_efunsrc.init_global_map()]] mouse keys setup>>
  ()
@

%  Keymap.add_global_key location [NormalMap, XK.xk_dead_circumflex]
%    "circumflex" (char_insert_command '^');
%dead:  let gmap = location.loc_map in 


\section{[[Vars]]}

% actually have polymorphic variables! trick using phantom types.
% See appendix (or put more of local.ml here?)

% why need variables in emacs? to configure things! e.g. level
% of indentation for this major mode. You can overwrite also
% global settings. Configurable editor! Easy way to add
% properties to buffers. Otherwise we would have to have
% a huge efuns.ml with too many fields in buffer, frame, etc.

<<[[Efuns.buffer]] other fields>>=
mutable buf_vars : Local.vars;
@
% less: rename Local? why Local?

<<[[Efuns.location]] other fields>>=
loc_vars : Local.vars;
@
% does not read good, looks like local variables when really
% it's global variables here, loc = location, and Local = ???

% different scopes again:
% - global
% - buffer
% - major mode
% - minor mode

<<function Efuns.set_global>>=
let set_global var value = 
  Local.set (location()).loc_vars var value
@
<<function Efuns.set_local>>=
let set_local buf var value = 
  Local.set buf.buf_vars var value
@

<<function Efuns.get_global>>=
let get_global var = 
  Local.get (location()).loc_vars var
@
%todo: put the type of the .mli here? subtle signature. polymorphic vars!
<<function Efuns.get_local>>=
let get_local buf var = 
  Local.get buf.buf_vars var
@

% buffer -> major -> minors -> global
<<function Efuns.get_var>>=
let get_var buf var = 
  try 
    Local.get buf.buf_vars var 
  with Not_found ->
    try 
      <<[[Efuns.get_var()]] try with major mode variables>>
    with Not_found ->
      try 
        <<[[Efuns.get_var()]] try with minor mode variables>>
      with Not_found ->
        Local.get (location()).loc_vars var
@

% was not there originally
<<misc keys>>=
[c_h; NormalMap, Char.code 'v'], "describe_variable";
@

% can't understand yet everything (so move it later??)
<<function Complex.get_variable>>=
let describe_variable frame = 
  Select.select frame "get_variable : " variable_hist "" 
    (all_variables frame)
    (fun s -> s) 
    (fun variable ->
      Top_window.mini_message frame 
        (Printf.sprintf "%s : %s" variable (
          let buf = frame.frm_buffer in
          try
            Local.print buf.buf_vars variable
          with _ ->
            Local.print (Efuns.location()).loc_vars variable)))
@
<<misc actions>>=
define_action "describe_variable"  Complexe.describe_variable;
@
% was called get_variable

\section{Hooks}
% essentially a set of list refs

% different kind of hooks:
% - variable hook, below, use variables that we've just seen above.
% - startup hooks (add_start_hook() and start_hooks[] and Efuns.init())
%    will see in main chapter.
% - named hooks, for frame a buffer actions, so take a string (action name)
%   for parameter. why not does not take the action function directly?
%   because want to possibly save such hooks configuration in a file

% again, configurable editor spirit so hooks to customize things,
% place where you can plug a customization at certain code points

\subsection{Variable hooks}

<<function Efuns.exec_hooks>>=
let exec_hooks hooks arg =
  hooks |> List.iter (fun f ->
    try f arg 
    with exn -> error "exn in hook: %s" (Common.exn_to_s exn)
  )
@

<<function Efuns.add_hook>>=
let add_hook hook_var hook =
  let tail = try get_global hook_var with _ -> [] in
  set_global hook_var (hook :: tail)
@


% example:
% of a hook var. What is the type of create_buf_hook? and get_global below?
<<constant Ebuffer.create_buf_hook>>=
let create_buf_hook = Local.create_abstr "create_buf_hook"
@
%less: remame create_buffer_hooks? more consistent?
% of use of this hook var
<<[[Ebuffer.create()]] run hooks>>=
let hooks = try get_global create_buf_hook with Not_found -> [] in
exec_hooks hooks buf;
@
% will be set to set_buffer_mode, which use the alist to automatically
% set the major mode!



\subsection{Named action hooks}
% named so can be put in configuration file

<<function Frame.exec_named_hooks>>=
let exec_named_hooks hooks frame =
  hooks |> List.rev |> List.iter (fun action -> 
   try execute_action action frame with _ -> ()
  )
@
%<<function Frame.exec_named_hooks_with_abort>>=
%(*
%let rec exec_named_hooks_with_abort hooks frame =
%  match hooks with
%    [] -> ()
%  | action :: hooks ->
%      exec_named_hooks_with_abort hooks frame;
%      execute_action action frame
%*)
%@

% example:
<<constant Frame.change_buffer_hooks>>=
let change_buffer_hooks = define_option ["change_buffer_hooks"] "" 
    (list_option string_option)
  [ "check_file" ]
@
% each time buffer change! -> <>
<<misc actions>>=
define_action "check_file" Complexe.check_file;
@


% ?? -> <>
<<function Ebuffer.exec_named_buf_hooks>>=
let exec_named_buf_hooks hooks frame =
  hooks |> List.rev |> List.iter (fun action ->
    try execute_buffer_action action frame 
    with exn -> error "exec_named_buf_hooks: exn = %s" (Common.exn_to_s exn)
  )
@

% ?? -> <>
<<function Ebuffer.exec_named_buf_hooks_with_abort>>=
let exec_named_buf_hooks_with_abort hooks frame =
  hooks |> List.rev |> List.iter (fun action ->
    execute_buffer_action action frame
 )
@
% no try here

% example:
<<constant Ebuffer.save_buffer_hooks>>=
(*
let save_buffer_hooks = define_option ["save_buffer_hooks"] "" 
    (list_option string_option)
  [ ]
*)
@
% use

\subsection{Startup hooks}

% will see them soon, below.





\chapter{[[main()]]}

% there is actually no really main() in ocaml, instead
% a list of toplevels doing stuff (in the order of the linking)
%update: but I reorged the code to gather stuff in a main(), more readable.

<<toplevel Main._>>=
let _ =
  main ()
@


% init files are not the .efunsrc, but the first set of files to open
% so when do efuns foo.c => init_files = ref ["foo.c"]
<<constant Efuns.init_files>>=
let initial_files = ref []
@
% should be used in Graphic.init
% efuns is a multi-file editor!

<<function Main.main>>=
let main () =
  <<[[main()]] set signal handlers>>

  Arg.parse [
    <<[[main()]] command line options>>
   ]
   (fun name -> initial_files := name :: !initial_files) 
   usage_str;
  <<[[main()]] set options>>

  <<[[main()]] initial location>>
  <<[[main()]] initialize the world>>
  <<[[main()]] misc initializations>>

  <<[[main()]] run the UI>>
  ()
@




\section{Configuration file, [[.efunsrc]]}

<<[[main()]] set options>>=
<<[[main()]] set options filename>>
<<[[main()]] adjust options>>
@


% see appendix on configuration file library
<<[[main()]] set options filename>>=
Options.filename := 
  (try Utils.find_in_path (Utils.homedir :: !!Efuns.load_path) ".efunsrc" 
   with _ -> Filename.concat Utils.homedir ".efunsrc"
  );
(try Options.init () 
 with exn -> Efuns.error "init error, exn = %s" (Common.exn_to_s exn)
);
@


<<misc actions>>=
define_action "save_options" save_options;
@
<<function Std_efunsrc.save_options>>=
let save_options frame = 
  Options.save ()
@



%<<constant Efuns.no_init>>=
%let no_init = ref false
%@
%% dead?
%<<[[main()]] command line options>>=
%  "-q", Arg.Set no_init,": Don't load init files";
%@

\section{Arguments processing}


%\section{General style parameters}
 
<<constants Main options>>=
let width = define_option ["width"] "" int_option 80
let height = define_option ["height"] "" int_option 44 (* 44, 25 *)
let foreground= define_option ["foreground"] "" string_option "wheat"
let background= define_option ["background"] "" string_option "DarkSlateGray"
@
%pad: was 25 for height
%pad: was white
%pad: was black
%<<constant Efuns.height>>=
%let height = ref 27
%@
%redundant?

% used in some major modes
<<constant Efuns.font>>=
let font = define_option ["font"] "" string_option "Menlo 18"
@
%pad: was fixed


<<constants Main.xxx_opt>>=
let width_opt = ref None
let height_opt  = ref None
let fg_opt = ref None
let bg_opt = ref None
let font_opt = ref None
@

<<[[main()]] command line options>>=
"-width"  , Arg.Int (fun i -> width_opt := Some i), "<len>: Width in chars";
"-height" , Arg.Int (fun i -> height_opt := Some i), "<len>: Height in chars";
"-fg"     , Arg.String(fun s -> fg_opt := Some s), "<color>: Foreground color";
"-bg"     , Arg.String(fun s -> bg_opt := Some s), "<color>: Background color";
"-font"   , Arg.String(fun s -> font_opt := Some s), "<font>: Font name";
@
% gymnastic with intermediate xxx_opt because options filename
% is set later because need first to process load_path
% but then once load the value we could possibly have overwritten
% the values passed by the command line, hence this intermediate

<<[[main()]] adjust options>>=
(match !width_opt  with None -> () | Some color -> width =:= color);
(match !height_opt with None -> () | Some color -> height =:= color);
(match !fg_opt     with None -> () | Some color -> foreground =:= color);
(match !bg_opt     with None -> () | Some color -> background =:= color);
(match !font_opt   with None -> () | Some color -> font =:= color);
@




%x11
<<constant Efuns.displayname>>=
let displayname = ref ""
@
<<[[main()]] command line options>>=
"-d",        Arg.String(fun s -> displayname := s),"<dpy>: Name of display";
"--display", Arg.String(fun s -> displayname := s),"<dpy>: Name of display";
@


<<constant Efuns.check>>=
let check = ref false
@
<<[[main()]] command line options>>=
"-check", Arg.Set check, ": only for testing";
@

% (*    "-c", Arg.String Dyneval.compile,"<file.ml>: compile file";*)



\section{The default world, [[location]]}

<<[[main()]] initial location>>=
let location = {
    loc_buffers = Hashtbl.create 13;
    loc_files = Hashtbl.create 13;

    top_windows = [];

    loc_width = !!width;
    loc_height = !!height;
    loc_fg = !!foreground;
    loc_bg = !!background;
    loc_font = !!font;

    loc_map = Keymap.create ();
    loc_dirname = Sys.getcwd ();

    loc_vars = Local.vars ();
    
    loc_fonts = Hashtbl.create 37;
    loc_fonts_names = Array.create 256 "";
    loc_fonts_n = 0;

    loc_colors = Hashtbl.create 37;
    loc_colors_names = Array.create 256 "";
    loc_colors_n = 0;
    
    loc_mutex = Mutex.create ()
} in
@
%less: need those loc_fonts_xxx and loc_colors_xxx?

\section{Startup hooks}
% hooks on location creation, hence they they a location in parameter

<<[[main()]] initialize the world>>=
init_efuns location (* launch first hooks *);
@

% not that this function reset also the start_hooks global!
%  so that can run it again later, if other hooks are setup later
%  (e.g. in the .efunsrc loading)
% main.ml -> <>
<<function Efuns.init>>=
let init_efuns (location : location) =
  global_location := Some location;
  let hooks = List.rev !Efuns.start_hooks in
  Efuns.start_hooks := [];
  hooks |> List.iter (fun f -> f ())

@
% List.rev because add_hooks add in head, see below
%old: used to be in efuns.ml, but better in main.ml


% init -> List.iter run <>
<<constant Efuns.start_hooks>>=
(* Les hooks de lancement apres le chargement d'un module *)
let start_hooks = (ref []: (unit -> unit) list ref)
@
% private? rename _start_hooks?

<<function Efuns.add_start_hook>>=
let add_start_hook hook = 
  start_hooks := hook :: !start_hooks
@



<<toplevel Std_efunsrc._5>>=
let _ =
  Efuns.add_start_hook (fun () ->
    <<[[Std_efunsrc._5]] start hooks options>>
    init_global_map ()
  )
@

\section{The graphical window}

<<[[main()]] run the UI>>=
Graphics_efuns.init !initial_files;
@
%less: could just take ()

\subsection{[[Graphics.init()]]}

% this is the not portable part!

% <<function Graphics_efuns.init>>=
%  Graphics_xxx.open_graphics
%  ...
%  let top_window = Top_window.create display in
%  ...
%  top_window.graphics <- Some (backend Graphic_xxx.context ...); 
%  ...
%  Top_window.update_display ();
%  ...
%  event loop
%    ...
%    Top_window.handler top_window () evt
%    ...
% @
% where the handler also call at some point Top_window.update_display;

% will see main functions called from init below

\subsection{[[Top_window.create()]]}

<<function Top_window.create>>=
let create () =
  let location = Efuns.location() in
  let buf = 
    Ebuffer.default "*help*" in
  (* keep one line for the minibuffer, hence the -1 *)
  let window = 
    Window.create_at_top  0 0 location.loc_width (location.loc_height - 1) in
  let frame = 
    Frame.create_without_top window None buf in
  let top_window =
    { 
      top_name = "window";
      top_width = location.loc_width;
      top_height = location.loc_height;
      window = window;
      top_active_frame = frame;

      top_mini_buffers = [];
      top_second_cursor = None;

      graphics = None;
    } 
  in

  (* adjust what Window.create_at_top could not do *)
  frame.frm_window.win_up <- TopWindow top_window;
  location.top_windows <- top_window :: location.top_windows;

  top_window
@
% a few notes:
% - top_active_frame!
% - loc_height -1 for the minibuffer.
% - top_mini_buffers is empty at first, the minibuffer is created
%   on the fly when do M-x, but before that it does not really
%    exist (hmm what about Top_window.message() though?)
% - we use create_without_top() because mutually recursive :) we need
%   an active frame to create a top_window, and we need a top_window
%   for from.frm_window.win_up.
%old: this used to contain far more graphical stuff, but I've
% extracted it from it and moved instead in Graphics_efuns.init()

%(*
%      top_term = xterm;
%      top_attrs = Array.create 256 None;
%      top_root=  display.WX_xterm.root_oo;
%      top_appli = top;
%      top_scrollbar = ady;
%*)






<<function Ebuffer.default>>=
let default name =
  try
    Hashtbl.find (Efuns.location()).loc_buffers name
  with Not_found ->
    let str = 
      if name = "*help*" 
      then help_buffer_content
      else ""
    in
    create name None (Text.create str) (Keymap.create ())
@
%(*
%"
%Version is " ^ Version.efuns_version ^"
%built by "^ Version.builder ^ " " ^ Version.date ^ " 
%with
%Efuns installation directory : " ^ Version.efuns_lib ^ "
%Ocaml installation directory : " ^ Version.ocamllib ^ "
%
%Fabrice Le Fessant
%PARA/SOR Project
%INRIA Rocquencourt
%
%Help for Key Bindings: C-h K
%See changes in "^ Version.efuns_lib ^"/Changes
%"
%*)

<<constant Ebuffer.help_buffer_content>>=
let help_buffer_content = 
"Welcome to Efuns, a small demo editor written in Ocaml.

Fabrice Le Fessant
PARA/SOR Project
INRIA Rocquencourt
"
@


% Top_window.create -> ()
<<function Window.create_at_top>>=
let create_at_top xpos ypos width height =
  let rec window = {
    win_xpos = xpos;
    win_ypos = ypos;
    win_width = width;
    win_height = height;

    win_down = NoFrame (); 
    win_up = Window window;

    win_mini = false;
  } in
  window
@
% let rec!! because it's used to bootstrap!
%less: could do without if were defining window, frame, and top_window
% with a 'let rec ... and ...'?
% or if were using globals for top_window, would need that? why
% we need the win_up field that makes things mutually recursive and
% slightly complicated?
% update: I think there is no choice, need win_up for certain actions.


%<<[[Top_window.create()]] create graphical window with right dimensions>>=
%(*
%let top = new WX_appli.t display.WX_xterm.root_oo [] in
%top#setWM_NAME "new_frame";
%top#setWM_CLASS "Efuns" "efuns";
%let hbar = new WX_bar.h top#container [] in
%top#container_add hbar#contained;
%let xterm = new WX_xterm.t 
%    hbar#container display
%    location.loc_width
%    location.loc_height in
%let ady = new WX_adjust.t () in
%let scrollbar = new WX_scrollbar.v hbar#container ady [] in
%hbar#container_add_s [xterm#contained; scrollbar#contained];
%*)
%@

%<<[[Top_window.create()]] misc stuff>>=
%(*
%  WX_xterm.install_handler display xterm (handler top_window xterm);
%  top#configure [Bindings [Key (anyKey, anyModifier), (fun _ ->
%          handler top_window xterm (WX_xterm.XTKeyPress (
%              !WX_types.modifiers_event, !key_string, !key_sym));
%          WX_xterm.update_displays ()
%    )]];
%*)
%@

\subsection{[[Top_window.update_display()]]}
% or mv in  its own \section, redisplay engine? after the event loop

% Graphics_xxx.init | (event loop -> handle_key) -> <>
<<function Top_window.update_display>>=
let update_display () =
  (Efuns.location()).top_windows |> List.iter (fun top_window ->
     top_window.window |> Window.iter (fun frm -> 
       Frame.display top_window frm
     );
     (match top_window.top_mini_buffers with
      | [] -> ()
      | frm :: _ -> Frame.display top_window frm
     );
     cursor_on top_window;
     let graphic = Window.backend top_window in
     graphic.Xdraw.update_display();
  ) 
@
% Why have a list of top_windows? because of Emacs "Frames" supported by
%  efuns?
% Why have a list for minibuffer?
% and Frame.display only the first minibuffer? 
%still?: get rid of top_windows, just have one?

% minibuffer is a frame!
% status line? it's attached to a frame actually
% (and minibuffer is a frame, but special without a status line, hmm)

% will see Frame.display() later
% will see cursor_on() later

% we call the graphic backend update_display so it knows
% things need to be refreshed (queue the pixmap widget)

\section{The event loop}

% again not portable part

%  let rec loop () =
%      let evt = ... in
%      ...
%      Top_window.handler top_window () evt
%  in
%  loop ()


\subsection{[[Event]]}

% event type?

\subsection{[[Top_window.handler()]]}

% will see later why need mutex, when use threads
% for external process (e.g. M-!) in which case
% we must ensure exclusive access to the shared data

<<function Top_window.handler>>=
let handler top_window event =
  Efuns.with_lock (fun () ->
    match event with
    <<[[Top_window.handler()]] match event cases>>
  )
@
%old: was using top_window.top_location.loc_mutex in 2 cases of 3
% more consistent to always use the same form
%pad: I factorized code with with_lock


\subsection{[[Top_window.handle_key()]]}

<<[[Top_window.handler()]] match event cases>>=
| Xtypes.XTKeyPress (modifiers, _s, keysym) ->
    handle_key top_window modifiers keysym
@
%  (*
%    if (keysym < XK.xk_Shift_L || keysym > XK.xk_Hyper_R)
%    then 
%  *)


<<function Top_window.handle_key>>=
let handle_key top_window modifiers keysym =
  keypressed := keysym;
  let frame = top_window.top_active_frame in
  let buf = frame.frm_buffer in

  clean_display (); (* set cursor off *)
  clear_message top_window;

  exec_hooks (try Efuns.get_var buf handle_key_start_hook with _ -> []) frame;

  let mod_ = 
    <<[[Top_window.handle_key()]] compute mod>>
  in
  let key = (mod_, keysym) in
  begin
    try
      (* should lead to an action being triggered and modifying things! *)
      try_map frame key
    with
    <<[[Top_window.handle_key()]] handle exception of try_map>>
  end;

  exec_hooks (try get_global handle_key_end_hook with _ -> []) ();

  update_display ()
@
% seen top_active_frame buffer!
% update_display() again!! each key down trigger a redisplay action
% will see try_map() later in keyboard section
%old: the handle_key_start used to take unit, but now it takes a frame,
% so can do more complex stuff, e.g. in eshell to try to go
% to the end of the buffer if type regular key


<<constant Top_window.keypressed>>=
let keypressed = ref 0
@
% who uses that? self_insert_command. Convenient otherwise
% will have to define 26 action strings and 26 functions
% to handle all the alphabet keys.

<<constant Top_window.handle_key_start_hook>>=
let handle_key_start_hook = Local.create_abstr "handle_key_start_hook"
@
<<constant Top_window.handle_key_end_hook>>=
let handle_key_end_hook = Local.create_abstr "handle_key_end_hook"
@
% who uses that? handle_key_start_hook can be used by eshell


<<constant Top_window.meta>>=
let meta = ref Xtypes.mod1Mask
@
% default meta key

<<[[Top_window.handle_key()]] compute mod>>=
let mask = Xtypes.controlMask lor !meta in
let diff = modifiers land mask in
match () with
| _ when diff = 0 -> NormalMap 
| _ when diff = Xtypes.controlMask -> ControlMap
| _ when diff = !meta -> MetaMap
| _ -> ControlMetaMap
@
% I don't handle Esc-x for now.

% so for now remains Frame.display(), and Top_window.try_map()
% which are big pieces to understand that we have not seen.




\chapter{Text Managment}

% text.ml

\section{Gap buffer}

%from guide.txt:
%The Text.t type implements a gap-buffer. A gap-buffer is a buffer with
%a big hole inside. Why ? To insert one char inside a buffer, you need to move
%all the end of the buffer by one char before inserting. This is too expensive
%for very large buffers. Instead, gap-buffers have a hole. To insert one char
%in the buffer, you only need to move the hole to your position, and to insert
%the char at the first position of the hole. Then, to insert a second char
%just after the first one (the most used operation in an editor), you only
%need to put it at the new first position of the hole.
%
%                       v
%aaaaaaaaaaa-------aaaaaaaaaaaaaaaaaa
%
%=> move the hole
%                       v
%aaaaaaaaaaaaaaaaaaaaaaa-------aaaaaa
%
%=> insert your char
%                       v
%aaaaaaaaaaaaaaaaaaaaaaab------aaaaaa
%
%=> move the cursor
%                        v
%aaaaaaaaaaaaaaaaaaaaaaab------aaaaaa
%
%=> insert the second char without moving any chars :)
%
%                        v
%aaaaaaaaaaaaaaaaaaaaaaabc-----aaaaaa
%
%Inside the Text.t structure, cursors are represented by Text.point structures.
%Indeed, when the gap (the hole) moves inside the buffer, all cursors must
%be updated with the new offset of the gap. This might be expensive, however,
%thanks to Ocaml modules, other Text implementations could be tested without
%breaking the editor.

%http://en.wikipedia.org/wiki/Gap_buffer
%http://scienceblogs.com/goodmath/2009/02/18/gap-buffers-or-why-bother-with-1/
%alternative used in emacs:
%http://en.wikipedia.org/wiki/Rope_(data_structure)

% already seen Text.text_size, Text.text_string in core DS chapter



<<[[Text.text]] gap fields>>=
(* g for gap *)
mutable gpoint : point;
mutable gsize : int;
@
%old: used to have gpoint and gline fields, but it was confusing.
% better to merge in a gpoint that is actually a Text.gpoint.
% A gpoint should be a point ... not a position.

% code looks like that then:
% let gap_end = gpoint.pos + text.gsize in

<<function Text.size>>=
let size tree = 
  let text = tree.tree_text in
  text.text_size - text.gsize
@
% gsize is 0 at the very beginning




\section{Points}

% seen Point type in core DS chapter with Buffer type.

% they are used as "cursors" that goes through the text.

<<misc actions>>=
define_action "describe_position" Complexe.describe_position;
@
<<[[interactives_map]] initial entries>>=
"describe_position";
@

<<function Complex.get_pos>>=
let describe_position frame =
  Top_window.message 
    (Window.top frame.frm_window)
    (Printf.sprintf "Char position %d" 
       (Text.get_position frame.frm_buffer.buf_text frame.frm_point))
@

<<function Text.get_position>>=
let get_position tree point = 
  let text = tree.tree_text in    
  (* gap handling *)
  if point.pos > text.gpoint.pos 
  then point.pos - text.gsize
  else point.pos
@
% note that point can never be in the middle of the hole.
% either it's the gpoint, or it's before or after the hole.



<<[[Text.text]] other fields>>=
mutable text_points : point list;
@

% There are a list of points maintained by the Text itself. Why?
% because the gap can move so you need to update all
% the points references. So need to create points by using specific
% APIs that maintain somewhere this list of points.


<<function Text.new_point>>=
let new_point tree =
  let text = tree.tree_text in      
  let p = { pos = 0; line = 0; } in    
  text.text_points <- p :: text.text_points;
  p
@
%old: was called add_point, but clearer new_point

<<function Text.dup_point>>=
let dup_point tree point =
  let text = tree.tree_text in      
  let p = { pos = point.pos; line = point.line } in
  text.text_points <- p :: text.text_points;
  p
@

<<function Text.remove_point>>=
let remove_point tree p =
  let text = tree.tree_text in      
  text.text_points <- 
    text.text_points |> List.fold_left (fun points point ->
        if point == p 
        then points 
        else point :: points
    ) []
@
%note: use of == not =

<<function Text.goto_point>>=
let goto_point _text p1 p2 =
  p1.pos <- p2.pos;
  p1.line <- p2.line
@
% order of argument is not super good, not very readable.

%\section{The gap}

% ?? -> <>
<<function Text.move_point_to>>=
let move_point_to tree point p =
  let text = tree.tree_text in    
  let _x,y = find_xy tree text.gpoint.pos text.gpoint.line p in
  point.pos <- p;
  point.line <- y
@
% find_xy???
%less: rename move_point_to_pos

\section{Lines}

% already seen Text.text_newlines, Text.text_nlines, and 
% Text.line (very partial for now) type

%\subsection{Line and column}

% status line display the line of the cursor -> <>
<<function Text.point_line>>=
let point_line _text point = 
  point.line
@
% note that it's 0 based! status_line displays it as starting
% at line 1, but internally it's 0 based.
%less: rename? line_of_point?

% status line display the co of the cursor -> <>
<<function Text.point_col>>=
let point_col tree point = 
  let text = tree.tree_text in    
  let pos = point.pos in
  let gpos = text.gpoint.pos in
  let bol = text.text_newlines.(point.line).position in
  (* gap handling *)
  if bol <= gpos && gpos < pos
  then pos - bol - text.gsize
  else pos - bol
@



\section{Inserting characters}

% -> <>
<<function Text.low_insert>>=
let low_insert tree pos str =
  let text = tree.tree_text in
  let strlen = String.length str in
  <<[[Text.low_insert()]] fail if readonly buffer>>

  <<[[Text.low_insert()]] move gap to point>>
  (* subtle: don't move those 'let' earlier, because moving the gap do side
   * effects on the position and line of the gpoint. 
   *)
  let gpos = text.gpoint.pos in
  let gline = text.gpoint.line in

  cancel_repr text gpos gline;
  <<[[Text.low_insert()]] extend gap if not enough space>>
  (* all points should have their point.pos correctly adjusted *)

  String.blit  str 0   text.text_string gpos    strlen;
  (* todo: should refontify! *)
  Array.fill text.text_attrs gpos strlen direct_attr;

  let (nbr_newlines, _nbr_chars) = Utils.count_char str '\n' in
  if nbr_newlines > 0 then 
  begin
    <<[[Text.low_insert()]] adjust newlines when str contains newlines>>
  end;
  let gline = text.gpoint.line in
  text.text_points |> List.iter (fun p ->
    if p.pos > gpos then
      (* todo? why this extra condition?? BUG?? unit test? *)
      if p.line = gline 
      then p.line <- p.line + nbr_newlines;

  );
  text.gpoint <- { pos = gpos + strlen; line = gline + nbr_newlines };
  text.gsize <- text.gsize - strlen;
  (gpos, strlen, text.text_modified) 
@
%  (*let gchars = gpoint - text.text_newlines.(gline).position in*)
% (* p.point_x <- (p.point_x - (if nbr_newlines > 0 then gchars else 0)) + nbr_chars; *)

%TODO: unit test the condition


\subsection{Moving the gap}

<<[[Text.low_insert()]] move gap to point>>=
move_gpoint_to text pos;
@


% low_insert | low_delete | clean_text  -> <>
<<function Text.move_gpoint_to>>=
let move_gpoint_to text pos =
  let gpos = text.gpoint.pos in
  let gsize = text.gsize in
  let gline = text.gpoint.line in
  let gap_end = gpos + gsize in

  text.text_clean <- false;
  if pos <> gpos then
    if pos < gpos then begin
      <<[[Text.move_gpoint_to()]] when pos is before gpos>>
    end else begin
      <<[[Text.move_gpoint_to()]] when pos is after gpos>>
    end
@
%text_clean? see clean_text()


<<[[Text.move_gpoint_to()]] when pos is before gpos>>=
let delta = gpos - pos in
let (delta_line,_) = 
  Utils.count_char_sub text.text_string pos delta '\n' in
String.blit  text.text_string pos   text.text_string (pos + gsize)   delta;
Array.blit   text.text_attrs  pos   text.text_attrs  (pos + gsize)   delta;
for i = gline - delta_line + 1 to gline do
  text.text_newlines.(i).position <- text.text_newlines.(i).position + gsize 
done;
text.text_points |> List.iter (fun p -> 
  if p.pos > pos && p.pos <= gpos 
  then p.pos <- p.pos + gsize
);
text.gpoint <- { pos = pos; line = gline - delta_line };
@
%TODO: figure:
% p.pos > pos? it's not p.pos >= pos?

<<[[Text.move_gpoint_to()]] when pos is after gpos>>=
let delta = pos - gap_end in
let (delta_line,_) = 
  Utils.count_char_sub text.text_string gap_end delta '\n' in
String.blit  text.text_string gap_end   text.text_string gpos   delta;
Array.blit   text.text_attrs  gap_end   text.text_attrs  gpos   delta;
for i = gline + 1 to gline + delta_line do
  text.text_newlines.(i).position <- text.text_newlines.(i).position - gsize
done;
text.text_points |> List.iter (fun p -> 
    if p.pos >= gap_end && p.pos <= pos 
    then p.pos <- p.pos - gsize
);
text.gpoint <- { pos = pos - gsize; line = gline + delta_line }
@
%TODO: figure:
% for text.gpoint <- { pos = pos - gsize ... } ?? it's not pos?
% no because it was pos in the text where the gap was before, but
% now that the gap has moved, it's pos - gsize!




\subsection{extending the gap}

<<[[Text.low_insert()]] extend gap if not enough space>>=
if strlen > text.gsize 
then extend_gap text strlen;
@

% extending the gap is simple

<<constant Text.add_amount>>=
let add_amount = define_option ["add_amount"] "Size of the gap in the buffer"
  int_option 200
@

% ?? -> <>
<<function Text.extend_gap>>=
let extend_gap text amount =
  let add_size = max !!add_amount 
      ((amount / !!add_amount) * !!add_amount + !!add_amount) in
  let old_size = text.text_size in
  let gsize = text.gsize in

  let gpos = text.gpoint.pos in
  let gap_end = gpos + gsize in

  let new_text = String.create (old_size + add_size) in
  String.blit  text.text_string 0   new_text 0    gpos; 
  String.blit  text.text_string gap_end   new_text (gap_end + add_size) 
    (old_size - gap_end);
  text.text_string <- new_text;

  let new_attrs = Array.create (old_size + add_size) direct_attr in
  Array.blit   text.text_attrs 0   new_attrs 0   gpos; 
  Array.blit   text.text_attrs gap_end    new_attrs (gap_end + add_size) 
    (old_size - gap_end);
  text.text_attrs <- new_attrs;

  for i = text.gpoint.line + 1 to text.text_nlines - 1 do
    text.text_newlines.(i).position <- 
      text.text_newlines.(i).position + add_size
  done;
  text.text_points |> List.iter (fun p -> 
      if p.pos > gpos 
      then p.pos <- p.pos + add_size
  );
  text.gsize <- gsize + add_size;
  text.text_size <- old_size + add_size;
  ()
@
%TODO: figure:

\subsection{Adjusting newlines information}

<<[[Text.low_insert()]] adjust newlines when str contains newlines>>=
if (Array.length text.text_newlines - text.text_nlines) < nbr_newlines then
  begin
    <<[[Text.low_insert()]] grow newlines>>
  end;

Array.blit
  text.text_newlines (gline+1) 
  text.text_newlines (gline+1+ nbr_newlines) 
 (text.text_nlines - gline -1);
text.text_nlines <- text.text_nlines + nbr_newlines;

(* similar to compute_newlines() but just for lines after gpos *)
let rec iter n pos =
  let new_pos = String.index_from text.text_string pos '\n' in
  text.text_newlines.(gline+n) <- mk_line_with_pos (new_pos + 1);
  if n < nbr_newlines 
  then iter (n+1) (new_pos + 1)
in
iter 1 gpos;
@
%old:tree_insert tree text text.gpoint.line nbr_newlines;
%<<function Text.tree_insert>>=
%let tree_insert tree t gline nbr = ()
%@


<<[[Text.low_insert()]] grow newlines>>=
let old_size = text.text_nlines in
let new_cache = Array.create (old_size + (max 20 nbr_newlines)) 
  { (mk_line_with_pos (-1)) with line_modified = false }
in
Array.blit 
  text.text_newlines 0 
  new_cache 0 
  old_size;
text.text_newlines <- new_cache;
@
% not sure needs this subtle line_modified = - 1 


\section{Deleting characters}

% ??? -> <>
<<function Text.low_delete>>=
let low_delete tree pos len =
  let text = tree.tree_text in      
  <<[[Text.low_insert()]] fail if readonly buffer>>

  <<[[Text.low_insert()]] move gap to point>>
  (* subtle: don't move those 'let' earlier, because moving the gap do side
   * effects on the position and line of the gpoint. 
   *)
  let gpos = text.gpoint.pos in
  let gline = text.gpoint.line in

  cancel_repr text gpos gline;

  let gap_end = gpos + text.gsize in
  let len = min (text.text_size - gap_end) len in

  let str = String.sub text.text_string gap_end len in

  let (nbr_newlines, _nbr_chars) = Utils.count_char str '\n' in
  if nbr_newlines > 0 then begin
    <<[[Text.low_delete()]] adjust newlines when str contained newlines>>
  end;
  text.text_points |> List.iter (fun p -> 
      if p.pos > gap_end + len 
      then p.line <- p.line - nbr_newlines
      else
        (* points that were in deleted region *)
        if p.pos > gpos then begin
           p.pos <- gpos;
           p.line <- gline
         end
  );
  text.gsize <- text.gsize + len;
  (gpos, str, text.text_modified) 
@
%          (*if p.line = gline + nbr_newlines then
%            p.point_x <- (p.point_x - nbr_chars) + 
%              (if nbr_newlines > 0 then gchars else 0);*)
%         (* p.pos_x <- gchars; *)
% no need extend the gap this time.

<<[[Text.low_delete()]] adjust newlines when str contained newlines>>=
Array.blit 
  text.text_newlines (gline + nbr_newlines + 1)
  text.text_newlines (gline + 1) 
 (text.text_nlines - gline - nbr_newlines - 1);
text.text_nlines <- text.text_nlines - nbr_newlines;
@

\section{Attributes}

<<type Text.attribute>>=
type attribute = int
@
% int, because need to be efficient!
% attribute is an encoded int, direct_attr = black fg, white bg, no highlight
% regular font. Want efficient representation here because each
% character will have this attribute?
%old: was used only in .mli before, but now I used it
% in in Text.text.attrs too

<<[[Text.text]] attribute fields>>=
mutable text_attrs : attribute array;
@

<<function Text.make_attr>>=
let make_attr fg bg font highlighted =
  let attr = 
     fg + 
     (bg lsl 8) + 
     (font lsl 16) + 
     (if highlighted then 1 lsl 24 else 0)
  in
  attr
@
% 8 bits fg, 8 bigs bg, 8 bits font, 1 bit highlight
% color map = 0 -> black, 1 -> white?

<<constant Text.direct_attr>>=
let direct_attr =  make_attr 0 1 0 false
@
<<constant Text.inverse_attr>>=
let inverse_attr =  make_attr 1 0 0 false
@
% let no_attr = 0?

% dead: highlight bit? just use inverse_attr?


<<function Text.get_attr>>=
let get_attr tree point =
  let text = tree.tree_text in
  let pos = 
    (* gap handling *)
    if point.pos = text.gpoint.pos
    then point.pos + text.gsize 
    else point.pos
  in
  if pos < text.text_size 
  then text.text_attrs.(pos)
  else direct_attr
@
%less: could print a warning if overflow no?

<<function Text.set_char_attr>>=
let set_char_attr tree point attr =
  let text = tree.tree_text in    
  let y = point.line in
  let pos = 
    (* gap handling *)
    if point.pos = text.gpoint.pos
    then point.pos + text.gsize 
    else point.pos
  in
  if pos < text.text_size then begin
    cancel_repr text pos y;
    text.text_attrs.(pos) <- attr
  end
@
% cancel_repr? a cache.


<<function Text.set_attr>>=
let set_attr tree point len attr = (* should not exceed one line *)
  let text = tree.tree_text in  
  if len > 0 then
    let gap_end = text.gpoint.pos + text.gsize in

    let x,y = find_xy tree text.gpoint.pos text.gpoint.line point.pos in
    cancel_repr text point.pos y;

    let pos = point.pos in
    let gpos = text.gpoint.pos in
    let before, after, after_pos =
      if pos > gap_end then
        0, (min (text.text_size - pos) len), pos
      else
      if pos + len <= gpos then
        0, len, pos
      else
      let before = gpos - pos in
      let after = min (len - before) (text.text_size - gap_end) in
      before, after, gap_end
    in
    if before > 0 
    then Array.fill text.text_attrs pos before attr;
    Array.fill text.text_attrs after_pos after attr
@
%TODO: figure: where show 3 different configs depending
% on where is the covered area regarding the hole


<<function Text.unset_attr>>=
let unset_attr tree =
  let text = tree.tree_text in  
  Array.fill text.text_attrs 0 (Array.length text.text_attrs) direct_attr;
  text.text_newlines |> Array.iter (fun line -> line.line_modified <- true)
@

<<misc actions>>=
define_action "unset_attr" Simple.unset_attr;
@

% -> <> ?? why need that? 
<<function Simple.unset_attr>>=
let unset_attr frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  Text.unset_attr text
@
% does not trigger redisplay?



\section{Colors}

<<[[Efuns.location]] other fields>>=
loc_colors : (string,int) Hashtbl.t;
loc_colors_names : string array;
mutable loc_colors_n : int;
@
% 0 1 are used!
% can seem limited to have a color map, but to have
% an efficient representation for text attributes, it's
% better to use an int which then indexes a map (color map, font map)

% have side effect of setting the color if it's not there before!
<<function Window.get_color>>=
let get_color color_name =
  let location = Efuns.location() in
  try
    Hashtbl.find location.loc_colors color_name
  with Not_found ->
    if location.loc_colors_n = 256 
    then raise Not_found
    else begin
      let n = location.loc_colors_n in
      location.loc_colors_n <- n + 1;
      location.loc_colors_names.(n) <- color_name;
      Hashtbl.add location.loc_colors color_name n;
      n
    end
@



<<[[main()]] misc initializations>>=
(* color 0 is foreground *)
Window.get_color !!foreground |> ignore;
(* color 1 is background *)
Window.get_color !!background |> ignore;
(* color 2 is highlight *)
Window.get_color !!highlight_color |> ignore;
@

% standard! just like stdin/stdout/stderr convention. Sometimes
% conventions are convenient.
% alternative: "foreground", "background", "highlight" color name

% see makefile_color() function, switching to makefile_mode
% will then trigger coloration of the buffer

% makefile_color | ... -> <>
<<function Simple.color>>=
let color buf regexp strict attr =
  let text = buf.buf_text in
  let point = Text.new_point text in
  try
    while true do
      let len = Text.search_forward text regexp point in
      let before =
        if Text.bmove_res text point 1 = 1 then begin
          let c = Text.get_char text point in
          Text.fmove text point (len+1);
          c
        end else begin
          let c = Text.get_char text point in
          Text.fmove text point (len+1); 
          c
        end
      in
      let after = Text.get_char text point in
      if not (strict && (buf.buf_syntax_table.(Char.code before) ||
            buf.buf_syntax_table.(Char.code after))) then
        begin
          Text.bmove text point len;
          Text.set_attr text point len attr;
          Text.fmove text point len;
          ()
        end
    done
  (* at some point Text.search_forward will return Not_found *)
  with Not_found -> 
    Text.remove_point text point;
    buf.buf_modified <- buf.buf_modified + 1
@
% not really incremental as font-lock-mode.
% but can be a simple starting point!

% todo: have also a region variant, start/end

\section{Highlights}

<<constant Main.highlight_color>>=
let highlight_color = define_option ["highlight_color"] "" color_option "cyan"
@
% color 2 by convention

<<constant Simple.highlight_bit>>=
let highlight_bit = 1 lsl 24
@
% see also make_attr

<<function Simple.hightlight_region>>=
let hightlight_region buf debut fin =
  let text = buf.buf_text in
  let curseur = Text.new_point text in
  let final = Text.new_point text in
  Text.set_position text curseur debut;
  Text.set_position text final fin;
  while curseur < final do
    let attr = Text.get_attr text curseur in
    Text.set_char_attr text curseur (attr lor highlight_bit);
    Text.fmove text curseur 1
  done;
  Text.remove_point text curseur;
  Text.remove_point text final;
  buf.buf_modified <- buf.buf_modified + 1
@

<<function Simple.unhightlight_region>>=
let unhightlight_region buf debut fin =
  let text = buf.buf_text in
  let curseur = Text.new_point text in
  let final = Text.new_point text in
  Text.set_position text curseur debut;
  Text.set_position text final fin;
  while curseur < final do
    let attr = Text.get_attr text curseur in
    Text.set_char_attr text curseur (attr land (lnot highlight_bit));
    Text.fmove text curseur 1;
  done;
  Text.remove_point text curseur;
  Text.remove_point text final;
  buf.buf_modified <- buf.buf_modified + 1
@



<<constant Simple.highlighted>>=
(* hightlighting of regions *)  
let highlighted = ref None
@

<<constant Simple.highlighted_chars>>=
let highlighted_chars = ref []
@

<<function Simple.unhightlight>>=
let unhightlight _frame =
  !highlighted_chars |> List.iter (fun (buf,curseur,attr) ->
    let text = buf.buf_text in
    Text.set_char_attr text curseur attr;
    buf.buf_modified <- buf.buf_modified + 1;
    Text.remove_point text curseur
  );
  highlighted_chars := [];
  match !highlighted with
  | None -> ()
  | Some (frame,debut,fin) -> 
     (*   if !keypressed <> XK.xk_Pointer_Drag1 then *)
     highlighted := None;
     let buf = frame.frm_buffer in
     let text = buf.buf_text in
     let curseur = Text.new_point text in
     let final = Text.new_point text in
     Text.set_position text curseur debut;
     Text.set_position text final fin;
     let str = Text.region text curseur final in
     Text.remove_point text curseur;
     Text.remove_point text final;
     kill_string str;
     (* ??? WX_xterm.set_cutbuffer xterm str; for interop? *)
     unhightlight_region buf debut fin
@

<<function Simple.highlight>>=
let highlight frame =
  let frame =
    match !highlighted with
    | None -> frame
    | Some (frame,d,f) -> frame
  in    
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  let text = buf.buf_text in
  let mark = Ebuffer.get_mark buf point in
  let debut, fin =
    if point < mark 
    then point,mark
    else mark,point
  in
  let pos1 = Text.get_position text debut in
  let pos2 = Text.get_position text fin in
  let debut,fin =
    match !highlighted with
    | None -> pos1,pos2
    | Some (frame,d,f) ->
        if d < pos1 
        then unhightlight_region buf d pos1; 
        if f > pos2 
        then unhightlight_region buf pos2 f;
        if pos1 < d 
        then  pos1,d
        else
          if pos2 > f 
          then f, pos2
          else pos1,pos1
  in
  highlighted := Some (frame, pos1, pos2);
  hightlight_region buf debut fin
@



%\section{Highlighting}
%
%<<[[Text.line]] other fields>>=
%mutable line_hlt : int; (* highlighting *)
%@
%%dead? seems never set. subsumed by color attribute? with special
% higlight bit?
%
%
%<<[[Text.compute_representation()]] handle highlighting>>=
%(* once we have computed the simple representation, we can add more
% * complicated things, such as highlighting ... 
% *)
%(match line.line_hlt with
%| 0 -> ()
%| x when x > 0 ->
%    (* the line is hightlighted from the beginning to pos the
%     * line.line_hlt char 
%     *)
%      <<[[Text.compute_representation()]] if line_hlt is positive>>
%| x when x < 0 ->
%  (* the line is hightlighted from then end to pos line.line_hlt *)
%      <<[[Text.compute_representation()]] if line_hlt is negative>>
%| _ -> raise Impossible
%);
%@
%
%
%
%<<[[Text.compute_representation()]] if line_hlt is positive>>=
%let first = line.line_hlt - 1 in
%let rec iter list tail =
%  match list with
%  | [] -> List.rev tail 
%  | repr :: list_r ->
%      if repr.box_pos > first 
%      then iter list_r (repr :: tail)
%      else
%        let len = first - repr.box_pos + 1 in
%        (List.rev tail) @
%          (let before, after = 
%             if len = repr.box_len 
%             then [], list
%             else [ 
%              { repr with
%                box_pos = repr.box_pos + len;
%                box_len = repr.box_len - len;
%                box_size = repr.box_charsize * (repr.box_len - len);
%                box_pos_repr = repr.box_pos_repr + (len*repr.box_charsize)
%              }
%              ], ({ repr with
%                    box_len = len;
%                    box_size = repr.box_charsize * len;
%                   } :: list_r)
%        in
%        after |> List.iter (fun repr ->
%          repr.box_attr <- repr.box_attr lor (1 lsl 24)
%        );
%        before @ after
%      )
%in
%line.boxes <- iter line.boxes []
%@
%
%<<[[Text.compute_representation()]] if line_hlt is negative>>=
%let first = line.line_hlt - 1 in
%let rec iter list tail =
%  match list with
%  | [] -> List.rev tail 
%  | repr :: list_r ->
%      if repr.box_pos > first 
%      then iter list_r (repr :: tail)
%      else
%        let len = first - repr.box_pos + 1 in
%        (List.rev tail) @
%          (let before, after = 
%             if len = repr.box_len 
%             then [], list
%             else [ 
%              { repr with 
%                box_pos = repr.box_pos+len;
%                box_len = repr.box_len - len;
%                box_size = repr.box_charsize * (repr.box_len - len);
%                box_pos_repr = repr.box_pos_repr + (len * repr.box_charsize)
%              }
%              ], ({ repr with
%                    box_len = len;
%                    box_size = repr.box_charsize * len;
%                  } :: list_r)
%        in
%        after |> List.iter (fun repr ->
%          repr.box_attr <- repr.box_attr lor (1 lsl 24)
%        );
%        before @ after
%       )
%in
%line.boxes <- iter line.boxes []
%@

\section{Fonts}
% with an 's'?

<<[[Efuns.location]] other fields>>=
loc_fonts : (string,int) Hashtbl.t;
loc_fonts_names : string array;
mutable loc_fonts_n : int;
@

% similar to get_color, have the side effect of "allocating" a new font
<<function Window.get_font>>=
let get_font font_name =
  let location = Efuns.location() in
  try
    Hashtbl.find location.loc_fonts font_name
  with Not_found ->
    if location.loc_fonts_n = 256 
    then raise Not_found
    else begin
      let n = location.loc_fonts_n in
      location.loc_fonts_n <- n + 1;
      location.loc_fonts_names.(n) <- font_name;
      Hashtbl.add location.loc_fonts font_name n;
      n
    end
@

<<[[main()]] misc initializations>>=
(* font 0 is initial font *)
Window.get_font !!font |> ignore;
@

%todo: variable sized font?



\section{Line representation}
% Line display?

% data -> text_string -> text_newlines -> Text.line with repr_string
% we will get closer to an actual display because we will handle
% special chars, to get the "line representation" in repr_string.

\subsection{Line boxes}
% (cached) representation

% mv later? Keep Text Managment section to be only about text_string?

% text.text_newlines is array of Text.line, where have seen
% already the line.position which is the bol pos.
% here is another field:

<<[[Text.line]] representation fields>>=
mutable boxes : box list; (* sorted in reverse; head is last box on the line *)
@
% order? they are reversed!
%old: the field was called representation, and box was called line_repr 
% (or repr_line), but I prefer to keep the representation term
%  for the actual repr_string!
% this a cache? because at the beginning it's empty, see
% mk_line_with_pos(). It's not a cache really, but it's computed
% on demand for the line we actually want to display (in which case
% we need the line "representation").

% why need that? opti? to avoid sending too many graphic
% commands? can put every chars using the same attribute together?
% well we need anyway the repr_string at least, for ^M special display.

<<type Text.repr>>=
and box = 
  { 
    box_pos : position;   (* pos of box in Text.t string *)
    box_len : int;        (* len of box in Text.t string *)
    mutable box_attr : int;    (* common attribute *)

    <<[[Text.box]] other fields>>
  } 
@
%old: I renamed things, clearer, there was too many line_repr or repr_line
% so repr -> box, repr_line_pos -> box_pos, repr_line_len -> box_len, etc


\subsection{Characters representation}

% text.text_string is a string, an array of chars where
% a char is a byte. But while some chars
% take one "char" space in the display, some special chars
% have no direct representation, and so to represent them
% we "cheat", and display them like ^M. Same for tabs (see advanced topics).
% in which case they take 2 chars!

<<[[Efuns.buffer]] other fields>>=
mutable buf_charreprs : Text.charreprs; (* 256 array *)
@
% not char array!

<<[[Ebuffer.create()]] buffer other fields setup>>=
buf_charreprs = Array.init 256 (fun i -> String.make 1 (Char.chr i));
@

%less: when need special values? why keep that a buffer property?
% could share at least?

% 26 letters of the alphabet, but for special chars!
<<[[Ebuffer.create()]] adjust charreprs>>=
for i=0 to 25 do
  let s = String.make 2 '^' in
  s.[1] <- Char.chr (97+i);    
  buf.buf_charreprs.(i) <- s
done;
@
% ^M, ^R, etc
% 97 = Char.code 'A' ?

<<function Ebuffer.compute_representation>>=
let compute_representation buf n =
  Text.compute_representation buf.buf_text buf.buf_charreprs n
@


\subsection{Line string representation}

% really "representation" this time.

<<[[Text.line]] representation fields>>=
mutable repr_string : string;
mutable repr_len : int;
@
% this is how the line will be represented as a string, which
% is slighly different than the slice of text_string.
% this is useful for tabs, ^M, etc



<<[[Text.box]] other fields>>=
box_charsize : int; (* common size *)
box_size : int;
@
% for tabs, but also to display special chars like ^M with two chars.
%later: could be used for unicode stuff? hmmm need to change 
% how text_string is indexed too then. At least for unicode
% will see the characters?

<<[[Text.box]] other fields>>=
box_pos_repr : int;  (* pos of box in representation string *)
@


\subsection{[[Text.compute_representation()]]}

% most important is computing repr_string, and then the boxes
% which contain the appropriate colors for the different subparts
% of repr_string.

<<function Text.compute_representation>>=
(* On devrait reprendre la representation la ou elle est ... *)
let compute_representation tree charreprs n =
  let text = tree.tree_text in      
  <<[[Text.compute_representation]] if n is too big, return dummy line>>
  else
    let line = text.text_newlines.(n) in
    if line.line_modified then begin

      repr_string := line.repr_string;
      repr_len    := String.length line.repr_string;
      let boxes = ref [] in

      let text_cursor = ref line.position in
      let repr_cursor = ref 0 in

      let end_pos = text.text_newlines.(n+1).position - 1 in

      <<[[Text.compute_representation()]] locals>>
      
      <<[[Text.compute_representation()]] adjust text_cursor if in gap>>
      while !text_cursor < end_pos do
        <<[[Text.compute_representation()]] loop text_cursor to end_pos>>
      done;
      <<[[Text.compute_representation()]] adjust line fields after loop>>
    end;
    line
@
%TODO FIGURE where see the different kind of pos. it's too complicated.
% cursor on text_string, and cursor on repr_string.
%old: was line_curs (line cursor), but I prefer text_cursor and repr_cursor.



<<[[Text.line]] other fields>>=
mutable line_modified : bool;
@
%old: was int before, see commented Optimisation section below,
% but I changed it to bool; simpler code.




<<[[Text.compute_representation()]] loop text_cursor to end_pos>>=
let charcode = Char.code text.text_string.[!text_cursor] in
let charattr = text.text_attrs.(!text_cursor) in
let charrepr =
  <<[[Text.compute_representation()]] compute charrepr, special char>>
  else charreprs.(charcode) 
in
let charsize = String.length charrepr in

let box_len = ref 0 in

while !text_cursor < end_pos && 
  begin
    let char_code = Char.code text.text_string.[!text_cursor] in
    let char_attr = text.text_attrs.(!text_cursor) in
    char_repr := 
       <<[[Text.compute_representation()]] compute charrepr, special char>>
       else charreprs.(char_code);
    char_size := String.length !char_repr;

    !char_size = charsize && char_attr = charattr
  end
do
  <<[[Text.compute_representation()]] grow repr_string if needed>>
  String.blit !char_repr 0 !repr_string !repr_cursor charsize;
  repr_cursor := !repr_cursor + charsize;
  text_cursor := !text_cursor + 1;
  box_len := !box_len +1;
  <<[[Text.compute_representation()]] adjust text_cursor if reach gap>>
done;

let box = {
  box_pos = !line_start;
  box_len = !box_len;
  box_attr = charattr;

  box_charsize = charsize;
  box_size = !box_len * charsize;
  box_pos_repr = !repr_start;
} in
repr_start := !repr_cursor;
line_start := !line_start + !box_len;
boxes := box :: !boxes;
@

%old: was using ==, not sure you need that
%    !char_size == charsize && charattr == text.text_attrs.(!text_cursor)


<<[[Text.compute_representation()]] locals>>=
let line_start = ref 0 in
let repr_start = ref 0 in

let char_repr = ref "" in
let char_size = ref 0 in
@


<<constant Text.repr_string>>=
let repr_string = ref ""
@
<<constant Text.repr_size>>=
let repr_len = ref 0
@
% was repr_size, but better to match the fields

<<[[Text.compute_representation()]] grow repr_string if needed>>=
if !repr_cursor + charsize >= !repr_len then begin
    (* find a better heuristic to realloc the line string *)
    let new_len = !repr_len + 
        (low_distance text end_pos !text_cursor) + charsize * 2 
    in
    let new_repr = String.create new_len in
    String.blit !repr_string 0 new_repr 0 !repr_cursor;
    repr_string := new_repr;
    repr_len := new_len;
end;
@



<<[[Text.compute_representation()]] adjust line fields after loop>>=
line.boxes <- !boxes;
line.repr_string <- !repr_string;
line.repr_len <- !repr_cursor;
line.line_modified <- false;
@
% was line_modified <- -1; which now is false
% !repr_cursor maybe be smaller than !repr_len ?

\subsubsection{Gap managment}

<<[[Text.compute_representation()]] locals>>=
let gpos = text.gpoint.pos in
let gsize = text.gsize in
@

<<[[Text.compute_representation()]] adjust text_cursor if in gap>>=
if !text_cursor >= gpos && !text_cursor < gpos + gsize 
then text_cursor := !text_cursor + gsize;
@

<<[[Text.compute_representation()]] adjust text_cursor if reach gap>>=
if !text_cursor = gpos 
then text_cursor := gpos + gsize;
@



\subsubsection{Dummy lines}

<<constant Text.dummy_line>>=
let (dummy_line : line) = 
  {
    position = max_int;
    boxes = [];
    repr_len = 0;
    repr_string = "";
    line_modified = true;
  } 
@
% was line_modified = 0;, but it should not be -1? (and so now false)

<<[[Text.compute_representation]] if n is too big, return dummy line>>=
if n >= text.text_nlines - 1 then begin
    dummy_line.position <- text.text_size;
    dummy_line
end
@



%\subsubsection{Optimisations}
%
%% useless opti I think; it complicates the code; I removed it.
%
%%old:
%%    if line.line_modified >= 0 then begin
%%
%%      repr_string := line.repr_string;
%%      repr_len    := String.length line.repr_string;
%%
%%      let (repr_tail, next_pos, repr_pos) = 
%%        next_pos_xxx line.line_modified line.boxes 
%%      in
%%      let end_pos = text.text_newlines.(n+1).position - 1 in
%%      let text_cursor = ref (line.position + next_pos) in
%%      let repr_cursor = ref repr_pos in
%
%
%<<[[Text.line]] other fields>>=
%mutable line_modified : int; (* first modified position *)
%@
%% -1 if not modified since last time (=~ false), see cancel_repr.
%% this is an opti, we could simply do line_modified: bool;
%% that force a (not so expensive) recomputation.
%
%
%<<function Text.next_pos_xxx>>=
%let rec next_pos_xxx line_modified boxes =
%  match boxes with
%  | [] -> [], 0, 0
%  <<[[Text.next_pos_xxx()]] if had some boxes already>>
%@
%% at the beginning there is no boxes at all, so next_pos and repr_pos
%% is really 0, 0
%
%
%<<[[Text.next_pos_xxx()]] if had some boxes already>>=
%| box :: tail ->
%    let next_pos = box.box_pos + box.box_len in
%    if next_pos < line_modified 
%    then boxes, next_pos, box.box_pos_repr + box.box_size
%    else next_pos_xxx line_modified tail
%@
%% the boxes are sorted in reverse! so the head is the last box
%% hence the code above
%
%let line_start = ref next_pos in
%let repr_start = ref repr_pos in
%let repr_tail = ref repr_tail in


\subsection{[[Text.cancel_repr()]]}

<<function Text.cancel_repr>>=
let cancel_repr text _point n =
  let line = text.text_newlines.(n) in
  line.line_modified <- true
@

%old: when had line_modified: int
%let cancel_repr text point n =
%  let line = text.text_newlines.(n) in
%  let pos =  point - line.position in
%  line.line_modified <- 
%    (if line.line_modified < 0
%    then pos
%    else min line.line_modified pos
%    )




\chapter{Main Window}

% menu
% windows/frames with buffers
% status line (for each frame get this actually)
% minibuffer (a single one)

% see graphics_graphics.ml

% good way I think to present the code, because people don't understand
% the code but they interstand the interface, so let's start
% from that!

\section{Menus}

<<toplevel Std_efunsrc._4>>=
let _ =
  <<[[Std_efunsrc]] file menu setup>>
  <<[[Std_efunsrc]] edit menu setup>>
  <<[[Std_efunsrc]] help menu setup>>
  <<[[Std_efunsrc]] buffers menu setup>>
@



%<<[[Top_window.create()]] create menus>>=
%(*
%  top#add_button "Buffers" (!buffers_menu top_window);
%  top#add_menu "File" (Array.map (fun (name,action) ->
%        wrap_item top_window (name, execute_action action)
%    ) (Array.of_list !!file_menu));
%  top#add_menu "Edit" (Array.map (fun (name,action) ->
%        wrap_item top_window (name, execute_action action)
%    ) (Array.of_list !!edit_menu));
%  List.iter (fun (menu_name, items) ->
%      top#add_menu menu_name 
%        (Array.map (fun (name,action) ->
%            wrap_item top_window (name, execute_action action)
%        ) (Array.of_list items))
%  ) !!menus;
%  top#add_separator;
%  top#add_menu "Help" (Array.map (wrap_item top_window) !help_menu);
%  top#show;
%*)
%@


\subsection{File menu}

<<constant Top_window.file_menu>>=
let file_menu = define_option ["file_menu"] "" (list_option string2_option) []
@

<<[[Std_efunsrc]] file menu setup>>=
if !!Top_window.file_menu = [] then begin
  Top_window.file_menu =:= [
    "Open File", "load_buffer";
    "Save Buffer", "save_buffer";
    <<file menu entries>>
    "", "";
    "Quit", "exit";
  ]
  end;
@
% cool, everything is configurable :)

%old: open file was: (* "select_open_file";*)

\subsubsection{Opening a file}

% C-x C-f!
<<loading keys>>=
[c_x; ControlMap, Char.code 'f'], "load_buffer";
@
<<loading actions>>=
(* C-x map *)
define_action "load_buffer"  Complexe.load_buffer;
@


% in Complex because requires select and minibuffer
<<function Complex.load_buffer>>=
let load_buffer frame = 
  Select.set_previous_frame frame;
  Select.select_filename frame "Find file: " (fun str -> 
    Frame.load_file frame.frm_window str |> ignore
  )
@
% see later select_filename, quite complicated, use minibuffer
% and completion buffer.

%\subsection{Helpers}

<<function Frame.load_file>>=
let load_file window filename =
  let buf = Ebuffer.read filename (Keymap.create ()) in
  let frame = create window None buf in
  exec_named_hooks !!change_buffer_hooks frame;
  status_name frame buf.buf_name;
  frame
@
% and then the auto redisplay after event will handle the rest!
%note: most of the time nobody uses the returned frame, but the server
% and eval_library uses it.


<<loading keys>>=
[c_x; NormalMap, Char.code 'i'], "insert_file";
@
<<loading actions>>=
(* C-x map *)
define_action "insert_file"  Complexe.insert_file;
@

<<function Complex.insert_file>>=
let insert_file frame =
  Select.select_filename frame "Insert file: " (fun str ->
    let inc = open_in str in
    Simple.insert_string frame (Utils.read_string inc);
    close_in inc
  )
@



%%less: optional I think, this use the toolkit to offer a file
%% browser, but could redirect instead to "load_buffer" which
%% use the minibuffer to open a file
%<<loading actions>>=
%define_action "select_open_file" select_open_file;
%@
%
%<<function Std_efunsrc.select_open_file>>=
%let select_open_file frame =
%  let window = frame.frm_window in
%  let _top_window = Window.top window in
%  let _cdir = Frame.current_dir frame in
%  failwith "Std_efunsrc.select_open_file: TODO"
%(*
%  let info = {
%      filter = Filename.concat cdir "*";
%      current_selection = cdir;
%      predicat = (fun _ -> true);
%      action = (fun _ -> ());
%      cancel = (fun _ -> ());
%    } in
%
%  (* X11 *)
%  let query = new WX_filesel.t top_window.top_root info [] in
%  query#setWM_TRANSIENT_FOR (top_window.top_appli#top :> WX_types.container);
%  info.action <- (fun name ->
%      wrap top_window (fun top_window ->
%          query#destroy;
%          Frame.load_file window name |> ignore
%      ) ());
%  info.cancel <- (fun () ->
%      wrap top_window (fun top_window ->
%          query#destroy;
%      ) ());        
%  query#show
%*)
%@




\subsubsection{Saving the buffer}

<<saving keys>>=
[c_x; ControlMap, Char.code 's'], "save_buffer"; 
@
<<saving actions>>=
(* C-x map *)
define_action "save_buffer"  Complexe.save_buffer; 
@

<<function Complex.save_buffer>>=
let save_buffer frame =
  let buf = frame.frm_buffer in
  match buf.buf_filename with
    Some _ -> Ebuffer.save buf
  | None -> write_buffer frame
@


<<[[Efuns.buffer]] history fields>>=
mutable buf_last_saved : Text.version;
@
% for the ** in the status line.

<<function Ebuffer.save>>=
let save buf =
  exec_named_buf_hooks_with_abort !!saved_buffer_hooks buf;

  let filename =
    match buf.buf_filename with
      None -> raise Not_found
    | Some name -> name
  in
  let outc = open_out filename in
  Text.save buf.buf_text outc;
  close_out outc;
  buf.buf_last_saved <- Text.version buf.buf_text;

  exec_named_buf_hooks !!saved_buffer_hooks buf
@


\subsubsection{Save and change buffer hooks}
% reload

% see also in core DS chapter
% - create_buf_hook  (check_file)
% - change_buffer_hooks
% - save_buffer_hooks (dead??)
% - saved_buffer_hooks


<<constant Ebuffer.saved_buffer_hooks>>=
let saved_buffer_hooks = define_option ["saved_buffer_hooks"] "" 
    (list_option string_option)
  ["update_time" ]
@

<<misc actions>>=
define_buffer_action "update_time" Complexe.update_time;
@

%\subsubsection{Vars}

<<constant Complex.buf_mtime>>=
let buf_mtime = Local.create "buf_mtime" string_of_float float_of_string
@
% why not create_float then?
% who uses this local var? update_time below sets it, but who uses it?
% check_files uses it, which is in change_buffer_hook

<<function Complex.update_time>>=
let update_time buf =
  try
    buf.buf_filename |> Common.do_option (fun file ->
      let st = Unix.lstat file in
      if st.st_kind = S_REG 
      then Efuns.set_local buf buf_mtime st.st_mtime;
    )
  with _ -> ()
@


% load_file | change_buffer -> <> (as change_buffer_hook <- add_hook(<>))
<<function Complex.check_file>>=
let check_file frame =
  try
    let buf = frame.frm_buffer in
    buf.buf_filename |> Common.do_option (fun file ->
      let st = Unix.lstat file in
      if st.st_kind = S_REG then
        try
          let time = Efuns.get_local buf buf_mtime in
          Efuns.set_local buf buf_mtime st.st_mtime;
          if time <> st.st_mtime then
            (Select.select_yes_or_no frame 
               (Printf.sprintf "%s changed on disk; reload (y/n) ?" 
                    buf.buf_name) 
                (fun bool ->
                   if bool 
                   then reload frame 
                   else Frame.status_modified frame true
                 )) |> ignore
       with _ -> Efuns.set_local buf buf_mtime st.st_mtime
    )
  with _ -> ()
@




\subsubsection{More saving operations}

<<saving keys>>=
[c_x; NormalMap, Char.code 's'], "save_some_buffers";
[c_x;ControlMap, Char.code 'w'], "write_file"; 
@
<<saving actions>>=
(* C-x map *)
define_action "save_some_buffers"  Complexe.save_some_buffers;
(* C-x map *)
define_action "write_file"  Complexe.write_buffer; 
@


<<function Complex.save_some_buffers>>=
let save_some_buffers frame =
  let buffers = list_of_hash (Efuns.location()).loc_buffers in
  save_buffers_and_action frame buffers (fun _ -> ())
@
%less: save_buffers_and_action here?

<<function Complex.write_buffer>>=
let write_buffer frame = 
  let buf = frame.frm_buffer in
  Select.select_filename frame "Save file as: " (fun str -> 
    Ebuffer.change_name buf str;
    Ebuffer.save buf
  )
@

%\subsection{Helpers}
<<function Frame.save_buffer>>=
let save_buffer frame =
  Ebuffer.save frame.frm_buffer
@
% dead?


\subsubsection{Exit}

<<misc keys>>=
[c_x; ControlMap, Char.code 'c'], "exit"; 
@
<<misc actions>>=
(* C-x map *)
define_action "exit"  Complexe.exit_efuns; 
@

<<function Complex.exit_efuns>>=
let exit_efuns frame =
  let buffers = Utils.list_of_hash (Efuns.location()).loc_buffers in
  save_buffers_and_action frame buffers (fun _ -> 
    (* todo: have some exit hooks? *)
    exit 0
  )
@
%    (*Graphics.close_graph ();*)

%todo: save_buffers_and_action?

\subsection{Edit menu}

<<constant Top_window.edit_menu>>=
let edit_menu = define_option ["edit_menu"] "" (list_option string2_option) []
@

<<[[Std_efunsrc]] edit menu setup>>=
if !!Top_window.edit_menu = [] then begin
    Top_window.edit_menu =:= [ 
      "Cut",    "kill_region";
      "Paste",  "insert_killed";

      "Undo",    "undo";
      "", "";
      <<[[edit_menu]] entries>>
    ];
  end;
@
% will see later

\subsection{Buffers menu}

% will see later again

\subsection{Help menu}

<<constant Top_window.help_menu>>=
let help_menu = ref ([| |]: (string * action) array)
@
% this one is not configurable apparently, and so use ref instead of option
% was an array, need an array?

<<[[Std_efunsrc]] help menu setup>>=
Top_window.help_menu := [|
  "Key Bindings", (fun frame ->
    Frame.change_buffer frame.frm_window "*bindings*"
  );
  "About Efuns", (fun frame ->
    Frame.change_buffer frame.frm_window "*help*"
  );
  "Changes", (fun frame ->
    (*
      let _ = Frame.load_file frame.frm_window (
          Version.efuns_lib ^"/Changes") in ()
    *)
    failwith "Std_xxx.menu changes: TODO"
  );
|];
@
% see Frame.change_buffer later

%   (*
%        let top_window = Window.top frame.frm_window in        
%        let dialog = new WX_dialog.t top_window.top_root 
%            "Efuns,\nVersion 015\nFabrice Le Fessant\nFabrice.Le_Fessant@inria.fr" [] in
%        dialog#add_button "OK" (fun _ -> dialog#destroy);
%        dialog#show;
%    *)




\section{Sub-windows/Frames}

\subsection{Frames and windows creation}

% have see create_without_top() in core DS chapter
% and its use in Top_window.create in the main chapter.
% Will see later more functions to create frames.

% let's see Frame.install though.


% ((Top_window.create | ...) -> Frame.create_without_top) | v_cut | ... -> <>
<<function Frame.install>>=
let install window frame =
  <<[[Frame.install()]] sanity check frame is not a minibuffer>>

  window |> Window.iter (fun f -> 
     if (f != frame) 
     then kill f
  );
  window.win_down <- WFrame frame;

  frame.frm_xpos <- window.win_xpos;
  frame.frm_ypos <- window.win_ypos;
  frame.frm_width <- window.win_width;
  frame.frm_height <- window.win_height;
  frame.frm_window <- window;

  <<[[Frame.install()]] adjust frm_cutline>>
  <<[[Frame.install()]] set frm_table>>
  frame.frm_redraw <- true
@


\subsection{Frame display}

% the redisplay function!!!

\subsubsection{[[Frame.display()]]}

% (main -> Graphics.init | event loop -> ...) -> Top_window.update_display -> <>
% called for each frame (including the minibuffer's frame when in use)
<<function Frame.display>>=
let display top_window frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in

  let point = frame.frm_point in

  let width = frame.frm_width - frame.frm_has_scrollbar in
  let height = frame.frm_height - frame.frm_has_status_line in

  let graphic = Window.backend top_window in

  <<[[Frame.display()]] if buf sync goto end of text>>
  if
    <<[[Frame.display()]] conditions for redraw>>
  then begin
    <<[[Frame.display()]] redraw>>
  end;
  <<[[Frame.display()]] draw status line or minibuffer>>
@
% was called Frame.update, but I prefer Frame.display,
% to avoid all those update_xxx that are not in the same category
% (e.g.  update_line, update_table, etc)

\subsubsection{Frame decorations display}

<<[[Efuns.frame]] decoration fields>>=
(* 0 for no scrollbar, 2 for scrollbar *)
mutable frm_has_scrollbar : int;
@

<<[[Efuns.frame]] decoration fields>>=
(* 0 for minibuffer, 1 for normal frame *)
mutable frm_has_status_line : int;
(* Some for minibuffer, None for normal frame *)
mutable frm_mini_buffer : string option;
@
% Some means it's a mini buffer frame, in which case
% we don't want status line
%less: redundant frm_has_status_line?

<<[[Frame.display()]] draw status line or minibuffer>>=
match frame.frm_mini_buffer with
| None -> 
    <<[[Frame.display()]] draw status line>>
| Some request ->
    <<[[Frame.display()]] draw minibuffer request string>>
@
% hmm but if minibuffer, it will also redraw its content?
% no cos minibuffer is one line? so does not move?


% will see later those special draw.
% Let's go back to the main window for now.

\subsubsection{Conditions for redraw}

<<[[Frame.display()]] conditions for redraw>>=
<<[[Frame.display()]] conditions for redraw, point outside frame>>
<<[[Frame.display()]] conditions for redraw, buffer modified>>
<<[[Frame.display()]] conditions for redraw, forced redraw>>
@

% a frame is a view over a buffer, from line x to line y
% and cursor at point.

<<[[Efuns.frame]] current position fields>>=
(* first point of the first buffer-line on screen *)
mutable frm_start : Text.point;
(* last point on screen, -1 if modified *)
mutable frm_end : Text.point;
@


<<[[Frame.display()]] conditions for redraw, point outside frame>>=
(point < frame.frm_start) ||
(point > frame.frm_end)  || 
@
% > ?? because use the first field anyway?



<<[[Efuns.frame]] history fields>>=
mutable frm_last_text_updated : int;
mutable frm_last_buf_updated : int;
@
% frm_last_text_updated actually seems to decrement in undo
% and seems used only there

% so if have 2 frames on the same buffer, then
% modifying in one frame will cause the other frame to be updated too.

<<[[Frame.display()]] conditions for redraw, buffer modified>>=
(version text <> frame.frm_last_text_updated) ||
(buf.buf_modified <> frame.frm_last_buf_updated) ||
@
% when the text can be modified?? when a buffer can be modified?

<<[[Efuns.frame]] other fields>>=
mutable frm_redraw : bool;    
@
% when switch back or create a new frame, nothing has
%  been computed in frm_table, so we force a redraw.
% Used also when modify some text in which case we don't
% need to redraw the other lines. But if we end up scrolling,
% then we want to redraw all the lines.

<<[[Frame.display()]] conditions for redraw, forced redraw>>=
frame.frm_redraw
@


\subsubsection{Redraw}

<<[[Frame.display()]] redraw>>=
if !debug_display
then pr2 "redraw";
<<[[Frame.display()]] redraw, possibly update frm_y_offset>>
<<[[Frame.display()]] redraw, possibly update frm_x_offset>>
update_table frame;

if (point > frame.frm_end) || (point < start) then begin
    <<[[Frame.display()]] redraw, if frm_force_start>>
    else begin
      Text.goto_point text start point;
      <<[[Frame.display()]] redraw, update frm_y_offset again>>
      update_table frame;
   end
end;

<<[[Frame.display()]] redraw, scrollbar adjustments>>

frame.frm_last_text_updated <- version text;
frame.frm_last_buf_updated <- buf.buf_modified;

for y = 0 to height - 1 do
  <<[[Frame.display()]] redraw, draw line y if line changed>>
done;
frame.frm_redraw <- false
@
%bug! there was a point > start instead of point < start!
% so then when going back it was not redisplaying!
% it's because of some past (wrong) refactoring,
% because before it was 'if (frame.frm_end < point)  || (start > point)'

% need to do the first update_table when point outside <frm_start,frm_end>?
% seems unecessary. Then we could have a proper if then else with
% the second update_table.

\subsection{Line display}

% text -> x,y display (and cursor below is the reverse)

% data -> text_string -> 
% text_newlines -> 
%  repr_string (^M) ->
% frm_table ->
%  frm_line (\)

% FIGURE! where see how text_string with special char
% lead to a different repr_string which then when too longs leads
% to multiple frm_line for one of text_newlines.


% frame have a width!

<<[[Efuns.frame]] other fields>>=
(* where do we put a \ for overflowing lines *)
mutable frm_cutline : int; (* max_int for no, else length *)
@

<<[[Frame.install()]] adjust frm_cutline>>=
if frame.frm_cutline < max_int 
then frame.frm_cutline <- window.win_width - 1;
@


\subsubsection{The frame table}
%[[Frame.update_table()]]

<<[[Efuns.frame]] other fields>>=
mutable frm_table : frm_line array;
@
% line 0 is the line that you see in the frame,
% so this table is a sort of slice of the original text_newlines.
% But it also manages the overflow lines! so it's not exactly a slice!

% diff with frm.frm_buffer.buf_text.newlines? well it handles overflow
% some some Text.line corresponds sometimes to 2 frm_line, but
% with different repr_xxx values.

<<type Efuns.line_repr>>=
and frm_line =
  { 
    mutable frm_text_line : Text.line;

   (* sorted normally, head = first box in line *)
   mutable frmline_boxes : Text.box list; 
   mutable first_box_extra_offset : int;

    <<[[Efuns.frm_line]] other fields>>
  } 
@
%old: was repr_line, but there was also line_repr, so better
% rename this frm_line. otherwise had line_repr.repr_line.boxes.box_pos, hmmm
%old: was repr_y, repr_x, repr_offset, but again, there was
% too many repr_xxx where actually you don't know what they reference
% (text_string? text_newlines? repr_string? frm_table?)
%dead: repr_x, was not used.
%why need frmline_boxes? why not use frm_text_line.repr_reprs instead?
% because it could have changed in the mean time? 
% it is mainly for the overflow I think, in which case the boxes are 
% actually different!
%why need frm_text_line then? just for the repr_string it contains?
% then why not replace frm_text_line by that then? It's used for ==
% another line in set_cursor, so maybe it's needed.


<<[[Efuns.frm_line]] other fields>>=
mutable lineidx_in_text : int;
@
% why need that? frm_text_line not enough?
% for cursor_to_point?


<<[[Frame.install()]] set frm_table>>=
frame.frm_table <- (Array.init window.win_height (fun i -> 
   {
     frm_text_line = Text.dummy_line;
     frmline_boxes = [];

     lineidx_in_text = 0;
     first_box_extra_offset = 0;

     repr_prev_offset = 0;
     prev_frmline_boxes = [];
   } 
));
@

\subsubsection{[[Frame.update_table()]]}

% y goes from 0 to height below, which are the entries
% for frm_table that we need to fill.

% Top_window.update_display -> Frame.display -> <>
<<function Frame.update_table>>=
let update_table frame =
  let buf =  frame.frm_buffer in
  let text = buf.buf_text in

  let start = frame.frm_start in
  let height = frame.frm_height - frame.frm_has_status_line in

  let current_n = ref (Text.point_line text start) in
  let current_line = ref (Ebuffer.compute_representation buf !current_n) in

  <<[[Frame.update_table()]] adjust current line when frm_y_offset negative>>

  <<[[Frame.update_table()]] adjust current line when frm_y_offset positive>>

  (* update frame.frm_start *)
  Text.goto_line text start !current_n; 

  (* update frame representation *)
  <<function Frame.update_table.iter_line>>
  <<function Frame.update_table.iter_repr>>

  iter_line (- frame.frm_y_offset) !current_n !current_line
@


<<function Frame.update_table.iter_line>>=
let rec iter_line y n line =
  if y < height then begin
    let reprs = List.rev line.boxes in
    if y >= 0 then begin
        let frm_line = frame.frm_table.(y) in
        frm_line.frm_text_line <- line;
        frm_line.frmline_boxes <- reprs;
        frm_line.lineidx_in_text <- n;
        frm_line.first_box_extra_offset <- 0;
    end;
    iter_repr frame.frm_cutline (y+1) n line reprs
  end
  else Text.goto_line text frame.frm_end (n-1)
@

<<function Frame.update_table.iter_repr>>=
and iter_repr xcutline y n line reprs =
  <<[[Frame.update_table.iter_repr()]] if line too big>>
  else  
    let line = Ebuffer.compute_representation buf (n+1) in
    iter_line y (n+1) line
in
@


\subsubsection{[[Frame.display_line()]]}

%old: was called update_line, but was a good name? 
% as opposed to update_table, here it's more
% about the display that updating some internal structure. 
% So I renamed it.

<<[[Frame.display()]] redraw, draw line y if line changed>>=
let frm_line = frame.frm_table.(y) in

if not ((frm_line.prev_frmline_boxes == frm_line.frmline_boxes) &&
        (frm_line.repr_prev_offset == frm_line.first_box_extra_offset)) 
   || frame.frm_redraw
then
  begin
    frm_line.prev_frmline_boxes <- frm_line.frmline_boxes;
    frm_line.repr_prev_offset <- frm_line.first_box_extra_offset;

    display_line graphic frame frm_line.frm_text_line.repr_string y;
  end;
@
%todo: old: was line.repr_line.repr_string, ugly

<<[[Efuns.frm_line]] other fields>>=
(* previous values, so can check if the line changed *)
mutable repr_prev_offset : int;
mutable prev_frmline_boxes : Text.box list;
@
% it's an opti, not sure it's that useful

% finally reach the graphic backend!

<<function Frame.display_line>>=
let display_line graphic frame repr_string y = 
  let frm_line = frame.frm_table.(y) in

  let rec iter x offset boxes =
    if x < frame.frm_width then
      match boxes with
      | [] -> 
          graphic.Xdraw.clear_eol (x+frame.frm_xpos) (y+frame.frm_ypos)
            (frame.frm_width - x)
      | box :: tail ->
          let len = min (frame.frm_width-x) (box.box_size - offset) in
          graphic.Xdraw.draw_string (x+frame.frm_xpos) (y+frame.frm_ypos)
            repr_string (box.box_pos_repr+offset) len
            box.box_attr;
          iter (x+len) 0 tail
    else
      <<[[Frame.display_line()]] in iter, line overflow frm_width>>
  in
  iter 0 (frm_line.first_box_extra_offset + frame.frm_x_offset) frm_line.frmline_boxes
@
%old: was called update_line, but confusing with update_table
% which is quite different.

\subsubsection{Overflowing lines}


% xcutline is originally frm_cutline = frm_width - 1
<<[[Frame.update_table.iter_repr()]] if line too big>>=
if line.repr_len > xcutline then
  match reprs with
  | repr :: tail ->
      if repr.box_pos_repr <= xcutline && 
         repr.box_pos_repr + repr.box_size > xcutline
      then
        if y = height 
        then Text.goto_line text frame.frm_end n 
        else begin
            if y>= 0 then begin
              let frm_line = frame.frm_table.(y) in
              frm_line.frm_text_line <- line;
              frm_line.lineidx_in_text <- n;
              frm_line.first_box_extra_offset <- xcutline - repr.box_pos_repr;
              frm_line.frmline_boxes <- reprs;
            end;
            iter_repr (xcutline+frame.frm_cutline) (y+1) n line reprs
        end
      else iter_repr xcutline y n line tail
  | [] -> 
      let line = Ebuffer.compute_representation buf (n + 1) in
      iter_line (y+1) (n+1) line
@
% generate multi frm_line for one text_newline
%old: frm_line.repr_x <- repr.box_pos_repr;

%FIGURE again, where see skip the first few boxes, because
% they are handled by the previous line, and will not overflow
% because of the code below:

<<[[Frame.display_line()]] in iter, line overflow frm_width>>=
graphic.Xdraw.draw_string 
   (frame.frm_width+frame.frm_xpos-1) (y+frame.frm_ypos)
   "/" 0 1 Text.direct_attr
@
% the / at the end of the line!


\subsection{Cursor}

% x,y display -> text (reverse of display_line stuff)

% why not return an actual point then? it's more a (line x col) actually
<<function Frame.cursor_to_point>>=
let cursor_to_point frame x y =
  <<[[Frame.cursor_to_point()]] sanity check parameters in range>>
  let frm_line = frame.frm_table.(y) in
  let line = frm_line.lineidx_in_text in
  let rec iter x boxes default =
    match boxes with
      [] -> default
    | box :: tail -> 
        if x < box.box_size
        then box.box_pos + x / box.box_charsize
        else iter (x - box.box_size) tail (box.box_pos + box.box_len)
  in
  let col = iter (x + frame.frm_x_offset + frm_line.first_box_extra_offset) 
    frm_line.frmline_boxes 0 
  in
  col , line
@
% useful for? the mouse?

<<function Frame.point_to_cursor>>=
let point_to_cursor buf point =
  let text = buf.buf_text in
  let line = Ebuffer.compute_representation buf (Text.point_line text point) in
  let xpos = Text.point_col text point in
  let rec iter reprs =
    match reprs with
    | [] -> 0
    | repr :: tail ->
        if repr.box_pos > xpos 
        then iter tail
        else repr.box_pos_repr + repr.box_charsize *  (xpos - repr.box_pos)
  in
  iter line.Text.boxes
@



<<[[Frame.cursor_to_point()]] sanity check parameters in range>>=
if (y < 0) || (x<0) || (y >= frame.frm_height-1) || (x>frame.frm_cutline) 
then raise Not_found;
@

<<[[Efuns.frame]] other fields>>=
mutable frm_cursor_x : int;
mutable frm_cursor_y : int;
mutable frm_cursor : string;
mutable frm_cursor_attr : Text.attribute;
@
% a frame has a cursor!
% x and y here are coordinates in the frame, not top_window coordinates,
% and not text_string coordinates.






% an output, but strongly related
% also to input devices (input device feedback essentially)

% Top_window.update_display -> <>
<<function Top_window.cursor_on>>=
let cursor_on top_window =
  let frame = top_window.top_active_frame in
  let name = frame.frm_buffer.buf_name in
  if not (name == top_window.top_name) then begin
    Common.pr2_once "Top_window.top_apply#setWM_NAME";
    (* top_window.top_appli#setWM_NAME name; *)
    top_window.top_name <- name
  end;
  set_cursor_on top_window frame;
  top_window.top_second_cursor |> Common.do_option (fun frame ->
    set_cursor_on top_window frame
  )
@
% when can have second_cursor? for C-s! you edit in mini_frame
%  but the cursor is on the searched frame
% todo: aspectize second_cursor


<<function Top_window.set_cursor_on>>=
let set_cursor_on top_window frame = 
  Frame.set_cursor frame;
  if frame.frm_cursor.[0] <> '\000' then
    let graphic = Window.backend top_window in
    graphic.Xdraw.draw_string
      (frame.frm_xpos + frame.frm_cursor_x-frame.frm_x_offset)
      (frame.frm_ypos + frame.frm_cursor_y) 
      frame.frm_cursor 0 1 Text.inverse_attr
@


%\subsection{[[Top_window.clean_display()]]}

% event loop -> ... -> handle_key -> ...; <>; Top_window.update_display()
<<function Top_window.clean_display>>=
let clean_display () =
  (Efuns.location()).top_windows |> List.iter cursor_off 
@

% update_display -> clean_display -> <>
<<function Top_window.cursor_off>>=
let cursor_off top_window =
  let frame = top_window.top_active_frame in
  set_cursor_off top_window frame;
  top_window.top_second_cursor |> Common.do_option (fun frame ->
    set_cursor_off top_window frame
  )
@

<<function Top_window.set_cursor_off>>=
let set_cursor_off top_window frame =
  if frame.frm_cursor.[0] <> '\000' then
    let graphic = Window.backend top_window in
    graphic.Xdraw.draw_string
      (frame.frm_xpos + frame.frm_cursor_x) 
      (frame.frm_ypos + frame.frm_cursor_y) 
      frame.frm_cursor 0 1 frame.frm_cursor_attr
@
% inverse!


\subsection{Frame offsets}


<<[[Efuns.frame]] other fields>>=
(* ?? *)
mutable frm_x_offset : int;
(* offset(+/-) of screen-lines after frm_start *)
mutable frm_y_offset : int;
@





\subsubsection{Y offset}

<<[[Frame.display()]] redraw, possibly update frm_y_offset>>=
let start = frame.frm_start in
let start_c = point_to_cursor buf start in
if start_c > 0 then begin
  frame.frm_y_offset <- frame.frm_y_offset - start_c / frame.frm_cutline;
  Text.bmove text start start_c |> ignore
end;
@

<<[[Frame.display()]] redraw, update frm_y_offset again>>=
frame.frm_y_offset <- - height / 2;
let start_c = point_to_cursor buf start in
if start_c > 0 then begin
  frame.frm_y_offset <- frame.frm_y_offset - start_c / frame.frm_cutline;
  Text.bmove text start start_c |> ignore
end;
@





<<[[Frame.update_table()]] adjust current line when frm_y_offset positive>>=
(* assert current_line is the first line *)

while frame.frm_y_offset > !current_line.repr_len / frame.frm_cutline
    && !current_n < nbre_lines text
do
  frame.frm_y_offset <- frame.frm_y_offset - 
    (!current_line.repr_len / frame.frm_cutline) - 1;
  current_n := !current_n + 1;
  current_line := Ebuffer.compute_representation buf !current_n;
done;

if !current_n = nbre_lines text && 
   frame.frm_y_offset > !current_line.repr_len / frame.frm_cutline
then frame.frm_y_offset <- !current_line.repr_len / frame.frm_cutline;
@

<<[[Frame.update_table()]] adjust current line when frm_y_offset negative>>=
(* assert frame.frm_y_offset >= 0 *)

while frame.frm_y_offset < 0 && !current_n > 0 do
  current_n := !current_n - 1;
  current_line := Ebuffer.compute_representation buf !current_n;
  let lines = !current_line.repr_len / frame.frm_cutline in
  frame.frm_y_offset <- frame.frm_y_offset + lines + 1;
done;
if !current_n = 0 && frame.frm_y_offset <0 
then frame.frm_y_offset <- 0;
@

\subsubsection{X offset}

<<[[Frame.display()]] redraw, possibly update frm_x_offset>>=
let point_c = point_to_cursor buf point in
if point_c < frame.frm_x_offset then begin
    frame.frm_x_offset <- max (point_c - width / 2) 0;
    frame.frm_redraw <- true;
end else if frame.frm_cutline = max_int && 
            (point_c mod frame.frm_cutline >= frame.frm_x_offset + width - 3)  
  then begin
    frame.frm_x_offset <- point_c - (width / 2);
    frame.frm_redraw <- true;
end;
@

\subsubsection{Recenter}

<<misc keys>>=
[ControlMap, Char.code 'l'], "recenter";
@
<<misc actions>>=
define_action "recenter"  Simple.recenter;
@

<<function Simple.recenter>>=
let recenter frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  frame.frm_force_start <- true;
  frame.frm_redraw <- true;
  Text.goto_point text frame.frm_start frame.frm_point;
  frame.frm_y_offset <- - frame.frm_height/2
@

% not sure it's related only to scrollbar thing
<<[[Efuns.frame]] other fields>>=
mutable frm_force_start : bool;
@

<<[[Frame.display()]] redraw, if frm_force_start>>=
if frame.frm_force_start then begin
  let x,y = 
    cursor_to_point frame frame.frm_cursor_x frame.frm_cursor_y
  in
  Text.goto_line text frame.frm_point y;
  Text.fmove text frame.frm_point x |> ignore
end 
@

\subsection{Scrollbar}

%later: can have sublime style toolbar actually!
% or firefox style
% https://atom.io/packages/minimap
% codemap spirit!

%<<[[Top_window.create()]] optional scrollbar setup>>=
%(* ady#add_subject (fun () -> *) (
%(*
%      let ady = () in
%      let frame = top_window.top_active_frame in
%      if not frame.frm_force_start then
%        wrap top_window (scroll_to_frame ady) ()
%*)
%  ()
%  );
%@

%todo: comment? need that?

<<function Top_window.scroll_to_frame>>=
let scroll_to_frame ady top_window =
  let frame = top_window.top_active_frame in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let pos_start = Text.get_position text frame.frm_start in
  let _size = Text.size text in
  Common.pr2 "ady#get_pos size";
  let y = 1
(*    ady#get_pos size  *)
  in
  if abs (y - pos_start) > 80 then
  (* the position has changed *)
    begin
      frame.frm_force_start <- true;
      frame.frm_redraw <- true;
      Text.set_position text frame.frm_start y
    end
@
%(*
%    Text.set_position text point y;
%      let point = Text.new_point text in
%      let curline = Text.point_line text frame.frm_start in
%      let newline = Text.point_line text point in
%      Text.remove_point text point;
%    frame.frm_y_offset <- frame.frm_y_offset + (newline - curline);
%  *)




<<[[Frame.display()]] redraw, scrollbar adjustments>>=
if frame == top_window.top_active_frame then begin
  frame.frm_force_start <- true; (* AVOID CYCLING IN SCROLLBAR *)
  let _pos_start = get_position text frame.frm_start in
  let _pos_end   = get_position text frame.frm_end in

  Common.pr2_once "Frame.display: TODO scrollbar";
  (*top_window.top_scrollbar#set_params pos_start (pos_end - pos_start) 
     (size text);
   *)
end;
frame.frm_force_start <- false;
@
%todo: how frm_force_start can ever be true? it's true only temporarily
% so I don't get how the flow can go two times in Frame.display?

\section{[[Status]] Line}

\subsection{Status line creation}

<<[[Efuns.frame]] status field>>=
mutable frm_status : status;    
@

<<type Efuns.status>>=
and status =
  { 
    mutable stat_name : string;
    mutable stat_file : string;
    mutable stat_line : int;
    mutable stat_col : int;

    mutable status_modified : bool;
    mutable stat_modified : bool;
    <<[[Efuns.status]] other fields>>
  }
@

<<[[Frame.create_without_top()]] let status>>=
let status = {
    stat_name = "";
    stat_file = "";
    stat_line = -1;
    stat_col = -1;
    status_modified = true;
    stat_modified = (buf.buf_last_saved = Text.version buf.buf_text);

    stat_modes = [];
    stat_mode = dummy_mode;

    status_format = !status_format;

    status_string = String.make 256 '-';
  } in
String.blit editname 0 status.status_string 5 (String.length editname);
@

<<constant Frame.editname>>=
let editname = "Efuns:"
@

<<[[Frame.create_without_top()]] adjust status of frame>>=
status_name frame buf.buf_name;
@

<<function Frame.status_name>>=
let status_name frame name =
  let status = frame.frm_status in
  if status.stat_name <> name then begin
    status.stat_name <- name;
    status_print status name StatName
  end
@

\subsection{Status line format}

<<[[Efuns.status]] other fields>>=
(* the pair of int is a:   pos * max_len *)
mutable status_format : (status_info * (int * int)) list;
@

<<type Efuns.status_info>>=
and status_info =
| StatName
| StatFile
| StatLine
| StatCol
| StatModified
| StatMode
@
% also clock, load, etc

<<constant Frame.status_format>>=
let status_format = ref [
    StatModified , (1, 2);
    StatName, (5, 20);
    StatMode, (30,30);
    StatLine, (65, 5);
    StatCol, (70 , 5);
    StatFile, (35,15);
  ]
@
% meaning? see below, it's a (pos, maxlen)

\subsection{[[Frame.status_print()]]}

% status_name | status_modified | ... -> <>
<<function Frame.status_print>>=
let status_print status str stat_type =
  status.status_modified <- true;
  try
    let (pos,maxlen) = List.assoc stat_type status.status_format in
    let len = min (String.length str) maxlen in
    String.blit str 0 status.status_string pos len;
    String.fill status.status_string (pos + len) (maxlen - len) ' '
  with Not_found -> ()
@

<<[[Efuns.status]] other fields>>=
(* the string! --- ... --- *)
mutable status_string : string;
@
% this will then be the only thing used in the rendering

\subsection{[[Frame.status_xxx()]]}

% Frame.display -> <>
<<function Frame.status_modified>>=
let status_modified frame modified =
  let status = frame.frm_status in
  if status.stat_modified <> modified then begin
    status_print status (if modified then "**" else "--") StatModified;
    status.stat_modified <- modified
  end
@

% Frame.display -> <>
<<function Frame.status_line>>=
let status_line frame line =
  let status = frame.frm_status in
  if status.stat_line <> line then begin
    status.stat_line <- line;
    status_print status (Printf.sprintf "L%d" (line+1)) StatLine
  end
@
% note the +1

% Frame.display -> <>
<<function Frame.status_col>>=
let status_col frame col =
  let status = frame.frm_status in
  if status.stat_col <> col then begin
    status.stat_col <- col;
    status_print status (Printf.sprintf "C%d" (col+1)) StatCol
  end
@
% note the +1


%<<function Frame.status_file>>=
%let status_file frame name =
%  let status = frame.frm_status in
%  if status.stat_file <> name then
%    begin
%      status.stat_file <- name;
%      status_print status name StatFile
%    end
%@
% dead? status_name is used instead.

\subsection{Status line display}

<<[[Frame.display()]] draw status line>>=
let status = frame.frm_status in

status_modified frame (version text <> buf.buf_last_saved);
status_line frame  (point_line text frame.frm_point);
status_col  frame  (point_col  text frame.frm_point);
status_name frame buf.buf_name;
status_major_mode frame;

if status.status_modified 
then
  graphic.Xdraw.draw_string 
    frame.frm_xpos (frame.frm_ypos + frame.frm_height - 1)
    status.status_string 
    0 width Text.inverse_attr
@

% todo: actually if not active_frame should do Text.direct_attr

\section{Minibuffer}

% way to ask for user input (that is different from the text user input).

\subsection{Minubuffer creation}

% when it's created? each time enter M-x?

<<[[Efuns.top_window]] other fields>>=
mutable top_mini_buffers : frame list;
@
% there are many mini_buffers??

% ?? -> <>
<<function Minibuffer.create>>=
let create frame local_map request =
  let window = frame.frm_window in
  let top_window = Window.top window in

  let qlen = String.length request in
  let request = 
     if qlen < 50 
     then request 
     else String.sub request 0 47 ^ "..."
  in

  let mini_text = 
    Text.create "" in
  let mini_buf = 
    buf_create mini_text local_map in
  let mini_window = 
    Window.create true (*mini*) (TopWindow top_window) 
      qlen (top_window.top_height - 1) (top_window.top_width - qlen) 1 in
  let mini_frame = 
    Frame.create mini_window (Some request)(*mini*) mini_buf in    

  mini_frame.frm_cutline <- max_int;
  mini_frame.frm_has_status_line <- 0;

  top_window.top_mini_buffers <- mini_frame :: top_window.top_mini_buffers;

  Keymap.add_binding local_map [ControlMap, Char.code 'g']
    (fun mini_frame -> kill mini_frame frame);
  mini_frame
@
% C-g :)


<<[[Efuns.window]] other fields>>=
mutable win_mini : bool;
@
% which is what is used in Window.create true


% Minibuffer.create -> <>
<<function Minibuffer.buf_create>>=
let buf_create text local_map =
  { 
    buf_text = text;
    buf_name = "*Minibuffer*";
    buf_filename = None; (* no connected file! *)

    buf_major_mode = Ebuffer.fondamental_mode;
    buf_minor_modes = [];

    buf_charreprs = charreprs;
    buf_map = local_map;
    buf_map_partial = true;
    buf_syntax_table = Ebuffer.default_syntax_table;

    buf_modified = 0;
    buf_last_saved = Text.version text;

    buf_point = Text.new_point text;
    buf_start = Text.new_point text;
    buf_mark = None;

    buf_sync = false;
    buf_shared = 0;
    buf_finalizers = [];

    buf_vars = Local.vars ();
  }
@


<<[[Frame.install()]] sanity check frame is not a minibuffer>>=
if window.win_mini = (frame.frm_mini_buffer = None) then begin 
  kill frame; 
  failwith "Cannot install in minibuffer"
end;
@

\subsection{Minibuffer display}

<<[[Frame.display()]] draw minibuffer request string>>=
graphic.Xdraw.draw_string
 0 (top_window.top_height-1)  
 request 
 0 (String.length request) Text.direct_attr
@

% event loop -> ... -> Top_window.handle_key -> <>
<<function Top_window.clear_message>>=
let clear_message top_window =
  match top_window.top_mini_buffers with
    [] -> 
      let graphic = Window.backend top_window in
      graphic.Xdraw.clear_eol 
        0 (top_window.top_height - 1) 
        top_window.top_width; 
  | _ -> ()
@


\subsection{[[Top_window.message()]]}

% convenient to communicate info

<<function Top_window.message>>=
let message top_window msg =
  let graphic = Window.backend top_window in
  let len = String.length msg in

  graphic.Xdraw.draw_string 0 (top_window.top_height - 1)
    msg 0 len Text.direct_attr;
  graphic.Xdraw.clear_eol len (top_window.top_height - 1)
    (top_window.top_width - len);

  match top_window.top_mini_buffers with
    [] -> (* No mini-buffer ... *) ()
  | mini_buffer :: _ -> (* one mini-buffer is active *)
      graphic.Xdraw.update_display ();
      (* let _ = Unix.select [] [] [] 0.2 in *)
      mini_buffer.frm_redraw <- true
@
%less: do a sleep 0.2?



\chapter{Input Managment}

\section{Keyboard}

\subsection{Keys to action, [[try_map()]]}

<<exception Efuns.UnboundKey>>=
exception UnboundKey
@

<<[[Efuns.frame]] other fields>>=
mutable frm_prefix : key list;
@
% prefix, have to wait for another key press

% Top_window.handle_key -> <>(top_window.top_active_frame, ...)
<<function Top_window.try_map>>=
let try_map frame key =
  let keylist = frame.frm_prefix @ [key] in
  match Ebuffer.get_binding frame.frm_buffer keylist with
  | Function f ->
      frame.frm_prefix <- [];
      (* dispatch the action *)
      <<[[Top_window.try_map()]] if debug, print action name>>
      f frame; 
      <<[[Top_window.try_map()]] set last action>>
  | Prefix map ->
      frame.frm_prefix <- keylist;
      let top_window = Window.top frame.frm_window in
      message top_window (Keymap.print_key_list frame.frm_prefix);
  | Unbound -> raise UnboundKey
@
%old:      <<[[Top_window.try_map()]] set repeat action>>


% Ebuffer.get_binding is essentially trying to find the right map
% (buffer map, major mode map, global map)

% Ebuffer.get_binding -> <>
<<function Keymap.get_binding>>=
let rec get_binding map keylist =
  match keylist with
    [] -> Unbound
  | [key] ->
        <<[[Keymap.get_binding()]] find key in map>>
  | key :: tail ->
      match
        <<[[Keymap.get_binding()]] find key in map>>
      with
      | Prefix map -> get_binding map tail
      | _ -> Unbound
@
% lookup


<<[[Keymap.get_binding()]] find key in map>>=
(match key with
  (NormalMap,key) when key >= 0 && key < 256 -> 
    map.char_map.(key)
| _ -> 
    try List.assoc key map.complex_bindings
    with Not_found -> Unbound
 )
@

<<[[Top_window.handle_key()]] handle exception of try_map>>=
| UnboundKey -> 
    message top_window
      (Printf.sprintf "Unbound key %s"
        (Keymap.print_key_list (frame.frm_prefix @ [key])));
    frame.frm_prefix <- [];
| Failure str -> message top_window str
| e -> 
    if !debug
    then pr2 (spf "Uncaught exception %s" (Utils.printexn e));
    message top_window 
      (Printf.sprintf "Uncaught exception %s" (Utils.printexn e))
@


% useful for undo, will see also useful for goal-column

<<[[Efuns.frame]] other fields>>=
mutable frm_last_action : action;
@
<<[[Top_window.try_map()]] set last action>>=
frame.frm_last_action <- f
@

\subsection{Action to keys, [[add_binding()]]}

<<function Keymap.add_binding>>=
let rec add_binding map key_list binding =
  match key_list with
    [] -> failwith "ERROR add_complex_binding: empty key list"
  | [key] -> set_binding map key (Function binding)
  | key :: tail ->
      match
        match key with
          (NormalMap,key) when key >= 0 && key < 256 -> 
            map.char_map.(key)
        | _ -> 
            try
              List.assoc key map.complex_bindings
            with
              Not_found -> Unbound
      with
        Prefix map -> add_binding map tail binding
      | Unbound ->
          let newmap = create () in
          set_binding map key (Prefix newmap);
          add_binding newmap tail binding;
      | e -> 
          failwith "ERROR add_complex_binding: Unable to add prefix"
@


<<function Keymap.set_binding>>=
let set_binding map key binding =
  match key with
    (NormalMap,key) when key >= 0 && key < 256 -> 
      map.char_map.(key) <- binding
  | _ -> 
      map.complex_bindings <- (key,binding) :: map.complex_bindings
@


\subsection{Bindings display}

<<misc keys>>=
[c_h; NormalMap, Char.code 'K'], "help_bindings";
@
<<misc actions>>=
(* C-h map *)
define_action "help_bindings"  Frame.bindings_help;
@

<<function Frame.bindings_help>>=
let bindings_help frame =
  let window = frame.frm_window in
  change_buffer window "*bindings*"
@
% how can change_buffer with just window info? don't pass the frame?
% no need because can go back to top_window and active_frame?



% Graphics_efun.init -> <>
<<function Interactive.create_bindings>>=
let create_bindings () =
  let s = Keymap.all_bindings () in
  let text = Text.create s in
  Ebuffer.create "*bindings*" None text (Keymap.create ())
@


<<function Keymap.all_bindings>>=
let all_bindings () =
  let s = ref "Default bindings:" in
  (Efuns.location()).loc_map.interactives |> List.iter(fun (name,(_,binding)) ->
    match binding with
    | None -> ()
    | Some key_list ->
        s := Printf.sprintf "%s\n%20s : %s" !s 
              (print_key_list key_list) name
  );
  !s
@
% used to be copy pasted in create_bindings, with only diff was
% the %s\n%20s : %s" and the use of List.rev.

<<function Keymap.print_key>>=
let print_key (map,keysym) =
  let prefix =
    match map with
    | NormalMap -> ""
    | ControlMap -> "C-"
    | MetaMap -> "M-"
    | ControlMetaMap -> "CM-"
  in
  let kname =
    try List.assoc keysym XK.keysym_to_name
    with Not_found -> 
      try Printf.sprintf "%c" (Char.chr keysym)
      with Invalid_argument _ -> "?"
  in
  prefix^kname
@

<<function Keymap.print_key_list>>=
let rec print_key_list key_list =
  match key_list with
  | [] -> ""
  | [key] -> Printf.sprintf "%s" (print_key key)
  | key :: tail ->
      Printf.sprintf "%s %s" (print_key key) (print_key_list tail)
@




% ?? -> <>
%<<function Keymap.print>>=
%let print map =
%  Printf.printf "MAP:\n";
%  List.iter (fun (key, binding) ->
%    (match binding with
%      Prefix _ -> print_string "Prefix "; 
%    | Function _ -> print_string "Function"
%    | Unbound -> print_string "Unbound"
%          );
%    print_string (print_key key);
%    print_newline ()
%      ) map.complex_bindings
%@
% dumper? could mv in debugging section



\section{Mouse}

<<constant Top_window.mouse_x>>=
let mouse_x = ref 0
@

<<constant Top_window.mouse_y>>=
let mouse_y = ref 0
@

<<[[Top_window.handler()]] match event cases>>=
| Xtypes.XTButtonPress (modifiers,button,x,y) -> 
    mouse_x := x;
    mouse_y := y;
    handle_key top_window modifiers (XK.xk_Pointer_Button_Dflt + button)
@




<<[[Std_efunsrc.init_global_map()]] mouse keys setup>>=
Keymap.add_global_key [NormalMap, XK.xk_Pointer_Button1]
  "set_active_frame" Simple.mouse_set_frame;
Keymap.add_global_key [NormalMap, XK.xk_Pointer_Button2]
  "insert_at_point" Simple.mouse_yank_at_click;
Keymap.add_global_key [NormalMap, XK.xk_Pointer_Button3]
  "mouse_save_then_kill" Simple.mouse_save_then_kill;
@

<<function Simple.mouse_set_frame>>=
let mouse_set_frame frame =
  let top_window = Window.top frame.frm_window in
  let frame = Top_window.mouse_set_active top_window in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let mark = Ebuffer.get_mark buf point in
  Text.goto_point text mark point;
  ()
@

<<function Simple.mouse_yank_at_click>>=
let  mouse_yank_at_click frame =
failwith "Simple.mouse_yank_at_click: TODO"
(*
  let top_window = Window.top frame.frm_window in
  let frame = mouse_set_active top_window in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let xterm = Window.xterm top_window in
  let str = WX_xterm.get_cutbuffer xterm in
  Text.insert text point str |> ignore;
  Text.fmove text point (String.length str)
*)
@

<<function Simple.mouse_save_then_kill>>=
let mouse_save_then_kill frame =
  failwith "Simple.mouse_save_then_kill: TODO"
(*
  let top_window = Window.top frame.frm_window in
  let frame = Top_window.find_selected_frame top_window in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let mark = Ebuffer.get_mark buf point in
  let new_point = new_point text in
  Frame.move_point frame new_point !mouse_x !mouse_y;
  if point = new_point then
    begin
      remove_point text new_point;
      let (start,term) =
        if point < mark then (point,mark) else (mark,point) 
      in
      Text.delete text start (Text.distance text start term) |> ignore
    end
  else
  let xterm = Window.xterm top_window in
  goto_point text mark point;
  goto_point text point new_point;
  remove_point text new_point;
  let str = Text.region text mark point in
  kill_string str;
  WX_xterm.set_cutbuffer xterm str;
  highlight frame
*)
@



<<[[Top_window.handler()]] match event cases>>=
| Xtypes.XTMouseMotion (modifiers,button,x,y) ->
    mouse_x := x;
    mouse_y := y;
    handle_key top_window modifiers (XK.xk_Pointer_Drag_Dflt + button)
@

<<[[Top_window.handler()]] match event cases>>=
| Xtypes.XTResize (new_width, new_height) ->
    resize_window top_window.window 0 0 new_width (new_height - 1);
    top_window.top_mini_buffers |> List.iter (fun frame -> 
      let window = frame.frm_window in
      window.win_ypos <- new_height - 1;
      window.win_width <- new_width;
      Frame.install window frame
    );
    top_window.top_width <- new_width;
    top_window.top_height <- new_height;
    clear_message top_window;
    update_display ()
@          


\section{Interactive select}
% here?


\subsection{[[M-x foo]], [[call_interactive()]]}

<<meta keys>>=
[MetaMap, Char.code 'x'], "call_interactive";
@
<<meta actions>>=
define_action "call_interactive"  Interactive.call_interactive;
@


<<constant Interactive.meta_hist>>=
let meta_hist = ref []
@

<<function Interactive.call_interactive>>=
let call_interactive frame =
  let buf = frame.frm_buffer in
  let interactives = buf_interactives buf in
  Select.select frame "M-x " meta_hist "" 
    (fun _ -> List.map fst interactives)
    (fun s -> s) 
    (exec_interactive interactives frame)
@

<<function Interactive.buf_interactives>>=
let buf_interactives buf =
  let interactives = 
    buf.buf_major_mode.maj_map.interactives @
    (Efuns.location()).loc_map.interactives 
  in
  List.fold_left (fun list minor -> minor.min_map.interactives @ list) 
   interactives buf.buf_minor_modes 
@


<<function Interactive.exec_interactive>>=
let exec_interactive interactives frame name =
  try
    let f, key = List.assoc name interactives in
    <<[[Interactive.exec_interactive()]] display if has a keybinding>>
    (* run it ! *)
    f frame
  with Not_found -> 
    let top_window = Window.top frame.frm_window in
    Top_window.message top_window ("No interactive command "^name)
@


<<[[Interactive.exec_interactive()]] display if has a keybinding>>=
(match key with
| None -> ()
| Some key_list ->
    let top_window = Window.top frame.frm_window in
    Top_window.message top_window
      ("you can run "^name^" by typing "^
        (Keymap.print_key_list key_list))
);
@


\subsection{Adding interactive functions}

%subsubsection{[[Map.interactives]]}

% in addition to char_map and complex_binding

<<[[Efuns.map]] other fields>>=
mutable interactives : (string * (action * prefix option)) list;
@
% record key so useful so can display the list of bindings?

<<type Efuns.prefix>>=
and prefix = key list
@

%\subsection{[[interactives_map]]}

<<constant Std_efunsrc.interactives_map>>=
let interactives_map = define_option ["interactives_map"] ""
    (list_option string2_option) 
  []
@

<<[[Std_efunsrc.toplevel]] set interactives_map>>=
if !!interactives_map = [] then begin
    interactives_map =:= List.map (fun x -> x, x ) [
      <<[[interactives_map]] initial entries>>
    ]
  end    
@


<<[[interactives_map]] initial entries>>=
"save_options";
(*"load_library";*)
"open_display";
"unset_attr";
(*"start_server";*)
@      
% a big ugly. An ocaml attribute would be better
% that then auto generate the list of interactive functions.

<<[[Std_efunsrc.init_global_map()]] add interactives from interactives_map>>=
!!interactives_map |> List.iter (fun (name, action) ->
  try
    Keymap.add_interactive (Efuns.location()).loc_map name 
      (execute_action action)
  with e ->
    Log.printf "Error for action %s" action;
    Log.exn "%s\n" e;
);
@

<<function Keymap.add_interactive>>=
let add_interactive map name f =
    map.interactives <- (name, (f, None)) :: map.interactives
@
%less: should look for duplicates

% so each global key and their associated func is accessible!
<<[[Keymap.interactive()]] add keylist and name to interactives list>>=
map.interactives <- (name, (f, Some keylist)) :: map.interactives;
@
%less: should look for duplicates


\subsection{Incremental mini buffer}
% for select (and so completion), for search, replace.
% each time ask input to user.


<<function Select.incremental_mini_buffer>>=
let incremental_mini_buffer 
 frame ismap request default incremental_action end_action =
  let top_window = Window.top frame.frm_window in
  let incremental mini_frame =
    incremental_action frame (Text.to_string mini_frame.frm_buffer.buf_text)
  in
  let incremental_insert mini_frame =
    Simple.self_insert_command mini_frame;
    incremental mini_frame
  in
  for key = 32 to 127 do
    Keymap.add_binding ismap [NormalMap, key] incremental_insert
  done;
  Keymap.add_binding ismap [NormalMap, XK.xk_BackSpace] (fun mini_frame -> 
    Simple.delete_backspace_char mini_frame;
    incremental mini_frame
  );
  top_window.top_second_cursor <- Some frame;
  Minibuffer.create_return frame ismap request default (fun frame str -> 
    top_window.top_second_cursor <- None;
    end_action frame str
  )
@




\chapter{Basic Features}

\section{Navigating}

<<navigating keys>>=
[NormalMap, XK.xk_Left], "move_backward"; 
[NormalMap, XK.xk_Right], "move_forward"; 
[ControlMap, Char.code 'b'], "move_backward";
[ControlMap, Char.code 'f'], "move_forward";

[ControlMap, XK.xk_Left ], "backward_word";
[ControlMap, XK.xk_Right ], "forward_word";  
[MetaMap, XK.xk_Left ], "backward_word";
[MetaMap, XK.xk_Right ], "forward_word";

[ControlMap, Char.code 'a'], "beginning_of_line";
[ControlMap, Char.code 'e'], "end_of_line";

[NormalMap, XK.xk_Up], "backward_line"; 
[NormalMap, XK.xk_Down], "forward_line"; 


[ControlMap, XK.xk_Up], "backward_paragraph";
[ControlMap, XK.xk_Down], "forward_paragraph";  

[NormalMap, XK.xk_Prior], "backward_screen"; 
[NormalMap, XK.xk_Next], "forward_screen";

[ControlMap, XK.xk_Next], "end_of_file";
[ControlMap, XK.xk_Prior], "begin_of_file";
@

\ifallcode
<<navigating keys>>=

(* pad: *)
[MetaMap, Char.code '>'], "end_of_file";
[MetaMap, Char.code '<'], "begin_of_file";
[MetaMap, Char.code 'g'], "goto_line";

[MetaMap, XK.xk_Up], "scroll_up"; 
[MetaMap, XK.xk_Down], "scroll_down"; 
[MetaMap, XK.xk_Left], "scroll_other_up"; 
[MetaMap, XK.xk_Right], "scroll_other_down"; 

@
\fi

<<navigating actions>>=
define_action "move_backward"  (fun frame -> ignore (Simple.move_backward frame 1));
define_action "move_forward"   (fun frame -> ignore (Simple.move_forward frame 1));

define_action "backward_word"  (Simple.to_frame Simple.backward_word);
define_action "forward_word"  (Simple.to_frame Simple.forward_word);  

define_action "beginning_of_line"  Simple.beginning_of_line;
define_action "end_of_line"  Simple.end_of_line;

define_action "backward_line"  Simple.backward_line;
define_action "forward_line"  Simple.forward_line;  

define_action "backward_paragraph"  (Simple.to_frame Simple.backward_paragraph);
define_action "forward_paragraph"  (Simple.to_frame Simple.forward_paragraph);  

define_action "backward_screen"  Simple.backward_screen;
define_action "forward_screen"  Simple.forward_screen;

define_action "begin_of_file"  Simple.begin_of_file;
define_action "end_of_file"  Simple.end_of_file;

(* M-x *)
define_action "goto_char" Complexe.goto_char;
define_action "goto_line" Complexe.goto_line;
@

<<[[interactives_map]] initial entries>>=
"goto_char";
"goto_line";
@

\subsection{Characters}

<<function Simple.move_backward>>=
let move_backward frame delta =
  Text.bmove frame.frm_buffer.buf_text frame.frm_point delta
@

<<function Simple.move_forward>>=
let move_forward frame delta =
  Text.fmove frame.frm_buffer.buf_text frame.frm_point delta
@
% Note that there is no mention of redisplay, or of adjusting
% the cursor. This is done automatically each time, based on
% the new value of frame.frm_point.


\subsection{Words and the syntax table}

%\section{Syntax table}
% was in core DS but better here I think

<<[[Efuns.buffer]] other fields>>=
mutable buf_syntax_table : bool array;
@

<<function Ebuffer.create_syntax_table>>=
let create_syntax_table ()  =
  let table = Array.create 256 false 
  in  
  for i = Char.code 'a' to Char.code 'z' do
    table.(i) <- true;
  done;
  for i = Char.code 'A' to Char.code 'Z' do
    table.(i) <- true;
  done;
  for i = Char.code '0' to Char.code '9' do
    table.(i) <- true;
  done;
  table
@

<<constant Ebuffer.default_syntax_table>>=
let default_syntax_table = create_syntax_table ()
@
% word consistuent? just a bool? emacs has more no?




<<function Simple.backward_word>>=
let backward_word buf point =
  let text = buf.buf_text in
  let syntax = buf.buf_syntax_table in
  in_prev_word text point syntax;
  to_begin_of_word text point syntax
@

<<function Simple.in_prev_word>>=
let in_prev_word text mark syntax =
  while Text.bmove_res text mark 1 = 1 &&
        (not syntax.(Char.code (Text.get_char text mark)))
  do () done
@

<<function Simple.to_begin_of_word>>=
let to_begin_of_word text mark syntax =
  if Text.bmove_res text mark 1 = 1 then
    begin
      while syntax.(Char.code (Text.get_char text mark)) &&
            (Text.bmove_res text mark 1) <> 0 
      do () done;
      if not syntax.(Char.code (Text.get_char text mark)) 
      then (Text.fmove text mark 1)
    end
@




<<function Simple.forward_word>>=
let forward_word buf point =
  let text = buf.buf_text in
  let syntax = buf.buf_syntax_table in
  in_next_word text point syntax;
  to_end_of_word text point syntax
@

<<function Simple.in_next_word>>=
let in_next_word text mark syntax =
  while (not syntax.(Char.code (Text.get_char text mark))) &&
        Text.fmove_res text mark 1 = 1 
  do () done
@

<<function Simple.to_end_of_word>>=
let to_end_of_word text mark syntax =
  while syntax.(Char.code (Text.get_char text mark)) &&
       (Text.fmove_res text mark 1) <> 0 
  do () done
@


% helpers for writing his own functions, e.g. C-s C-w uses that

<<function Simple.end_of_word>>=
let end_of_word  buf point =
  let text = buf.buf_text in
  let syntax = buf.buf_syntax_table in
  let mark = Text.dup_point text point in
  to_end_of_word text mark syntax;
  let s = Text.region text point mark in
  Text.remove_point text mark;
  s
@

<<function Simple.beginning_of_word>>=
let beginning_of_word buf point =
  let text = buf.buf_text in
  let syntax = buf.buf_syntax_table in
  let mark = Text.dup_point text point in
  to_begin_of_word text mark syntax;
  let s = Text.region text mark point in
  Text.remove_point text mark;
  s
@


\subsection{Lines}

<<function Simple.beginning_of_line>>=
let beginning_of_line frame =
  move_backward frame (begin_to_point frame) |> ignore
@
<<function Simple.begin_to_point>>=
let begin_to_point frame =
  Text.point_to_bol frame.frm_buffer.buf_text frame.frm_point
@


<<function Simple.end_of_line>>=
let end_of_line frame =
  move_forward frame (point_to_end frame) |> ignore
@
<<function Simple.point_to_end>>=
let point_to_end frame =
  Text.point_to_eol frame.frm_buffer.buf_text frame.frm_point
@



% mutually recursive because of goal_column()
<<function Simple.backward_line>>=
and backward_line frame =
  let text = frame.frm_buffer.buf_text in
  let point = frame.frm_point in
  if Text.point_line text point > 0 then begin
    let goal_col = goal_column frame in
    beginning_of_line frame;
    move_backward frame 1 |> ignore;
    move_to_goal_column frame goal_col;
  end
@
%old: was doing also some beginning_of_line when going up,
% end end_of_line when going down! I prefer
% to remain where I was column-wise
%old:
%    let old_x = begin_to_point frame in
%    beginning_of_line frame;
%    move_backward frame 1 |> ignore;
%    beginning_of_line frame;
%    move_forward  frame (min old_x (point_to_end frame)) |> ignore

<<function Simple.forward_line>>=
and forward_line frame =
  let text = frame.frm_buffer.buf_text in
  let point = frame.frm_point in
  if Text.point_line text point < Text.nbre_lines text then begin
    let goal_col = goal_column frame in
    end_of_line frame;
    move_forward frame 1 |> ignore;
    move_to_goal_column frame goal_col;
  end
@
%old:
%    if point_to_end frame = 0 then begin
%        move_forward frame 1 |> ignore;
%        end_of_line frame;
%    end else begin
%      let old_x = begin_to_point frame in
%      end_of_line frame;
%      move_forward frame 1 |> ignore;
%      move_forward frame (min old_x (point_to_end frame)) |> ignore



%\subsubsection{Goal column}
%pad: this was added by me! I get really confused
% when I don't have the exact look&feel of emacs!

%history:
% I struggled to implement that :):
% - I first added a type Bol | Col of int | Eol, but in fact
%   emacs does not do that, when you do eol and up, you don't
%   want to go to the eol, you want to remain at the same column.
% - Then I added a old_col_pos_max but it's tricky to get right
%   because other moving commands must reset it, but that means
%   ensuring an invariant at every places we use a move command.
% - In the end I had a look in microemacs and found the lastcmd
%   trick. In fact in emacs they uses that to and check if
%   the last command was a next-line or back-line. In fact
%   if you use M-x next-line instead of down you'll see that
%   the goal column is maintained only for the arrow keys, not
%   for the interactive version.

%emacs: 
% "It is the column where point was at the start of the current run
% of vertical motion commands."
<<constant Simple.temporary_goal_column>>=
let temporary_goal_column = 
  Local.create_abstr "Simple.temporary_goal_column"
@
% better than adding yet another field in the Buffer or Frame structure

<<function Simple.goal_column>>=
let rec goal_column frame =
  let cur_col = begin_to_point frame in
  if frame.frm_last_action == forward_line ||
     frame.frm_last_action == backward_line
  then 
    try Efuns.get_local frame.frm_buffer temporary_goal_column
    with Not_found -> cur_col
  else cur_col
@

<<function Simple.move_to_goal_column>>=
and move_to_goal_column frame goal_col =
  move_backward frame (begin_to_point frame) |> ignore;
  move_forward frame (min goal_col (point_to_end frame)) |> ignore;
  Efuns.set_local frame.frm_buffer temporary_goal_column goal_col
@


\subsection{Paragraphs}

<<function Simple.backward_paragraph>>=
let backward_paragraph buf point =
  let text = buf.buf_text in
  while Text.bmove_res text point 1 = 1 && 
        (let c = Text.get_char text point in c = '\n' || c = ' ')
  do () done;
  try
    Text.search_backward text (Str.regexp "\n *\n") point |> ignore;
    Text.fmove text point 1
  with Not_found -> Text.set_position text point 0
@

<<function Simple.forward_paragraph>>=
let forward_paragraph buf point =
  let text = buf.buf_text in
  while (let c = Text.get_char text point in c = '\n' || c = ' ') &&
         Text.fmove_res text point 1 = 1 
  do () done;
  try
    Text.search_forward text (Str.regexp "\n *\n") point |> ignore;
    Text.fmove text point 1
  with Not_found -> Text.set_position text point (Text.size text)
@

\subsection{Screens}

<<function Simple.backward_screen>>=
let backward_screen frame =
  frame.frm_force_start <- true;
  frame.frm_redraw <- true;
  frame.frm_y_offset <- frame.frm_y_offset - frame.frm_height + 2
@
%less: seems redundant a bit frm_force_start and frm_redraw no?

<<function Simple.forward_screen>>=
let forward_screen frame =
  frame.frm_force_start <- true;
  frame.frm_redraw <- true;
  frame.frm_y_offset <- frame.frm_y_offset + frame.frm_height - 2
@

\subsection{File}

<<function Simple.begin_of_file>>=
let begin_of_file frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  Text.set_position text frame.frm_point 0
@

<<function Simple.end_of_file>>=
let end_of_file frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  Text.set_position text frame.frm_point (Text.size text)
@


\subsection{Position}

<<function Complex.goto_char>>=
let goto_char frame =
  Select.simple_select frame "goto-char:" (fun name ->
    let char = int_of_string name in
    Text.set_position frame.frm_buffer.buf_text frame.frm_point char
  )
@

<<function Complex.goto_line>>=
let goto_line frame =
  Select.simple_select frame "goto-line:" (fun name ->
    let line = int_of_string name in
    Text.goto_line frame.frm_buffer.buf_text frame.frm_point (line - 1)
  )
@

<<function Text.goto_line>>=
let goto_line tree point y =
  let text = tree.tree_text in      
  if text.text_nlines - 1 <= y 
  then set_position tree point (size tree)
  else begin
    let line = text.text_newlines.(y) in
    point.pos <- line.position;
    point.line <- y
  end
@



%\subsection{Helpers}

<<function Text.point_to_eol>>=
let point_to_eol tree point =
  let text = tree.tree_text in    
  low_distance text point.pos
    (text.text_newlines.(point.line + 1).position - 1)
@

<<function Text.point_to_bol>>=
let point_to_bol tree point =
  let text = tree.tree_text in    
  low_distance text 
    text.text_newlines.(point.line).position
    point.pos
@

<<function Text.point_to_eof>>=
let point_to_eof tree point =
  let text = tree.tree_text in    
  low_distance text point.pos text.text_size
@

<<function Text.point_to_bof>>=
let point_to_bof tree point =
  let text = tree.tree_text in    
  low_distance text 0 point.pos
@




<<function Text.point_to_lof>>=
let point_to_lof text point n =
  if n > 0 
  then point_to_eof text point
  else point_to_bof text point
@

<<function Text.point_to_lol>>=
let point_to_lol text point n =
  if n > 0 
  then point_to_eol text point
  else point_to_bol text point
@

<<function Text.point_to_line>>=
let point_to_line tree point line =
  let text = tree.tree_text in    
  let pos = 
    if text.text_nlines <= line + 1 
    then text.text_size
    else text.text_newlines.(line).position
  in
  move_point_to tree point pos
@




\section{Inserting}

<<inserting keys>>=
[NormalMap, XK.xk_Return], "insert_return"; 
@
<<inserting actions>>=
define_action "insert_return"  Simple.insert_return;
@

<<function Simple.insert_return>>=
let insert_return frame =
  insert_char frame '\n'
@


<<constant Simple.single_char>>=
let single_char = String.make 1 ' '
@
% thread-safe?

<<function Simple.insert_char>>=
let insert_char frame char =
  let text = frame.frm_buffer.buf_text in
  let point = frame.frm_point in
  single_char.[0] <- char;
  Text.insert text point single_char |> ignore;
  Text.fmove text point 1 |> ignore
@




<<function Text.insert>>=
let insert text point str = 
   insert_res text point str |> ignore
@
<<function Text.insert_res>>=
let insert_res tree point str =
  let text = tree.tree_text in
  let (pos,len,modif) = low_insert tree point.pos str in
  text.text_history <- Insertion(pos,len,modif) :: text.text_history;
  text.text_modified <- text.text_modified + 1;
  pos, len
@

% Insertion! For undo!



<<function Simple.self_insert_command>>=
let self_insert_command frame =
  let char = Char.chr !Top_window.keypressed in
  let buf = frame.frm_buffer in
  if Ebuffer.modep buf overwrite_mode 
  then insert_at_place frame char
  else insert_char frame char
@

\section{Deleting}

<<deleting keys>>=
[NormalMap, XK.xk_BackSpace], "delete_before_point"; 
[ControlMap, Char.code 'd'], "delete_at_point";
[NormalMap, XK.xk_Delete], "delete_at_point"; 

[MetaMap, Char.code 'd' ], "delete_forward_word";
[MetaMap, XK.xk_BackSpace ], "delete_backward_word";

[ControlMap, XK.xk_BackSpace], "hungry_electric_delete";
[ControlMap, Char.code 'k'], "kill_end_of_line";
@

<<deleting actions>>=
define_action "delete_before_point"  Simple.delete_backspace_char;
define_action "delete_at_point"  Simple.delete_char;

define_action "delete_forward_word"  (Simple.to_frame Simple.delete_forward_word);
define_action "delete_backward_word"  (Simple.to_frame Simple.delete_backward_word);

define_action "hungry_electric_delete"  Simple.hungry_electric_delete;
define_action "kill_end_of_line"  Simple.kill_end_of_line;
@

\subsection{Characters}

<<function Simple.delete_backspace_char>>=
let delete_backspace_char frame =
  let text = frame.frm_buffer.buf_text in
  if Text.bmove_res text frame.frm_point 1 <> 0 
  then Text.delete text frame.frm_point 1 |> ignore
@

<<function Simple.delete_char>>=
let delete_char frame =
  let text = frame.frm_buffer.buf_text in
  Text.delete text frame.frm_point 1 |> ignore
@

<<function Text.delete>>=
let delete text point len = 
  delete_res text point len |> ignore
@
<<function Text.delete_res>>=
let delete_res tree point len =
  let text = tree.tree_text in  
  let (pos,str,modif) = low_delete tree point.pos len in
  text.text_history <- Deletion(pos,str,modif) :: text.text_history;
  text.text_modified <- text.text_modified + 1;
  pos, str
@

% Deletion! For undo


\subsection{Words}

<<function Simple.delete_backward_word>>=
let delete_backward_word buf point =
  let text = buf.buf_text in
  let old_point = Text.dup_point text point in
  backward_word buf point;
  Text.delete text point (Text.distance text point old_point) |> ignore;
  Text.remove_point text old_point
@

<<function Simple.delete_forward_word>>=
let delete_forward_word buf point =
  let text = buf.buf_text in
  let old_point = Text.dup_point text point in
  forward_word buf point;
  let len = Text.distance text old_point point in
  Text.remove_point text old_point;
  Text.bmove text point len;
  Text.delete text point len |> ignore
@

\subsection{Lines}

<<function Simple.kill_end_of_line>>=
let kill_end_of_line frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let eol = point_to_end frame in
  let len = if eol = 0 then 1 else eol in
  kill_text text frame.frm_point len
@

%\subsection{XXX}

<<function Simple.hungry_char>>=
let hungry_char c = 
  c = ' ' || c = '\n' || c = '\t'
@

<<function Simple.hungry_electric_delete>>=
let hungry_electric_delete frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let session = Text.start_session text in
  let c1 = previous_char frame in
  delete_backspace_char frame;
  let c2 = previous_char frame in
  begin
    if hungry_char c1 && hungry_char c2 then
      try
        delete_backspace_char frame;
        while 
          let c = previous_char frame in
          hungry_char c        
        do
          delete_backspace_char frame
        done;
        insert_char frame ' '
      with
        Not_found -> ()
  end;
  Text.commit_session text session
@


\section{Moving}

<<moving keys>>=
[ControlMap, Char.code ' '], "mark_at_point";
[ControlMap, Char.code 'w'], "kill_region";
[ControlMap, Char.code 'y'], "insert_killed";
[MetaMap, Char.code 'y'], "insert_next_killed";
@

<<moving actions>>=
define_action "mark_at_point"  Complexe.mark_at_point;
define_action "kill_region"  Simple.kill_region;
define_action "insert_killed"  Simple.insert_killed;
define_action "insert_next_killed"  Simple.insert_next_killed;
@

\subsection{Mark}

<<function Complex.mark_at_point>>=
let mark_at_point frame =
  Ebuffer.set_mark frame.frm_buffer frame.frm_point;
  let top_window = Window.top frame.frm_window in
  Top_window.message top_window "Mark set";
  ()
@

<<[[Efuns.buffer]] other fields>>=
mutable buf_mark : Text.point option;
@

<<function Ebuffer.set_mark>>=
let set_mark buf point =
  let text = buf.buf_text in
  buf.buf_modified <- buf.buf_modified + 1;
  match buf.buf_mark with
    None ->
      let mark = Text.dup_point text point in
      buf.buf_mark <- Some mark
  | Some mark ->
      Text.goto_point text mark point
@




<<function Ebuffer.get_mark>>=
let rec get_mark buf point =
  match buf.buf_mark with
    None -> 
      set_mark buf point;
      get_mark buf point
  | Some mark -> mark
@

<<function Ebuffer.remove_mark>>=
let remove_mark buf =
  match buf.buf_mark with
    None -> ()
  | Some mark ->
      buf.buf_mark <- None;
      Text.remove_point buf.buf_text mark;
      buf.buf_modified <- buf.buf_modified + 1
@


% can actually also navigate with the mark


\subsection{Highlight}
%less: mv in colors section?

%less: when done via mouse?
%todo: could be done also in cua mode

%todo: use also for C-s?

\subsection{Cut}

<<function Simple.kill_region>>=
let kill_region frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let mark =
    match buf.buf_mark with
      None -> failwith "No mark set"
    | Some mark -> mark
  in
  let (start,term) = 
    if mark > point then (point,mark) else (mark,point)
  in
  let _,region = Text.delete_res text start (Text.distance text start term) in
  kill_string region
@

\subsection{Copy}
% M-w?

\subsection{Paste}

<<constant Simple.kill_ring>>=
let kill_ring = Array.create kill_max ""
@

<<function Simple.insert_killed>>=
let insert_killed frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let pos, len =  Text.insert_res text point kill_ring.(0) in
  Text.fmove text point len; 
  last_insert := Some(frame,pos,0,len)
@

<<constant Simple.last_insert>>=
let last_insert = ref None
@

% M-y
<<function Simple.insert_next_killed>>=
let insert_next_killed frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  match !last_insert with
  |  Some (oldframe,oldpoint,n,len) when 
    oldframe == frame && oldpoint + len = Text.get_position text point ->
      let n = if n = (min !kill_size kill_max) - 1 then 0 else n+1 in
      Text.bmove text point len;
      Text.delete text point len |> ignore;
      let pos, len =  Text.insert_res text point kill_ring.(n) in
      Text.fmove text point len;
      last_insert := Some(frame,pos,n,len)
  | _ -> ()
@

%subsection{CUA mode}?

\subsection{Mark navigation}

<<misc actions>>=
(* C-x map *)
define_action "point_at_mark"  Simple.point_at_mark;
@

<<misc keys>>=
[c_x; ControlMap, Char.code 'x'], "point_at_mark";
@
% I use C-u C-space for that? but I have a history of mark no?

<<function Simple.point_at_mark>>=
let point_at_mark frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in

  let mark = Ebuffer.get_mark buf point in
  let pos = Text.get_position text point in
  Text.goto_point text point mark;
  Text.set_position text mark pos
@

\section{Undo}

<<undoing keys>>=
[ControlMap, Char.code '_'], "undo";
@
<<undoing actions>>=
define_action "undo"  Simple.undo;
@

\ifallcode
<<undoing keys>>=
(* pad: *)
[ControlMap, Char.code '/'], "undo";
@
\fi


<<function Simple.undo>>=
let undo frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in  
  let point = frame.frm_point in
  let action, at_point, len = Text.undo text in
  frame.frm_last_text_updated <- Text.version text - 1;
  Text.set_position text point at_point;
  Text.fmove text point len
@


%\subsection{Helpers}


<<type Text.action>>=
and action =
  Insertion of int * int * int
| Deletion of int * string * int
<<[[Text.action]] other cases>>
@
% who generates that? the very low-level basic text operations!
% we rely on that! otherwise undo complicated.

<<function Text.undo>>=
let undo tree =
  let text = tree.tree_text in  
  let rec undo action =
    let gpos = text.gpoint.pos in
    let gsize = text.gsize in
    match action with
    | Insertion(point_pos, len, modified) ->
        let point = if gpos < point_pos then point_pos + gsize else point_pos in
        let (pos,str,modif) = low_delete tree point len in
        text.text_modified <- modified;
        Deletion(pos,str,modif), point_pos, 0
    | Deletion (point_pos, str, modified) ->
        let point = if gpos < point_pos then point_pos + gsize else point_pos in
        let (pos,len,modif) = low_insert tree point str in
        text.text_modified <- modified;
        Insertion(pos,len,modif), point_pos, String.length str
    <<[[Text.undo()]] match action cases>>
  in
  match text.text_history with
    [] -> raise Not_found
  | action :: tail -> 
      let rev_action = undo action in
      text.text_history <- tail;
      rev_action
@

<<[[Text.text]] history fields>>=
mutable text_history : action list;
@



<<[[Text.action]] other cases>>=
| Session of action list
@

<<type Text.session>>=
type session = int
@
% used in .mly

<<[[Text.undo()]] match action cases>>=
| Session actions ->
    let last_point = ref 0 in
    let last_len = ref 0 in
    let rev_actions =
      List.fold_left (fun undos action -> 
          let (rev_action,point,len) = undo action in
          last_point := point;
          last_len := len;
          rev_action :: undos
      ) [] actions
    in
    Session rev_actions, !last_point, !last_len
@


<<function Text.commit_session>>=
let commit_session tree session_date =
  let text = tree.tree_text in      
  if text.text_modified > session_date then
    let rec iter session history =
      match history with
        [] -> assert false
      | action :: history ->
          let date =
            match action with
              Session _ -> failwith "Can not commit nested sessions"
            | Insertion (_,_,date) -> date
            | Deletion (_,_,date) -> date
          in
          if date = session_date then
            text.text_history <- (Session (List.rev (action::session)))
            :: history
          else
            iter (action::session) history
    in
    iter [] text.text_history
@

\chapter{Search and Replace}

\section{Searching}

%later: do like in firefox, display in scrollbar
% the matched places

<<searching keys>>=
[ControlMap, Char.code 's'], "isearch_forward";
[ControlMap, Char.code 'r'], "isearch_backward";
[MetaMap, Char.code 's'], "isearch_forward_regexp";
[MetaMap, Char.code 'r'], "isearch_backward_regexp";
@

<<searching actions>>=
define_action "isearch_forward"  Search.isearch_forward;
define_action "isearch_backward"  Search.isearch_backward;
define_action "isearch_forward_regexp"  Search.isearch_forward_regexp;
define_action "isearch_backward_regexp"  Search.isearch_backward_regexp;
@

<<type Efuns.sens>>=
type sens = 
| Backward
| Forward
@

\subsection{Strings}

<<constant Search.isearch_forward>>=
let isearch_forward = isearch RegexpString Forward
@
<<constant Search.isearch_backward>>=
let isearch_backward = isearch RegexpString Backward
@

\subsection{Regexps}

<<constant Search.isearch_forward_regexp>>=
let isearch_forward_regexp = isearch Regexp Forward
@
<<constant Search.isearch_backward_regexp>>=
let isearch_backward_regexp = isearch Regexp Backward 
@

\subsection{Search mini frame }

% use incremental_mini_buffer function

\subsection{Secondary cursor}

<<[[Efuns.top_window]] other fields>>=
mutable top_second_cursor : frame option;
@

\subsection{Helpers}

<<constant Search.last_search>>=
let last_search = ref ""
@

% should be a buffer setting
<<constant Search.case_fold>>=
(* todo: this should be a buffer variable, not a global *)
let case_fold = ref false
@

<<function Search.isearch>>=
let isearch to_regexp sens frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let ismap = Keymap.create () in

  let point = frame.frm_point in
  let spoint = Text.dup_point text point in
  let orig = Text.get_position text point in

  let sens = ref sens in
  let to_regexp = ref to_regexp in

  let request () =
    "isearch-"^
      (match !sens with
        Backward -> "backward"
      | Forward -> "forward"
    )^
      (match !to_regexp with
        Regexp -> "-regexp :"
      | RegexpString -> " :"
    )
  in

  let string = ref "" in
  let isearch_s () =
    last_search := !string;
    let regexp, delta =
      match !to_regexp, !case_fold with
      | Regexp, true  -> Str.regexp_case_fold !string, 0
      | Regexp, false -> Str.regexp !string, 0
      | RegexpString, true -> Str.regexp_string_case_fold !string, String.length !string
      | RegexpString, false -> Str.regexp_string !string, String.length !string
    in  
    Text.goto_point text point spoint;
    match !sens with
    | Backward -> Text.search_backward text regexp point |> ignore
    | Forward ->  
        let len = Text.search_forward text regexp point in
     (* Printf.printf  "Found at %d len %d" (Text.get_position text point) len;
        print_newline ();*)
        Text.fmove text point len |> ignore
  in
  let set_last mini_frame =
    if !string = "" then begin
      let buf = mini_frame.frm_buffer in
      let text = buf.buf_text in
      let point = mini_frame.frm_point in
      Text.insert text point !last_search;
      Text.fmove text point (String.length !last_search);
      string := !last_search
    end
  in

  <<[[Search.isearch()]] key bindings>>
@



<<[[Search.isearch()]] key bindings>>=
Keymap.add_binding ismap [ControlMap, Char.code 's'] 
  (fun mini_frame ->
    set_last mini_frame;      
    Text.goto_point text spoint point;
    sens := Forward;
    isearch_s ();
    Minibuffer.update_request mini_frame (request ())
);    
Keymap.add_binding ismap [ControlMap, Char.code 'r']
  (fun mini_frame ->
    set_last mini_frame;      
    Text.goto_point text spoint point;
    sens := Backward;
    isearch_s ();
    Minibuffer.update_request mini_frame (request ())
);  

Keymap.add_binding ismap [ControlMap, Char.code 'w']
  (fun mini_frame ->
    (*      set_last mini_frame;       *)
    Text.goto_point text spoint point;
    let end_current_word = Simple.end_of_word buf point in
    string := !string ^ end_current_word;
    Simple.insert_string mini_frame end_current_word;
    isearch_s ();
    Minibuffer.update_request mini_frame (request ())
  );

let _mini_frame =
  Select.incremental_mini_buffer frame ismap (request ()) !string
    (fun frame str -> 
      string := str;
      isearch_s ()
  )
  (fun frame str -> 
      last_search := str;
      Text.remove_point text spoint
  )
in
let kill_and f mini_frame =
  last_search := Text.to_string mini_frame.frm_buffer.buf_text;
  Minibuffer.kill mini_frame frame;
  f frame
in
Keymap.add_binding ismap [ControlMap, Char.code 'g']
  (fun mini_frame  ->
    Minibuffer.kill mini_frame frame;
    Text.set_position frame.frm_buffer.buf_text frame.frm_point orig
);
Keymap.add_binding ismap [NormalMap, XK.xk_Left]
  (fun mini_frame  ->
    Minibuffer.kill mini_frame frame;
    Simple.move_backward frame 1 |> ignore
   );  
Keymap.add_binding ismap [NormalMap, XK.xk_Right]
  (fun mini_frame  ->
    Minibuffer.kill mini_frame frame;
    Simple.move_forward frame 1 |> ignore
  );  
Keymap.add_binding ismap [NormalMap, XK.xk_Down] (kill_and Simple.forward_line);
Keymap.add_binding ismap [NormalMap, XK.xk_Up] (kill_and Simple.backward_line);
Keymap.add_binding ismap [ControlMap, Char.code 'a'] 
  (kill_and Simple.beginning_of_line);
Keymap.add_binding ismap [ControlMap, Char.code 'e'] 
  (kill_and Simple.end_of_line)
@


<<function Text.search_forward>>=
let search_forward tree regexp point =
  let text = tree.tree_text in    
  let gsize = text.gsize in
  let gap_end = text.gpoint.pos + gsize in
  if point.pos = text.gpoint.pos 
  then point.pos <- gap_end;
  if point.pos < gap_end 
  then clean_text text;
  let gap_end = text.gpoint.pos + gsize in  
  let string = text.text_string in
  let pos = Str.search_forward regexp string point.pos in
  let pos = if pos >= gap_end then pos - gsize else pos in
  set_position tree point pos;
  Str.match_end () - Str.match_beginning ()
@


<<function Text.search_forward_matched>>=
let search_forward_matched tree regexp point =
  let text = tree.tree_text in      
  let gsize = text.gsize in
  let gap_end = text.gpoint.pos + gsize in
  if point.pos = text.gpoint.pos 
  then point.pos <- gap_end;
  if point.pos < gap_end 
  then clean_text text;
  let string = text.text_string in
  let pos = Str.search_forward regexp string point.pos in
  let pos = 
    if pos >= text.gpoint.pos + gsize 
    then pos - gsize 
    else pos 
  in
  set_position tree point pos;
  Str.matched_string string
@

<<function Text.search_forward_groups>>=
let search_forward_groups tree regexp point groups =
  let text = tree.tree_text in      
  let gsize = text.gsize in
  let gap_end = text.gpoint.pos + gsize in
  if point.pos = text.gpoint.pos 
  then point.pos <- gap_end;
  if point.pos < gap_end 
  then clean_text text;
  let gap_end = text.gpoint.pos + gsize in  
  let string = text.text_string in
  let pos = Str.search_forward regexp string point.pos in
  let pos = if pos >= gap_end then pos - gsize else pos in
  let array = Array.init groups (fun i -> Str.matched_group (i+1) string) in
  set_position tree point pos;
  array
@

<<function Text.search_backward>>=
let search_backward tree regexp point =
  let text = tree.tree_text in    
  if point.pos > text.gpoint.pos 
  then clean_text text;
  let string = text.text_string in
  let start_pos =     
    if point.pos > 0 
    then point.pos - 1 
    else raise Not_found 
  in
  let pos =  Str.search_backward regexp string start_pos in
  set_position tree point pos;
  Str.match_end () - Str.match_beginning ()
@

<<function Text.search_backward_groups>>=
let search_backward_groups tree regexp point groups =  
  let text = tree.tree_text in    
  if point.pos > text.gpoint.pos 
  then clean_text text;
  let string = text.text_string in
  let start_pos =     
    if point.pos > 0 
    then point.pos - 1 
    else raise Not_found  
  in
  let pos =  Str.search_backward regexp string start_pos in
  let array = Array.init groups (fun i -> Str.matched_group (i+1) string) in
  set_position tree point pos;
  array
@



\section{Replacing}

<<replacing keys>>=
[MetaMap, Char.code '%'], "query_replace_string";
@

<<replacing actions>>=
define_action "replace_string" Search.replace_string;
define_action "replace_regexp" Search.replace_regexp;
define_action "query_replace_string" Search.query_replace_string;
define_action "query_replace_regexp" Search.query_replace_regexp;
@

<<[[interactives_map]] initial entries>>=
"replace_string";
"replace_regexp";
"query_replace_string";
"query_replace_regexp";
@


%\section{Regexps}
% mv later?

<<type Efuns.to_regexp>>=
type to_regexp =
  Regexp
| RegexpString
@

<<function Efuns.string_to_regex>>=
let string_to_regex s = s, Str.regexp s
@


<<constant Efuns.regexp_option>>=
let regexp_option = define_option_class "Regexp" 
    (fun v -> match v with
        Value s ->  string_to_regex s | _ -> raise Not_found)
  (fun (s,_r) -> Value s)
@
% where need that? for c_error_regexp config file

\subsection{Strings}

<<function Search.replace_string>>=
let replace_string frame =
  select_replace frame "Replace string: " (fun str ->
  select_replace frame "with string: "    (fun str2 ->
    replace RegexpString frame NoQuery str str2
  ))
@

<<function Search.query_replace_string>>=
let query_replace_string frame =
  select_replace frame "Replace string: " (fun str ->
  select_replace frame "with string: "    (fun str2 ->
    replace RegexpString frame (Query ( frame, "Replace string ? (y/n)"))
        str str2
  ))
@

\subsection{Regexps}

<<function Search.replace_regexp>>=
let replace_regexp frame =
  select_replace frame "Replace Regexp: " (fun str ->
  select_replace frame "with string: " (fun str2 ->
    replace Regexp frame NoQuery str str2
  ))
@

<<function Search.query_replace_regexp>>=
let query_replace_regexp frame =
  select_replace frame "Replace regexp: " (fun str ->
  select_replace frame "with string: "    (fun str2 ->
    replace Regexp frame (Query (frame, "Replace regexp ? (y/n)")) str str2
  ))
@

\subsection{Helpers}

<<function Text.replace_matched>>=
let replace_matched tree repl =
  let text = tree.tree_text in    
  Str2.replace_matched repl text.text_string
@


<<function Search.select_replace>>=
let select_replace frame request action =
  Select.select_string frame request string_history "" action 
@



<<function Search.replace>>=
let replace flag frame query str repl =
  let top_window = Window.top frame.frm_window in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let regexp = to_regexp flag str in
  let session = Text.start_session text in
  let n = ref 0 in
  try
    let last_pos = ref (Text.get_position text point) in
    match flag,query with
      Regexp, NoQuery ->
        while not (Top_window.check_abort frame) do
          let len = Text.search_forward text regexp point in
          let pos = Text.get_position text point in
          if pos = !last_pos then 
            (if Text.fmove_res text point 1 = 0 then raise Exit)
          else begin
              last_pos := pos;
              let result = Text.replace_matched text repl in
              let (_,_matched) = Text.delete_res text point len in
              Text.insert text point result;
              Text.fmove text point (String.length result);
              n := !n + 1
            end
        done
    | RegexpString, NoQuery ->
        let delta = String.length repl in
        while not (Top_window.check_abort frame) do
          let len = Text.search_forward text regexp point in
          let pos = Text.get_position text point in
          if pos = !last_pos then 
            (if Text.fmove_res text point 1 = 0 then raise Exit)
          else begin
              last_pos := pos;
              Text.delete text point len;
              Text.insert text point repl;
              Text.fmove text point delta;
              n := !n + 1
            end
        done
    | Regexp, Query (frame,request) ->
        let top_window = Window.top frame.frm_window in
        let rec iter () =
          let len = Text.search_forward text regexp point in
          let pos = Text.get_position text point in
          if pos = !last_pos then begin
              (if Text.fmove_res text point 1 = 0 then raise Exit);
              iter ();
            end
          else begin
              last_pos := pos;
              top_window.top_second_cursor <- Some frame;
              let _ = Select.select_yes_or_no frame request 
                  (fun yes ->
                    if yes then
                      begin
                        let result = Text.replace_matched text repl in
                        let (_,_matched) = Text.delete_res text point len in
                        Text.insert text point result;
                        Text.fmove text point (String.length result);
                        n := !n + 1
                      end;
                    iter ()) in
              ()
            end
        in
        iter ()
    | RegexpString, Query (frame,request) ->
        let delta = String.length repl in
        let top_window = Window.top frame.frm_window in
        let rec iter () =
          let len = Text.search_forward text regexp point in
          let pos = Text.get_position text point in
          if pos = !last_pos then begin
              (if Text.fmove_res text point 1 = 0 then raise Exit);
              iter ();
            end
          else begin
              last_pos := pos;
              top_window.top_second_cursor <- Some frame;
              let _ = Select.select_yes_or_no frame request 
                  (fun yes ->
                    if yes then
                      begin
                        Text.delete text point len;
                        Text.insert text point repl;
                        Text.fmove text point delta;
                        n := !n + 1
                      end;
                    iter ()) 
              in
              ()
            end
        in
        iter ()
  with 
  | Not_found ->
      Text.commit_session text session;
      Top_window.message top_window
        ("Replace "^(string_of_int !n)^" occurences")
  | _ ->
      Text.commit_session text session
@


\chapter{Multi-Buffers}

% will present 4 different ways to switch buffers:
%  - menu
%  - C-x b interactive
%  - C-x k to kill the current buffer (which in effect switch to next one)
%  - cycling


\section{Buffer names}

% can have ambiguity?
% no buf_name should be unique, so using it as a key to
% pass to change_buffer() should be enough
% (after all it's used as a key in location.loc_buffers)

% Ebuffer.create -> <>
<<function Ebuffer.get_name>>=
let get_name filename =
  let basename = Filename.basename filename in
  let name = 
    if basename = "" 
    then (Filename.basename (Filename.dirname filename)) ^ "/"
    else basename
  in
  let i = ref 0 in
  let compute_name () =
    if !i = 0 
    then name 
    else Printf.sprintf "%s<%d>" name !i
  in
  try
    while true do
      let _ = Hashtbl.find (Efuns.location()).loc_buffers (compute_name ()) in 
      incr i
    done; 
    assert false
  with Not_found -> 
    compute_name ()
@


\section{Buffers menu}

<<[[Std_efunsrc]] buffers menu setup>>=
Top_window.buffers_menu := (fun top_window button () ->
    let buffers = ref [] in
    let loc = Efuns.location() in
    Hashtbl.iter (fun name _buf -> buffers := name :: !buffers) loc.loc_buffers;
    let _desc = Array.map (fun name -> 
          (name, Top_window.wrap top_window (fun top_window ->
                let frame = top_window.top_active_frame in
                let window = frame.frm_window in
                Frame.change_buffer window name
            )))
      (Array.of_list !buffers) in

    (* X11 *)
    (*
    let menu = new WX_popup.t top_window.top_root desc in
    let (x,y) = button#root_coordinates in
    menu#popup_once x (y + button#height) (Some !WX_types.button_event)
    *)
    failwith "Std_menu: show menus TODO"
    )
@

\section{Changing the buffer}

%\section{Navigation}

<<buffer managment keys>>=
[c_x; NormalMap, Char.code 'b'], "change_buffer";
@
<<buffer managment actions>>=
(* C-x map *)
define_action "change_buffer"  Complexe.change_buffer;
@


<<function Complex.change_buffer>>=
let change_buffer frame =
  let default = Select.get_previous_frame () in
  Select.set_previous_frame frame;
  Select.select_buffer frame " Switch to buffer: " default (fun str ->
    Frame.change_buffer frame.frm_window str
  )
@

<<function Frame.change_buffer>>=
let change_buffer window name = 
  try
    let buf = Hashtbl.find (Efuns.location()).loc_buffers name in
    let frame = create window None buf in
    exec_named_hooks !!change_buffer_hooks frame;
    status_name frame buf.buf_name
  with Not_found -> ()
@


% set_previous_frame is also used in load_buffer, each time
% is close to switch to another buffer in the current frame.


\section{Killing the buffer}

<<file menu entries>>=
"Kill Buffer", "kill_buffer";
@

<<buffer managment keys>>=
[c_x; NormalMap, Char.code 'k'], "kill_buffer";
@
<<buffer managment actions>>=
(* C-x map *)
define_action "kill_buffer"  Simple.kill_buffer;
@

<<function Simple.kill_buffer>>=
let kill_buffer frame =
  let window = frame.frm_window in
  let buf = frame.frm_buffer in
  let new_buf = next_buffer buf in
  let _new_frame = Frame.create window None new_buf in
  if buf.buf_shared = 0 
  then Ebuffer.kill buf
@


<<function Ebuffer.kill>>=
let kill buf =
  let location = Efuns.location() in
  Hashtbl.remove location.loc_buffers buf.buf_name;
  buf.buf_filename |> Common.do_option (fun filename ->
    Hashtbl.remove location.loc_files filename
  );
  List.iter (fun f -> f () ) buf.buf_finalizers;
  Gc.compact ();
  buf.buf_shared <- -1
@



\section{Cycling buffers}
% of frame?

% lefessant specific?

<<buffer navigating keys>>=
(* lefessant?: *)
[ControlMetaMap, XK.xk_Left], "left_buffer";
[ControlMetaMap, XK.xk_Right], "right_buffer";
[ControlMetaMap, XK.xk_Down], "down_buffer";
[ControlMetaMap, XK.xk_Up], "up_buffer";
@

<<buffer navigating actions>>=
(* C-M map *)
define_action "left_buffer"  Multi_buffers.left_buffer;
(* C-M map *)
define_action "right_buffer"  Multi_buffers.right_buffer;
(* C-M map *)
define_action "down_buffer"  Multi_buffers.down_buffer;
(* C-M map *)
define_action "up_buffer"  Multi_buffers.up_buffer;
@


<<constant Select.prev_buffers>>=
let prev_buffers = ref []
@

<<function Complex.left_buffer>>=
let left_buffer frame =
  Select.set_previous_frame frame;
  Frame.change_buffer frame.frm_window 
    (match !Select.prev_buffers with
    | name :: buffer :: tail ->
        Select.prev_buffers := tail @ [name]; 
        buffer
    | _ -> raise Not_found
    )
@

<<function Complex.right_buffer>>=
let right_buffer frame =
  Select.set_previous_frame frame;
  Frame.change_buffer frame.frm_window 
    (match !Select.prev_buffers with
    | name :: tail ->
        (match List.rev tail with
        | buffer :: tail ->
            Select.prev_buffers := name :: (List.rev tail);
            buffer
        | _ -> raise Not_found
        )
    | _ -> raise Not_found
    )
@


<<function Select.set_previous_frame>>=
let set_previous_frame frame = 
  let name = frame.frm_buffer.buf_name in
  next_default := name;
  prev_buffers := name :: (Utils.list_removeq !prev_buffers name)
@


<<constant Complex.up_buffer>>=
let up_buffer = ref ""
@

<<function Complex.down_buffer>>=
let down_buffer frame = 
  up_buffer := frame.frm_buffer.buf_name
@

<<function Complex.up_buffer>>=
let up_buffer frame =
  if !up_buffer = "" 
  then raise Not_found;
  Select.set_previous_frame frame;
  Frame.change_buffer frame.frm_window !up_buffer
@

\chapter{Multi-Windows/Frames}

% recall window_down type!

% rendering:
% Top_window.update_display -> <> -> Frame.display
<<function Window.iter>>=
let iter f window = 
  let rec iter1 window =
    match window.win_down with
    | HComb (w1,w2) -> iter1 w1; iter1 w2       
    | VComb (w1,w2) -> iter1 w1; iter1 w2
    | WFrame frame -> f frame
    | NoFrame _ -> ()
  in
  iter1 window
@

% the active window??

\section{Creating sub windows}

<<[[edit_menu]] entries>>=
"Cut Frame", "vertical_cut_frame";
@

<<frame managment keys>>=
[c_x; NormalMap, Char.code '2'], "vertical_cut_frame";    
[c_x; NormalMap, Char.code '3'], "horizontal_cut_frame";    
@

<<frame managment actions>>=
(* C-x map *)
define_action "vertical_cut_frame"  Multi_frames.v_cut_frame;    
(* C-x map *)
define_action "horizontal_cut_frame"  Multi_frames.h_cut_frame;    
@

<<function Multi_frames.v_cut_frame>>=
let v_cut_frame frame =
  if frame.frm_mini_buffer = None 
  then Frame.create (cut_frame frame) None frame.frm_buffer |> ignore
@

<<function Multi_frames.h_cut_frame>>=
let h_cut_frame frame =
  if frame.frm_mini_buffer = None 
  then
    let window = frame.frm_window in
    if window.win_width > 10 then begin
      let wi = window.win_width / 2 in
      let w1 = Window.create false
                 (Window window) window.win_xpos window.win_ypos
                 wi window.win_height in
      let w2 = Window.create false (Window window) (window.win_xpos + wi) 
                 window.win_ypos
                 (window.win_width - wi) window.win_height in
      window.win_down <- HComb (w1,w2);
      Frame.install w1 frame;
      Frame.create w2 None frame.frm_buffer |> ignore
    end
@

% usually create also subwindows when run certain commands,
% like M-!, in which case the code usually looks like
% let newwin = Multi_frames.cut_frame frame in 
% Frame.create buf newwin ...


<<function Multi_frames.cut_frame>>=
let cut_frame frame =
  let window = frame.frm_window in
  if window.win_height > 3 then
    let h = window.win_height / 2 in
    let w1 = Window.create false
        (Window window) window.win_xpos window.win_ypos
        window.win_width h in
    let w2 = Window.create false (Window window) window.win_xpos 
        (window.win_ypos + h) 
      window.win_width (window.win_height - h) in
    window.win_down <- VComb (w1,w2);
    Frame.install w1 frame;
    w2 
  else
    window
@

\section{Deleting sub windows}

<<[[edit_menu]] entries>>=
"One Frame", "one_frame";
"Delete Frame", "delete_frame";
@
%bug? not sure v_cut_frame will work!
<<frame managment keys>>=
[c_x; NormalMap, Char.code '1'], "one_frame";
[c_x; NormalMap, Char.code '0'], "delete_frame";
@

<<frame managment actions>>=
(* C-x map *)
define_action "one_frame"  Multi_frames.one_frame;
(* C-x map *)
define_action "delete_frame"  Multi_frames.delete_frame;
@

<<function Multi_frames.one_frame>>=
let one_frame frame =
  if frame.frm_mini_buffer = None 
  then
    let window = frame.frm_window in
    let top_window = Window.top window in
    if not (top_window.window == window) then
      begin
        Frame.install top_window.window frame;
        Frame.active frame
      end
@

<<function Multi_frames.delete_frame>>=
let delete_frame frame =
  if frame.frm_mini_buffer = None 
  then
    let window = frame.frm_window in
    match window.win_up with
      TopWindow _ -> ()
    | Window upwin ->
        Frame.install upwin frame;
        Frame.active frame
@




<<[[Efuns.frame]] other fields>>=
mutable frm_killed : bool;
@

%XXX
% Minibuffer.kill | ??? -> <>
<<function Frame.kill>>=
let kill frame = 
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  frame.frm_killed <- true;
  buf.buf_shared <- buf.buf_shared - 1;
  Text.remove_point text buf.buf_point;
  Text.remove_point text buf.buf_start;
  buf.buf_point <- frame.frm_point;
  buf.buf_start <- frame.frm_start
@

% ??? -> <>
<<function Multi_frames.remove_frame>>=
let remove_frame frame =
  if frame.frm_mini_buffer = None then
    let window = frame.frm_window in
    match window.win_up with
    | TopWindow _ -> ()
    | Window upwin ->
        Window.prev (Frame.install upwin) window
@

\section{Navigating windows}

<<frame navigation keys>>=
[c_x; NormalMap, Char.code 'o'], "next_frame";
@
<<frame navigation actions>>=
(* C-x map *)
define_action "next_frame"  Multi_frames.next_frame;
@

<<function Multi_frames.next_frame>>=
let next_frame frame =
  let window = frame.frm_window in
  Window.next Frame.active window
@


<<function Window.next>>=
let rec next f window =
  match window.win_up with
  | TopWindow top_window -> first f top_window.window
  | Window win ->
      match win.win_down with
        HComb (w1,w2) ->
          if w2 == window 
          then next f win
          else first f w2
      | VComb (w1,w2) ->
          if w2 == window 
          then next f win
          else first f w2
      | _ -> ()
@


%\section{Navigation}


% ?? -> <>
<<function Window.first>>=
let rec first f window =
  match window.win_down with
    WFrame frame -> f frame
  | HComb (w1,w2) -> first f w1
  | VComb (w1,w2) -> first f w1
  | NoFrame _ -> ()
@

% ?? -> <>
<<function Window.last>>=
let rec last f window =
  match window.win_down with
    WFrame frame -> f frame
  | HComb (w1,w2) -> last f w2
  | VComb (w1,w2) -> last f w2
  | NoFrame _ -> ()
@


% ?? -> <>
<<function Window.prev>>=
let rec prev f window =
  match window.win_up with
    TopWindow top_window -> 
      if window == top_window.window then ()
      else 
        last f top_window.window
  | Window win ->
      match win.win_down with
        HComb (w1,w2) ->
          if w1 == window 
          then prev f win
          else last f w1
      | VComb (w1,w2) ->
          if w1 == window 
          then prev f win
          else last f w1
      | _ -> ()
@



\chapter{Major Modes}

<<[[Efuns.buffer]] other fields>>=
mutable buf_major_mode : major_mode;
@
% note that major mode is a property of the buffer! not the frame.

<<[[Efuns.status]] other fields>>=
mutable stat_mode : major_mode;
@


<<type Efuns.major_mode>>=
and major_mode = {
    maj_name : string;
    maj_map : map;

    mutable maj_hooks : (buffer -> unit) list;
    mutable maj_vars : vars;
  }
@

% toplevel fondamental_mode | every major modes  -> <>
<<function Ebuffer.new_major_mode>>=
let new_major_mode name hooks = {
    maj_name = name;
    maj_map = Keymap.create ();
    maj_hooks = hooks;
    maj_vars = Local.vars ();
  }
@


% set_buffer_mode -> <>
<<function Ebuffer.set_major_mode>>=
let set_major_mode buf mode =
  if !debug
  then pr2 (spf "setting %s major mode" mode.maj_name);
  buf.buf_modified <- buf.buf_modified + 1;
  buf.buf_major_mode <- mode;
  mode.maj_hooks |> List.iter (fun f -> 
    try f buf 
    with exn -> error "set_major_mode: exn = %s" (Common.exn_to_s exn)
  )
@



\section{Fundamental mode}

<<[[interactives_map]] initial entries>>=
"fondamental_mode";
@
% it's fundamental-mode normally :) french :)
<<major mode actions>>=
define_action "fondamental_mode" fondamental_mode;
@

<<function Std_efunsrc.fondamental_mode>>=
let fondamental_mode frame =
  Ebuffer.set_major_mode frame.frm_buffer Ebuffer.fondamental_mode
@


<<constant Ebuffer.fondamental_mode>>=
let fondamental_mode = new_major_mode "Fondamental" [] (* no hooks *)
@

\section{Auto detection}

<<constant Ebuffer.modes_alist>>=
let modes_alist = Local.create_abstr "modes_alist"
@
% but who sets it?


<<constant Ebuffer.suffix_reg>>=
let suffix_reg = Str.regexp "\\(.*\\)<[0-9]+>$"
@
%$

% ?? -> <>
<<function Ebuffer.set_buffer_mode>>=
let set_buffer_mode buf =
  let buf_name = 
    match buf.buf_filename with
      None -> 
        (try
           if Str.string_match suffix_reg buf.buf_name 0 
           then Str.matched_group 1 buf.buf_name 
           else buf.buf_name 
         with exn -> 
           error "set_buffer_mode: exn = %s" (Common.exn_to_s exn);
           buf.buf_name
         )
    | Some file_name -> file_name 
  in 
  let modes_alist = Efuns.get_var buf modes_alist in
  (* must use != here, because modes_alist contain functional values *)
  if (!modes_old != modes_alist) then begin
    regexp_alist := modes_alist |> List.map (fun (file_reg, major) ->
      Str.regexp file_reg, major
    );
    modes_old := modes_alist;
  end;
  try
    !regexp_alist |> List.iter (fun (regexp, major) ->
      if Str.string_match regexp buf_name 0 
      then
        try
          set_major_mode buf major;
          raise Exit
        with 
        | Exit -> raise Exit
        | exn -> 
            error "set_buffer_mode: exn = %s" (Common.exn_to_s exn);
            raise Exit
    ) 
  with Exit -> ()
@
% ugly those raise Exit

% opti, memo in regexp_alist
<<constant Ebuffer.modes_old>>=
let modes_old = ref []
@
<<constant Ebuffer.regexp_alist>>=
let regexp_alist = ref []
@

<<toplevel Ebuffer._1>>=
let _ =
  Efuns.add_start_hook (fun () ->
    set_global create_buf_hook [set_buffer_mode];
    set_global modes_alist []
  )
@
% important hook!!


\section{Status line}

<<[[Frame.create_without_top()]] adjust status of frame>>=
status_major_mode frame;
@

<<function Frame.status_major_mode>>=
let status_major_mode frame  =
  let buf = frame.frm_buffer in
  let status = frame.frm_status in
  if not (status.stat_modes == buf.buf_minor_modes &&
          status.stat_mode == buf.buf_major_mode
    ) then
    begin
      status.stat_modes <- buf.buf_minor_modes;
      status.stat_mode <- buf.buf_major_mode;
      status_print status (Printf.sprintf "(%s)" 
          (print_list
            (buf.buf_major_mode.maj_name ::
            (List.map (fun m -> m.min_name) status.stat_modes))))
      StatMode;
    end
@

\section{Major mode variables and keys}

<<function Efuns.set_major_var>>=
let set_major_var maj var value = 
  Local.set maj.maj_vars var value
@

<<function Keymap.add_major_key>>=
let add_major_key major = 
  interactive major.maj_map 
@


<<[[Ebuffer.get_binding()]] major mode key search>>=
(let b = Keymap.get_binding buf.buf_major_mode.maj_map keylist in
  match b with
    Prefix map -> binding := b
  | Function f -> binding := b; raise Exit
  | Unbound -> ());
@

<<[[Efuns.get_var()]] try with major mode variables>>=
Local.get buf.buf_major_mode.maj_vars var
@

\section{Colors}

% see section on colors in Text chapter

\section{Indentation}

\section{Structures}
% ???

\section{Abbrevs}

\chapter{Minor Modes}

% diff with major mode? can have multi minor mode, but
% could unify and have multi major mode? or major mode
% is just the one to display first?

<<[[Efuns.buffer]] other fields>>=
mutable buf_minor_modes : minor_mode list;
@

<<[[Efuns.status]] other fields>>=
mutable stat_modes : minor_mode list;
@

<<type Efuns.minor_mode>>=
and minor_mode = {
    min_name : string;
    min_map : map;

    mutable min_hooks : (buffer -> unit) list;
    mutable min_vars : vars;
  }
@

%<<function Ebuffer.new_minor_mode>>=
%let new_minor_mode name = {
%    min_name = name;
%    min_map = Keymap.create ();
%    min_hooks = [];
%    min_vars = Local.vars ()
%  }
%@
% dead?

<<function Ebuffer.new_minor_mode>>=
let new_minor_mode name hooks  = {
    min_name = name;
    min_map = Keymap.create ();
    min_hooks = hooks;
    min_vars = Local.vars ()
  }
@


<<function Ebuffer.set_minor_mode>>=
let set_minor_mode buf mode =
  buf.buf_minor_modes <- mode :: buf.buf_minor_modes;
  buf.buf_modified <- buf.buf_modified + 1;
  mode.min_hooks |> List.iter (fun f -> 
    try f buf 
    with exn -> error "set_minor_mode: exn = %s" (Common.exn_to_s exn)
  ) 
@

<<function Ebuffer.del_minor_mode>>=
let del_minor_mode buf minor =
  buf.buf_minor_modes <- 
    List.fold_right (fun mode list -> 
      if mode == minor then begin
        buf.buf_modified <- buf.buf_modified + 1;
        list
      end else (mode :: list)
    ) buf.buf_minor_modes []
@



\section{Example}
%less: maybe better to use paren mode as example, more concrete
% instead of all those empty functions, harder to understand.

<<constant Minor_mode_sample.minor_mode_name>>=
let minor_mode_name = "my_minor"
@

% empty install hook
<<function Minor_mode_sample.install>>=
let install buf = 
  ()
@

%!! that's what you will modify
<<constant Minor_mode_sample.mode>>=
let mode = Ebuffer.new_minor_mode  minor_mode_name [install]
@


<<function Minor_mode_sample.minor_mode_fun>>=
let minor_mode_fun frame = ()
@


<<toplevel Minor_mode_sample._1>>=
let _ = 
  List.iter
    (fun key -> 
      Keymap.add_binding mode.min_map [NormalMap, Char.code key]
        minor_mode_fun
  )
  [ ] (* no keys *)
@

%ex:
%<<toplevel Paren_mode._1>>=
%let _ = 
%  List.iter
%    (fun key -> 
%      Keymap.add_binding mode.min_map [NormalMap, Char.code key] find_matching
%  ) [ ')'; '}'; ']' ]
%@


<<toplevel Minor_mode_sample._2>>=
let _ = 
  define_action (minor_mode_name ^ "_mode")
    (fun frame -> 
      let buf = frame.frm_buffer in
      if Ebuffer.modep buf mode 
      then Ebuffer.del_minor_mode buf mode
      else Ebuffer.set_minor_mode buf mode
    )
@
% could be define_buffer_action too as don't use any info from the frame

<<function Ebuffer.modep>>=
let modep buf minor =
  List.memq minor buf.buf_minor_modes
@

\section{Minor mode variables and keys}

<<function Efuns.set_minor_var>>=
let set_minor_var min var value = 
  Local.set min.min_vars var value
@

<<function Keymap.add_minor_key>>=
let add_minor_key minor = 
  interactive minor.min_map 
@



<<[[Ebuffer.get_binding()]] minor mode key search>>=
buf.buf_minor_modes |> List.iter (fun minor ->
  let b = Keymap.get_binding minor.min_map keylist in
  match b with
    Prefix map -> binding := b
  | Function f -> binding := b; raise Exit
  | Unbound -> ()
); 
@

<<[[Efuns.get_var()]] try with minor mode variables>>=
let rec iter list =
  match list with
  | [] -> raise Not_found
  | min :: list -> 
      try
        Local.get min.min_vars var
      with _ -> iter list
in
iter buf.buf_minor_modes
@





\chapter{Extra Features}

\section{Running external commands}

% and get result in a buffer! "everything is a buffer"
% so can then use all the tools in emacs to manipulate the output
% of this external command

<<external commands keys>>=
[MetaMap, Char.code '!'], "shell_command";
@
<<external command actions>>=
define_action "shell_command"  System.shell_command;
@

<<function System.shell_command>>=
let shell_command frame =
  Select.select_string frame "Run command:" shell_hist "" (fun cmd -> 
    start_command "*Command*" (Multi_frames.cut_frame frame) cmd |> ignore)
@

<<constant System.shell_hist>>=
let shell_hist = ref []
@

<<function System.start_command>>=
let start_command buf_name window cmd =
  let buf = system buf_name cmd (fun _buf _status -> ()) in
  let frame = Frame.create window None buf in
  frame
@



<<function System.system>>=
let system buf_name cmd end_action =
  let (pid,inc,outc) = open_process cmd in
  let text = Text.create "" in
  let curseur = Text.new_point text in
  let buf = Ebuffer.create buf_name None text (Keymap.create ()) in
  (* !!! *)
  buf.buf_sync <- true;

  let ins = Unix.descr_of_in_channel inc in
  let tampon = String.create 1000 in
  let active = ref true in
  let location = Efuns.location () in
  Concur.Thread.add_reader ins (fun () ->
    let pos,str = Text.delete_res text curseur
                    (Text.point_to_eof text curseur) in
    let len = input inc tampon 0 1000 in
    Mutex.lock location.loc_mutex;
    if len = 0 then begin
      let pid,status = waitpid [WNOHANG] pid in
      (match status with 
      | WEXITED s -> Text.insert_at_end text (spf "Exited with status %d\n" s); 
          close_in inc;
          close_out outc;
          (try end_action buf s with _ -> ())
      | _ -> Text.insert_at_end text "Broken pipe" 
      );
      Text.set_position text curseur (Text.size text);
      active := false;
      (* redraw screen *)
      Top_window.update_display ();

      Mutex.unlock location.loc_mutex;
      Concur.Thread.remove_reader ins; (* Kill self *)
    end
    else
      Text.insert_at_end text (String.sub tampon 0 len);

    Text.set_position text curseur (Text.size text);
    Text.insert text curseur str;
    buf.buf_modified <- buf.buf_modified +1;

    (* redraw screen *)
    Top_window.update_display ();
    Mutex.unlock location.loc_mutex
  );

  let lmap = buf.buf_map in
  Keymap.add_binding lmap [NormalMap, XK.xk_Return] (fun frame ->
    let point = frame.frm_point in
    Text.insert text point "\n";
    Text.fmove text point 1;
    if !active then (* to avoid a segmentation fault in Ocaml *) begin
      let str = Text.sub text curseur 
          (Text.point_to_eof text curseur) in
      Text.set_position text curseur (Text.size text);
      (* synchronize viewpoint *)
      output outc str 0 (String.length str);
      flush outc
    end
  );

  <<[[System.system()]] set finalizer, to intercept killed frame>>

  buf
@


<<function System.open_process>>=
let open_process cmd =
  let (in_read, in_write) = pipe() in
  let (out_read, out_write) = pipe() in
  let inchan = in_channel_of_descr in_read in
  let outchan = out_channel_of_descr out_write in
  match fork() with
  | 0 ->
      if out_read <> stdin then begin
        dup2 out_read stdin; 
        close out_read 
      end;
      if in_write <> Unix.stdout ||  in_write <> Unix.stderr then begin
        if in_write <> Unix.stdout 
        then dup2 in_write stdout;
        if in_write <> Unix.stderr 
        then dup2 in_write stderr; 
        close in_write 
      end;
      List.iter close [in_read;out_write];
      execv "/bin/sh" [| "/bin/sh"; "-c"; cmd |];
      (*      exit 127 *)
  | pid -> 
      Unix.close out_read;
      Unix.close in_write;
      (pid, inchan, outchan)
@

\subsection{Threads and mutex}

<<[[Efuns.location]] other fields>>=
loc_mutex : Mutex.t;
@
% have multiple threads? need mutual exclusion?

\subsection{Finalizers}

<<[[Efuns.buffer]] other fields>>=
mutable buf_finalizers : (unit -> unit) list;
@
% when need that? if attached to a process?

<<[[System.system()]] set finalizer, to intercept killed frame>>=
buf.buf_finalizers <- (fun () -> 
  (try 
     Unix.kill pid Sys.sigkill;
     waitpid [] pid |> ignore;
   with _ -> ()
  );
  Concur.Thread.remove_reader ins
) :: buf.buf_finalizers;
@



\subsection{Synchronous buffers}

<<[[Efuns.buffer]] other fields>>=
mutable buf_sync : bool;
@

<<[[Frame.display()]] if buf sync goto end of text>>=
if buf.buf_sync && buf.buf_modified <> frame.frm_last_buf_updated 
then Text.set_position text point (Text.size text); 
@
% go at the end automatically even if no action was made
%todo: except if start to mv? in which case remove the buf_sync?


\section{Compilation and grep mode}

<<file menu entries>>=
"Compile", "compile";
@

<<[[interactives_map]] initial entries>>=
"compile";
"grep";
@
<<external command actions>>=
define_action "grep" Compil.grep;
define_action "compile" (Compil.compile Compil.c_find_error);
@


\subsection{[[M-x grep]]}

<<constant Std_efunsrc.grep_hist>>=
let grep_hist = ref ["grep -n "]
@

<<function Compil.grep>>=
let grep frame =
  let default = List.hd !grep_hist in
  Select.select_string frame 
    (Printf.sprintf "Grep command: %s (default: %s) " !!grep_command default)
    grep_hist ""
    (fun cmd -> 
      let cmd = if cmd = "" then default else cmd in
      let cmd = !!grep_command ^ " " ^ cmd in
      let cdir = Frame.current_dir frame in
      let comp_window =
        match !compilation_frame with
        | None -> Multi_frames.cut_frame frame 
        | Some (new_frame,error_point, _) ->
            Text.remove_point new_frame.frm_buffer.buf_text error_point;
            Ebuffer.kill new_frame.frm_buffer;
            if new_frame.frm_killed 
            then Multi_frames.cut_frame frame
            else new_frame.frm_window 
      in
      Unix.chdir cdir;
      let comp_frame = System.start_command "*Grep*" comp_window cmd in
      Frame.active frame;
      let buf = comp_frame.frm_buffer in
      let error_point = Text.new_point buf.buf_text in
      compilation_frame := Some (comp_frame, error_point, cdir);
      set_local buf find_error c_find_error
  )
@

\subsection{[[M-x compile]]}

<<misc actions>>=
(*define_action "compile" compile;*)
@
<<function Std_efunsrc.compile>>=
(*
let compile frame =
  Interactive.exec_interactive (Interactive.buf_interactives frame.frm_buffer) 
    frame "compile"
*)
@
% ???

<<function Compil.compile>>=
let compile find_error_fun frame =
  let default = List.hd !make_hist in
  Select.select_string frame 
    ("Compile command: (default :"^ default^") " )
    make_hist ""
    (fun cmd -> 
      let cmd = if cmd = "" then default else cmd in
      let cdir = Frame.current_dir frame in
      let cdir = 
        if !!compile_find_makefile then
          if String.sub cmd 0 4 = "make" || String.sub cmd 1 4 = "make" then
          (* try to find a Makefile in the directory *)
            let rec iter dir =
              let m = Filename.concat dir "Makefile" in
              if Sys.file_exists m then dir else
              let m = Filename.concat dir "makefile" in
              if Sys.file_exists m then dir else                
              let m = Filename.concat dir "GNUmakefile" in
              if Sys.file_exists m then dir else 
              let newdir = Filename.dirname dir in
              if newdir = dir then cdir else iter newdir
            in
            iter cdir
          else cdir
        else cdir
      in
      let comp_window =
        match !compilation_frame with
          None -> Multi_frames.cut_frame frame 
        | Some (new_frame,error_point, _) ->
            Text.remove_point new_frame.frm_buffer.buf_text error_point;
            Ebuffer.kill new_frame.frm_buffer;
            if new_frame.frm_killed 
            then Multi_frames.cut_frame frame
            else new_frame.frm_window 
      in
      Unix.chdir cdir;
      let comp_frame = System.start_command "*Compile*" comp_window cmd in
      Frame.active frame;
      let buf = comp_frame.frm_buffer in
      let error_point = Text.new_point buf.buf_text in
      compilation_frame := Some (comp_frame, error_point, cdir);
      set_local buf find_error find_error_fun
  )
@

\subsection{Go to next error}

<<misc keys>>=
@
<<misc actions>>=
(* C-x map *)
define_action "next_error"  Compil.next_error;
@
%pad: C-n


<<function Compil.next_error>>=
let next_error top_frame =
  let top_window = Window.top top_frame.frm_window in
  match !compilation_frame with
    None -> Top_window.message top_window "No compilation started"
  | Some (frame, error_point, cdir) ->      
      if frame.frm_killed 
      then Frame.unkill (Multi_frames.cut_frame top_frame) frame;
      let buf = frame.frm_buffer in
      let find_error = try
          get_local buf find_error
        with Failure _ -> !default_error
      in
      let text = buf.buf_text in
      let point = frame.frm_point in
      try
        let error = find_error text error_point in
        Text.set_position text frame.frm_start error.err_msg;
        Text.set_position text point error.err_msg;
        frame.frm_force_start <- true;
        frame.frm_redraw <- true;
        if error.err_filename <> "" then
          let filename = Filename.concat cdir error.err_filename in
          let buf = Ebuffer.read filename (Keymap.create ()) in
(* new frame for error buffer *)
          let frame = 
            try Frame.find_buffer_frame buf 
            with Not_found ->
                if frame == top_frame then
                  let new_window = Top_window.create ()
                      (*Window.display top_window*) 
                  in
                  Frame.create new_window.window None buf
                else
                  Frame.create top_frame.frm_window None buf
          in
          let text = buf.buf_text in
          let point = frame.frm_point in
          Text.point_to_line text point error.err_line;
          Text.fmove text point error.err_begin;
          Frame.active frame
      with Not_found ->
        Top_window.message top_window "No more errors"
@

\section{Shell mode}

\section{Efuns server and client}

% dual of previous chapter in some sense since this time
% it's external command that call in efuns instead of efuns
% calling external commands

\section{[[M-x eval]]}

<<meta actions>>=
define_action "eval" Complexe.eval;  
@
<<[[interactives_map]] initial entries>>=
"eval";  
@

<<constant Complex.eval_history>>=
let eval_history = ref []
@

<<function Complex.eval>>=
let eval frame =
  Select.select_string frame "Eval:" eval_history "" (fun str ->
    let top_window = Window.top frame.frm_window in
    (* This is not enough: the paths also may have changed. *)
    Top_window.message top_window 
      (*(Dyneval.eval 
        (let len = String.length str in
        if str.[len - 1] = ';' && str.[len -2 ] = ';' then str else
        str ^ " ;;"))
      *)(failwith "Complex.eval: TODO")
    )
@


\section{Completion}

%Expansion des abbreviations: 
%deux fonctions principales: 
%- "dabbrev_expand": expansion des mots a partir de mots trouves dans les
%     buffers (binding normap "M-/").
%- "expand_sabbrev": expansion des mots a partir d'abbreviations trouvees
%    dans des tables associees au buffer (variable "abbrev_table") 
%    (binding normal: un caractere de fin de mot (espace,newline,..))

<<misc keys>>=
[NormalMap, Char.code ' '], "char_expand_abbrev";
[MetaMap, Char.code '/'], "dabbrev_expand";
@

<<toplevel Abbrevs._1>>=
let _ =
  define_action "char_expand_abbrev" (fun frame ->
      expand_sabbrev frame; 
      Simple.self_insert_command frame
  );
  define_action "dabbrev_expand" dabbrev_expand;
  ()
@

<<function Abbrevs.expand_sabbrev>>=
let expand_sabbrev frame =
  try
    let point = frame.frm_point in
    let buf = frame.frm_buffer in
    let text = buf.buf_text in
    let abbrevs = get_local buf abbrev_table in
    let mark = Text.dup_point text point in
    Simple.to_begin_of_word text point buf.buf_syntax_table;
    let str = Text.region text point mark in
    Text.remove_point text mark;
    let len = String.length str in
    try
      let repl = Hashtbl.find abbrevs str in
      Text.delete text point len;
      Text.insert text point repl;
      Text.fmove text point (String.length repl); ()
    with
      Not_found -> Text.fmove text point len; ()
  with _ -> ()
@

<<function Abbrevs.dabbrev_expand>>=
let dabbrev_expand frame = 
  let buf = frame.frm_buffer in
  let syntax = buf.buf_syntax_table in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let loop = ref false in
  let s, buf, pos, history =
    match !dabbrev_buf with
      Some (s, for_frame, for_position, for_len,buf, pos, history) 
      when frame == for_frame && for_position = Text.get_position text point ->
        Text.bmove text point for_len;
        Text.delete text point for_len;
        s, buf, pos, history
    | _ -> 
        let str = Simple.beginning_of_word buf point in
        str , buf, 
        Text.get_position text point - String.length str, []
  in
  let truelen = String.length s in
  let s = escaped s in
  Text.bmove text point truelen;
  let regexp = Str.regexp s in
  let rec iter curr_buf pos =
    let curr_text = curr_buf.buf_text in
    let mark = Text.new_point curr_text in
    Text.set_position curr_text mark pos;
    try
      let rec restart () =
        let _len = Text.search_backward curr_text regexp mark in
        if curr_text == text && mark = point then
          raise Exit
        else
          if Text.bmove_res curr_text mark 1 <> 0 then
            if syntax.(Char.code (Text.get_char curr_text mark)) 
            then begin Text.fmove curr_text mark 1; restart () end
            else Text.fmove curr_text mark 1 |> ignore
          else
            ()
      in
      let rec first () =
        restart ();
        Text.fmove curr_text mark truelen;
        let m = Simple.end_of_word curr_buf mark in
        if List.mem m history then
          (Text.bmove curr_text mark truelen; first ())
        else
          begin
            Text.fmove text point truelen;
            let _,len = Text.insert_res text point m in
            Text.fmove text point len;
            dabbrev_buf := Some (s, frame, Text.get_position text point, len, 
              curr_buf, Text.get_position curr_text mark, m :: history);
            Text.remove_point curr_text mark
          end
      in
      first ()
    with
      Not_found ->
        Text.remove_point curr_text mark;
        let curr_buf = Simple.next_buffer curr_buf in
        if curr_buf == buf then
          if !loop then raise Not_found
          else
            loop := true; (* to avoid infinite loop *)
        iter curr_buf (Text.size curr_buf.buf_text) 
    | Exit ->
        Text.remove_point curr_text mark;
        Text.fmove text point truelen;
        dabbrev_buf := None;
        raise Not_found
  in
  iter buf pos; ()
@


<<constant Abbrevs.dabbrev_buf>>=
let dabbrev_buf = ref None
@

<<constant Abbrevs.abbrev_table>>=
let abbrev_table = Local.create "abbrev_table" 
    (fun table ->
      let s = ref "" in 
      Hashtbl.iter (fun s1 s2 ->
          s := Printf.sprintf "%s%s --> %s\n" !s s1 s2
      ) table;
      !s
  )
  Local.no_input
@

<<function Abbrevs.escaped>>=
let escaped s =
  let n = ref 0 in
  let len = String.length s in
  for i = 0 to len - 1 do
    let c = String.unsafe_get s i in
    match c with
      '\\' | '[' | ']' | '^' -> incr n
    | _ -> ()
  done;
  if !n = 0 then s else
  let ss = String.create (len + !n) in
  let p = ref 0 in
  for i = 0 to len - 1 do
    let c = String.unsafe_get s i in
    (match c with
        '\\' | '[' | ']' | '^' -> 
          String.unsafe_set ss !p '\\';
          incr p
      | _ -> ());
    String.unsafe_set ss !p c;
    incr p    
  done;
  ss
@

\section{Colored files and directories}

\section{Buffers menu}

\section{Transforming}
% maybe move in extra features?

<<transforming keys>>=
[ControlMap, Char.code 't'], "transpose_chars";

[MetaMap, Char.code 't'], "transpose_words";
[MetaMap, Char.code 'l'], "lowercase_word";
[MetaMap, Char.code 'u'], "uppercase_word";

[MetaMap, XK.xk_q], "fill_paragraph";
@

<<transforming actions>>=
define_action "transpose_chars"  (Simple.to_frame Simple.transpose_chars);

define_action "transpose_words"  (Simple.to_frame Simple.transpose_words);
define_action "lowercase_word" (fun frame ->
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  Simple.on_word buf point String.lowercase
);

define_action "uppercase_word" (fun frame ->
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  Simple.on_word buf point String.uppercase
);

define_action "fill_paragraph" Simple.fill_paragraph;
@

\subsection{Characters}

<<function Simple.transpose_chars>>=
let transpose_chars buf point =
  let text = buf.buf_text in
  let session = Text.start_session text in
  Text.bmove text point 1;
  let pos,c1 = Text.delete_res text point 1 in
  Text.fmove text point 1;
  Text.insert text point c1 |> ignore;
  Text.commit_session text session;
  Text.fmove text point 1;
  ()
@

\subsection{Words}
%\subsection{Case changing}

<<function Simple.transpose_words>>=
let transpose_words buf point =
  let text = buf.buf_text in
  let session = Text.start_session text in
  let syntax = buf.buf_syntax_table in
  in_prev_word text point syntax;
  to_begin_of_word text point syntax;
  let pos1 = Text.dup_point text point in
  to_end_of_word text point syntax;
  let _,word1 = Text.delete_res text pos1 (Text.distance text pos1 point) in
  Text.goto_point text point pos1;
  in_next_word text point syntax;
  let pos2 = Text.dup_point text point in
  to_end_of_word text point syntax;
  let _,word2 = Text.delete_res text pos2 (Text.distance text pos2 point) in    
  Text.insert text pos1 word2 |> ignore;
  Text.insert text pos2 word1 |> ignore;
  Text.fmove text point (String.length word1);
  Text.commit_session text session;
  Text.remove_point text pos1;
  Text.remove_point text pos2
@

<<function Simple.on_word>>=
let on_word buf point f =
  let text = buf.buf_text in
  let session = Text.start_session text in
  let syntax = buf.buf_syntax_table in
  to_begin_of_word text point syntax;
  let pos1 = Text.dup_point text point in
  to_end_of_word text point syntax;
  let _,word1 = Text.delete_res text pos1 (Text.distance text pos1 point) in
  let w = f word1 in
  Text.insert text pos1 w |> ignore;
  Text.fmove text point (String.length w);
  Text.commit_session text session;
  Text.remove_point text pos1
@

\subsection{Filling}

<<function Simple.fill_paragraph>>=
(* We will have to modify this to handle line_comment soon !! *)
let fill_paragraph frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let start = Text.dup_point text point in
  let session = Text.start_session text in
  backward_paragraph buf start;
  let fin = Text.dup_point text start in
  forward_paragraph buf fin;
  simplify text start fin;
  Text.insert text start "\n" |> ignore;
  let rec iter count last_space =
    if Text.compare text start fin < 0 then
    if Text.fmove_res text start 1 = 1 then 
      let c = Text.get_char text start in  
        if c = ' ' then (* good, a new space *)
          iter (count+1) 0
      else
      if count > 75 && count <> last_space then 
          begin
          Text.bmove text start (last_space+1);
          Text.delete text start 1;
          Text.insert text start "\n";
          Text.fmove text start 1;
          iter 0 0
          end
        else
          iter (count+1) (last_space+1)
  in
  iter 0 0;  
  Text.insert text fin "\n" |> ignore;
  Text.remove_point text start;
  Text.remove_point text fin;
  Text.commit_session text session
@


\section{Misc}

\subsection{Read-only}

% useful for instance for special major mode like
% buffer_menu, completion, etc, where don't want 
% edition at all.

<<[[Text.text]] other fields>>=
mutable text_readonly : bool;
@

<<[[Text.low_insert()]] fail if readonly buffer>>=
if text.text_readonly 
then failwith "Buffer is read-only";
@


%getter
<<function Text.readonly>>=
let readonly tree = 
  let text = tree.tree_text in    
  text.text_readonly
@
%setter
% dead since not one calls it and it's not an action
<<function Text.toggle_readonly>>=
let toggle_readonly tree = 
  let text = tree.tree_text in    
  text.text_readonly <- not text.text_readonly
@


\chapter{Advanced Topics}

\section{Tabs}

%(* for J.G. Malecki: tabs have a different representation depending
% * their position in the text (as in xterms) 
% *)

<<[[Ebuffer.create()]] adjust charreprs>>=
buf.buf_charreprs.(9) <- String.make !tab_size ' ';
@

<<constant Ebuffer.tab_size>>=
let tab_size = ref 9
@


<<[[Text.compute_representation()]] compute charrepr, special char>>=
if charcode = 9 
then tabreprs.(!repr_cursor mod 9)
@


<<constant Minibuffer.charreprs>>=
let charreprs = Array.init 256 (fun i -> String.make 1 (Char.chr i))
@
<<toplevel Minibuffer._1>>=
let _ =
  charreprs.(9) <- String.make !Ebuffer.tab_size ' '
@


% This should not exist I think. It complicates stuff.
% Which is why I put it in advanced topics

<<constant Text.tabreprs>>=
let tabreprs = [|
    "         ";
    "        ";
    "       ";
    "      ";
    "     ";
    "    ";
    "   ";
    "  ";
    " ";
    ""
  |]
@
% 8 columns tab!


\section{Unicode}

% charreprs?

\section{Signals}

<<exception Main.SigInt>>=
exception SigInt
@

<<[[main()]] set signal handlers>>=
Utils.register_exn (fun e ->
  match e with
  | Unix.Unix_error (error,f,arg) ->
      Printf.sprintf "Unix error %s: %s %s" f (Unix.error_message error) arg
  | _ -> raise e
);

Utils.set_signal Sys.sigint (Sys.Signal_handle (fun _ ->  
  (* Should auto-save all buffers, and then exit ... *)
  exit 1
)); 
Utils.set_signal Sys.sigterm (Sys.Signal_handle (fun _ ->  
  (* Should auto-save all buffers, and then exit ... *)
  raise SigInt
));
Utils.set_signal Sys.sighup (Sys.Signal_handle (fun _ -> 
  raise SigInt
));
@

\section{Dynamic linking}

<<[[main()]] command line options>>=
  "-I",Arg.String (fun s -> Efuns.load_path =:= 
      (Utils.string_to_path s) @ !!Efuns.load_path), "<path>: Load Path";
@
%dead? or for dynlink?

<<constant Efuns.load_path>>=
let load_path = define_option ["efuns_path"] 
  "<load_path> is the path where modules (.cmo and .cma) can be found
  for dynamic linking." path_option []
@

<<constant Efuns.path>>=
let path = (*Dyneval.load_path*) ref []
@

<<constant Efuns.efuns_path>>=
let efuns_path = [ 
      (Filename.concat homedir ".efuns") ;
(*
      Version.efuns_lib; 
      Version.installdir; 
      Version.ocamllib
*)
  ]
@

<<toplevel Efuns._1>>=
let _ = 
  path := !!load_path @ efuns_path;
  option_hook load_path (fun _ -> path := !!load_path @ efuns_path)
@

\section{X11}

<<constant Efuns.xdefaults>>=
let xdefaults = try Sys.getenv "XUSERFILESEARCHPATH" with
    Not_found -> Filename.concat Utils.homedir ".Xdefaults"
@

<<toplevel Efuns._2>>=
(*
let _ =
  begin    
    try
      let efuns_res = 
        let path = try Utils.string_to_path (Sys.getenv "XFILESEARCHPATH") with _ -> 
              [] in
        let xenv = try Sys.getenv "XENVIRONMENT" with _ -> "" in
        let xroot = try Filename.concat  (Sys.getenv "X11ROOT")
            "lib/X11/app-defaults/" with _ -> "" in
        Utils.find_in_path (path@[
            xenv; xroot; "/usr/X11/lib/X11/app-defaults/"]) "Efuns"
      in
      Xrm.safe_load x_res efuns_res
    with _ -> ()
  end;
  Xrm.safe_load x_res xdefaults
*)
@

<<constant Efuns.x_res>>=
(*let x_res = Xrm.create ()*)
@

<<constant Efuns.t>>=
(*let t = x_res*)
@




\section{Multiple toplevel windows}
% called actually frame in emacs terminology, but confusing I think.
% I don't think this feature is very useful.

% this used to require also the display parameter passed around,
% but I've removed it for now.

%todo: this is why have list top_window in location.top_windows?

<<misc keys>>=
<<window managment keys>>
@

<<misc actions>>=
<<window managment actions>>
@

<<constant Std_efunsrc.n_5>>=
let n_5 = (NormalMap, Char.code '5') 
@

<<constant Keymap.n_5>>=
let n_5 = (NormalMap, Char.code '5')
@

<<window managment keys>>=
(* less: delete *)
[c_x; n_5; NormalMap, Char.code 'f'], "window_load_buffer";
[c_x; n_5; NormalMap, Char.code 'b'], "window_change_buffer";
[c_x; n_5; NormalMap, Char.code '0'], "delete_window";
@

<<window managment actions>>=
(* C-x 5 map *)
define_action "window_load_buffer"  Complexe.window_load_buffer;
(* C-x 5 map *)
define_action "window_change_buffer"  Complexe.window_change_buffer;
(* C-x 5 map *)
define_action "delete_window"  Top_window.delete_window;
@


<<function Complex.window_load_buffer>>=
let window_load_buffer frame = 
  Select.select_filename frame "Find file: " 
    (fun str -> 
      let top_window = Top_window.create ()
          (*(Window.display top_window)*)
      in
      Frame.load_file top_window.window str |> ignore
    )
@

<<function Complex.window_change_buffer>>=
let window_change_buffer frame =
  Select.select_buffer frame "Switch to buffer in new frame: " 
    (Select.get_previous_frame ())
    (fun name ->
      let top_window = Top_window.create ()
           (*"TODO_Display"*) 
      in
      Frame.change_buffer top_window.window name
  )
@

<<function Top_window.delete_window>>=
let delete_window frame =
  failwith "Top_window:delete_window: TODO"
(*
  let top_window = Window.top frame.frm_window in
  let location = Efuns.location() in
  if List.length location.top_windows > 1 then
    let xterm = Window.xterm top_window in
    top_window.top_appli#destroy;
    WX_xterm.destroy_window xterm;
    Frame.kill_all top_window.window;
    location.top_windows <- Utils.list_remove location.top_windows
      top_window
*)
@

<<function Frame.kill_all>>=
let kill_all window =
  Window.iter kill window
@


<<constant Efuns.init_frames>>=
let init_frames = ref []
@
<<[[main()]] command line options>>=
  "-frame", Arg.String (fun s -> init_frames := s:: !init_frames), "<file>: open a frame with <file>";
@
%todo: remove? seems related to original notion of emacs frames
% that is independent emacs windows






\chapter{Conclusion}








\appendix

\chapter{Error Managment}

<<function Efuns.error>>=
let error f x =
  print_string ("error: ");
  Printf.printf f x;
  print_newline ()
@

<<function Ebuffer.message>>=
let message buf m =
  let name = "*Messages*" in
  try
    let buf = Hashtbl.find (Efuns.location()).loc_buffers name in
    Text.insert_at_end buf.buf_text (m^"\n");
  with Not_found ->
    create name None (Text.create (m^"\n")) (Keymap.create ()) |> ignore
@


%todo: there is a giant try somewhere?
% if do some failwith in the code, e.g. failwith "Buffer is read-only",
% then catched? and displayed nicely?

\chapter{Debugging}

% can use ocamldebug! fantastic!

<<constants Efuns.debug_xxx>>=
let debug = ref false
let debug_graphics = ref false
let debug_display = ref false
let debug_init = ref false
@

%less: would be good to have a -debug_init so at least print out
% all those hooks that are run at startup time

<<[[main()]] command line options>>=
"-debug", Arg.Set Efuns.debug, 
" for debugging";
"-debug_graphics", Arg.Set Efuns.debug_graphics, 
" for debugging";
"-debug_display", Arg.Set Efuns.debug_display, 
" for debugging";
"-debug_init", Arg.Set Efuns.debug_init, 
" for debugging";

"-debugger", Arg.Unit (fun () ->
  Efuns.debug := true;
), " for debugging";
@

\section{Actions trace, [[-debug]]}

<<[[Top_window.try_map()]] if debug, print action name>>=
if !Efuns.debug
then begin
  let found = ref false in
  Efuns.actions |> Hashtbl.iter  (fun k v ->
    match v with
    (* subtle: this will work only if f2 was not a closure *)
    | FrameAction f2 when f == f2 ->
        found := true;
        pr2 (spf "action: %s" k)
    | _ -> ()
  );
  if not !found
  then pr2 ("action not found");
end;
@

\section{Graphics commands trace, [[-debug_graphics]]}

\chapter{Profiling}

\chapter{Heterogeneous Collection Library}

% local.ml (why local?)
% quite important when you want each mode to be able to store
% variables in the buffer, but each of those variables have
% different types. It's like you want a list of things or,
% an assoc, but each element value has a different type.
% Could do via Variant encapsulation, but annoying.
% Enters the heterogeneous map using phantom type tricks!

\section{Interface}

<<signature type Local.vars>>=
type vars
@

<<signature function Local.vars>>=
val vars : unit -> vars
@

<<signature type Local.var>>=
type 'a var
@

<<signature function Local.get>>=
val get : vars -> 'a var -> 'a
@

<<signature function Local.set>>=
val set : vars -> 'a var -> 'a -> unit
@

<<signature functions Local.create_xxx>>=
val create_int : string -> int var
val create_string : string -> string var
val create_float : string -> float var
@

% let allvars = vars ()
% let myintvar = create_int "myint"
% let mystrvar = create_string "mystr"

% set allvars myintvar 2
% set allvars mystrvar "foo"

% let i = get allvars myintvar
% let s = get allvars mystrvar

\section{Implementation}

\subsection{[[vars]]}

<<type Local.vars>>=
(* (string * Obj.t ref) Map ref *)
type vars = Obj.t ref Vars.t ref
@

<<module Local.Vars>>=
module Vars = Map.Make 
 (struct  
      type t = string
      let compare = compare 
 end)
@
% Map string -> 'a


<<function Local.vars>>=
let vars () = 
  ref Vars.empty
@

\subsection{[[var]]}

<<type Local.var>>=
type 'a var = string
@
% phantom type!


<<function Local.create_int>>=
let create_int name = 
  create name string_of_int int_of_string
@

<<function Local.create_float>>=
let create_float name = 
  create name string_of_float float_of_string
@

<<function Local.create_string>>=
let create_string name = 
  create name id id
@


<<global Local.vars_table>>=
let (vars_table :
    (string, (Obj.t -> string) * (string -> Obj.t)) Hashtbl.t)
  = Hashtbl.create 203
@
% global to all vars! can't have the same key in different
% table buth with different type!

<<signature function Local.create>>=
val create : string -> ('a -> string) -> (string -> 'a) -> 'a var
@

<<function Local.create>>=
let create name print input =
  try
    let _ = Hashtbl.find vars_table name in
    failwith (Printf.sprintf "A variable named %s already exists" name)
  with
    Not_found ->
      Hashtbl.add vars_table name (Obj.magic print, Obj.magic input);
      name
@


<<signature functions Local.create_xxx>>=
val create_abstr : string -> 'a var
@

<<function Local.create_abstr>>=
let create_abstr name = 
  create name no_print no_input
@

<<function Local.no_print>>=
let no_print x = 
  "<abstr>:" ^ (Common.dump x)
@
<<function Local.no_input>>=
let no_input (s : string) = failwith "This variable can not be set"
@

\subsection{Getter/setter}

<<function Local.get>>=
let get vars var =  
  Obj.magic !(Vars.find var !vars)
@

<<function Local.set>>=
let set vars var value =
  let value = Obj.repr value in
  try
    let r = Vars.find var !vars in
    r := value
  with
    Not_found -> 
      vars := Vars.add var (ref value) !vars
@

\subsection{Misc}

<<signature functions Local>>=
val no_input : string -> 'a
val no_print : 'a -> string

val set_input : vars -> 'a var -> string -> unit
val get_print : vars -> 'a var -> string
val list : vars -> string list

val print : vars -> string -> string
val input : vars -> string -> string -> unit
@

<<function Local.get_print>>=
let get_print vars var =
  let value = get vars var in
  let (p,i) = Hashtbl.find vars_table var in
  p value  
@

<<function Local.set_input>>=
let set_input vars var value =
  let (p,i) = Hashtbl.find vars_table var in
  set vars var (i value)
@

<<function Local.list>>=
let list vars =
  let list = ref [] in
  Vars.iter (fun var value ->
      list := var :: !list;
  ) !vars;
  !list
@

<<constant Local.print>>=
let print = get_print
@

<<constant Local.input>>=
let input = set_input
@


\chapter{Configuration File Library}

% options.ml
% quite important again, you want the editor to be customizable!

\section{Adding options}

% interface
<<[[Std_efunsrc._5]] start hooks options>>=
Simple.add_option_parameter Compil.compile_find_makefile;
Simple.add_option_parameter Text.add_amount;
@


<<type Simple.parameter>>=
type parameter = (string * ((string -> Obj.t) * (Obj.t -> string) * 
      Obj.t option_record))
@

<<constant Simple.parameters_var>>=
let parameters_var = Local.create_abstr "parameters"
@




<<function Simple.add_option_parameter>>=
let add_option_parameter option =
  add_parameter (shortname option)
   (fun s -> from_value (get_class option) (Value s))
   (fun v -> 
      match to_value (get_class option) v with
        Value s -> s
      | _ -> failwith "Unable to print option"
    ) 
    option
@

<<function Simple.add_parameter>>=
let add_parameter (name : string) (input : string -> 'a) 
  (print : 'a -> string) (param : 'a option_record) =
  let (input : string -> Obj.t) = Obj.magic input in
  let (print : Obj.t -> string) = Obj.magic print in
  let (param : Obj.t option_record) = Obj.magic param in
  set_global parameters_var (
    (name, (input, print, param)) :: 
    (try get_global parameters_var with _ -> []))
@



<<constant Simple.all_params>>=
let all_params = ref None
@

<<function Simple.all_parameters>>=
let all_parameters frame _ =
  let parameters = 
    try get_global parameters_var with _ -> []
  in
  match !all_params with
    Some (f,l) when f == parameters -> l
  | _ ->
      let list = List.map fst parameters in
      all_params := Some (parameters, list);
      list
@


<<constant Complex.parameters_hist>>=
let parameters_hist = ref []
@

<<function Complex.set_parameter>>=
let set_parameter frame = 
  let parameters = get_global Simple.parameters_var in
  Select.select frame "set-parameter : " parameters_hist
    "" (Simple.all_parameters frame) (fun s -> s) (fun variable ->
      Select.select_string frame (Printf.sprintf "%s : " variable)
      value_hist "" (fun value ->
          let (input,print,param) = List.assoc variable parameters
          in
          param =:= input value))
@

<<function Complex.get_parameter>>=
let get_parameter frame =
  let parameters = get_global Simple.parameters_var in  
  Select.select frame "get-parameter : " parameters_hist
    "" (Simple.all_parameters frame) (fun s -> s) (fun variable ->
      Top_window.mini_message frame 
        (Printf.sprintf "%s : %s" variable (
          let (input,print,param) = List.assoc variable parameters
          in
          print !!param)))
@




\chapter{Major mode examples}

% not here:
%  - makefile
%  - ocaml toplevel
% via ocamllex:
%  - html
%  - C
%  - ocaml
%  - tex

<<[[interactives_map]] initial entries>>=
"makefile_mode";
"ocaml_mode";
"c_mode";
"tex_mode";
@

\section{Dired}

\section{Lisp mode}

\chapter{Minor mode examples}

<<[[interactives_map]] initial entries>>=
"paren_mode";
"abbrevs_mode";
(*"accents_mode";*)
"fill_mode";
"tab_mode";
"overwrite_mode";

(*"ocaml_compiler_mode";*)
"ocaml_minor_mode";
@

\section{Abbrevs}

\section{Paren}
% useful! edwin power!

\section{Tab}

\section{Fill}

%\section{Accents}



\chapter{Extra Code}

\ifallcode
#include "Efuns_extra.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
BOL  = Beginning Of Line
EOL  = End Of Line
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

