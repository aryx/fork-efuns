\documentclass[12pt]{report}
%alt: 12pt, twocolumn, landscape
%coupling: see Config.tex

\input{principia-latex/Packages}
\input{principia-latex/Config}
\input{principia-latex/Macros}

%******************************************************************************
% Prelude
%******************************************************************************

%------------------------------------------------------------------------------
%history:
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:
% - better decomposition than simple.ml, complex.ml, good TOC
% - removed deadcode (frm_force_point, frm_force_cursor, edt_counter, 
%    resname, buf_history, line_hlt and its huge compute_representation code,
%    repr_x)
% - removed some redundant functions (Top_window.dummy_action)
% - cleaner conventions and field names between point and position, no more
%   let point = point.point uglyness
% - use global for editor instead of all those fields and renamed it from
%   confusing 'location' name
% - removed useless opti around representation, and renamed line_repr,
%   repr_line; use boxes instead. 'repr' was used for too many things.
% - more cohesion, e.g. Select and Simple buffer stuff in 
%   Multi_buffers instead, split Efuns to have also Var and Action,
%   mv colors and fonts from Window to Attr
% - more consistency with coord, position, point, line x col, xy
%   so less confusing (when uses sometimes xy for col x line and sometimes
%   for frame coordinates)
% - differentiate position and position2 types! helped find commenting bugs
%   and confusing names

%thx to codemap/codegraph/scheck:
% - SEMI use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - SEMI use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - SEMI use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand Emacs:
% - the minibuffer is really a buffer/frame like the other :)
% - the top_window is an entity worth having if you want multiple top_windows
% - the modeline is actually associated with each window
% - representation string vs original string, tabs and ^M display handling
% - TODO how the mark get changed when you do big move?
% - the global vs local variables, I always get confused about
%    local variables in emacs
% - syntax table and the word specification

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, type, constant
%    * TODO ctor/dtor, dumper
%    * TODO action
%    * [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the Extra section in the main file
% - understand main(), LP split main, improve TOC
% - understand main functions, LP split, cluster, improve TOC
% - LP split the structures, use datalog for flow to field info
% - aspectify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - redundant copyrights, pad special keybindings,
%    the mostly boilerplate of buffer_action vs frame_action

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Text Editor [[efuns]]
}\\
{version 0.5}
}
\l The Screen Text Editor

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Fabrice Le Fessant
}

\maketitle 

%\onecolumn
\hrule
\input{principia-latex/Copyright}
\hrule
%\twocolumn


\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to explain with full details the source code of
a {text editor}.

\section{Motivations}

Why a text editor? 
Because I think you are a better programmer if
you fully understand how things work under the hood, and
%
the editor is probably the tool a programmer uses the most.

Even if the kernel and compiler are essential to run and produce programs,
and are the subjects of many textbooks, 
the text editor is also an essential program. Indeed,
The source code of almost all programs, including kernels and compilers,
was first entered in a computer by a programmer using a text editor. 
%"One of the first 3 key element of UNIX: assembler, shell, editor!"
% (in addition to kernel of course)
In fact, text editors are used to enter the code of text editors, leading to
bootstrapping issues, just like in a compiler.
%without:
\l history: punch card before, and line editor before screen text editors

Here are a few questions I hope this book will answer:
\begin{itemize}

\item How the text of a file is represented in memory? 
Which data structure is used?
\n Gap buffer

\end{itemize}

\section{The text editor [[efuns]]}

% I chose efuns, an emacs clone, simple, elegant. Also different language
% than previous books. Written in OCaml! more high level than C, and while
% you want to write a kernel in C, it makes more sense for an app
% to use a higher level language like Ocaml!

%%Good to vary a bit, not always C, and code written by the same people.
%%Help also to explore concepts for Editor.nw.
%%(or actually might become Editor.nw) 
%%(or actually in the end I might actually switch to efuns!!)

%efuns vs emacs:
%  - see http://www.emacswiki.org/emacs/EfunsEditor
%  - no extension language (Lisp) to extend the editor with plugins.
%    It made sense for Emacs because the implementation language
%    was C, which is more error prone than Lisp, but by using OCaml
%    for the implementation language we don't need so much another 
%    language to extend the core. You can just add a module! Yes you need
%    to recompile, but so what? less dynamic, but anyway
%    in emacs case I usually do it via modifying my .emacs and
%    very often reloading my emacs (buy maybe I'm not a good dynamic
%    programmer)
%  - easier to debug! can use ocamldebug, no more -debug-on-error
%    and binary search in .emacs when have a paren pb
%  - easier to program, Ocaml > Lisp! can also use ocamlyacc, my
%    pfff real parsers. More colors. More structure. Can use threads!

%efuns stuff that is now better than in emacs:
% - pfff-based modes highlighters
%   * better colors (more colors to differentiate different kinds of idents)
%   * correct colors (e.g. no need %$ trick for noweb)
% - minimap
% - f in eshell that does not list object files
% - lefessant: find makefile automatically in parent dir in M-x compile
% - working syntax tables for my different modes for the word separation
% - dircolors also in eshell and compile/grep buffers :) actually quite nice!
% - can use threads to program extensions! e.g. cursor blinking was easy.
% - working ocamlmerlin

%emacs stuff better than in efuns:
%  - interactive mechanism with many arguments got interactively (e.g.,
%    region), so can define indent_region frame point1 point2 and
%    this function can be used interactively (or programmatically from other
%    lisp code)

\section{Other editors}

%history: (gen1)
% - QED "online editor" by Butler Lampson
%   history of QED: https://www.bell-labs.com/usr/dmr/www/qed.html
% - ed, http://blog.sanctum.geek.nz/actually-using-ed/
% - vi 
%   (vi but less code: http://lists.suckless.org/dev/1409/23497.html)
%classic: unix (gen2)
% - vim
% - emacs
%exotic:
% - sam
% - acme
% - Leo editor (mix of org mode and literate programming)
% - https://github.com/ChrisPenner/rasa
%simple:
% - textedit
% - nano
% - joe
%modern: (gen3)
% - textmate
% - sublime
% - atom
% - visual studio code
%   now used by a lot of developers and making progress according to stack
%   overflow survey in 2018
%IDEs:
% - eclipse
% - intellij
%fancy-visual:
% - lighttable
%   but its archi is a mess, see https://news.ycombinator.com/item?id=9377304
% - https://www.destroyallsoftware.com/talks/a-whole-new-world
%   but vaporware, no real product
% - bret's victor stuff
% - codemap :) (only a reader though)
%mini:
% - qemacs
% - vis, based on VI and sam (says use structural regular expression)
%   https://github.com/martanne/vis
% - pyvim
% - in rust:
%   https://github.com/google/xi-editor
%functional-language:
% - yi
%other-ocaml-editors:
% - https://github.com/diml/zed (seems just an "engine")
% - https://github.com/janestreet/ecaml can write emacs plugins in ocaml
%   see https://github.com/janestreet/ecaml/tree/master/src/ *.mli
% - http://ocamleditor.forge.ocamlcore.org/

%todo: look atom flight manual for its TOC?

% http://texteditors.org/cgi-bin/wiki.pl
% https://github.com/jhallen/joes-sandbox/tree/master/editor-perf

%trends in popularity:
% http://pypl.github.io/IDE.html
%bench? compare efuns vs famous editors:
% https://blog.xinhong.me/post/sublime-text-vs-vscode-vs-atom-performance-dec-2016/

%how to write an editor in less than 1000 LOC (screencast + code)
% http://viewsourcecode.org/snaptoken/kilo/
% http://antirez.com/news/108
%notes on how to write an editor:
% http://ned.rubyforge.org/doc/editor-101.txt
% http://ned.rubyforge.org/doc/editor-102.txt
%Design and implementation of a win32 text editor:
% http://www.catch22.net/tuts/neatpad

\section{Other Emacs-like editors}

Here are a few Emacs clones that I considered for this book,
but which I ultimately discarded:
\begin{itemize}

\item Emacs
%too big, xdisp.c is a single file of 30 000 LOC ... more than the whole
% efuns
%todo: look at emacs lisp manual, and emacs manual to see the concepts though
\l also xemacs

\item Microemacs
% the source of many forks apparently, so maybe the code is cleaner?
% uemacs, one of them, used by torvalds, is 20 000 LOC so not bad

\item Qemacs
% unicode support! complex html/css visualization, multi fonts
% size? 

\item mg
%mg, micro gnu emacs, 20 000 LOC
%http://homepage.boetes.org/software/mg/

\end{itemize}

%other:
% - jed (Pixel and then I were using that one at first on Linux)
% - Rust port of Emacs C part: https://github.com/remacs/remacs

%http://www.jwz.org/doc/emacs-timeline.html
%multics emacs, history and design:
%  http://www.multicians.org/mepap.html


\section{Getting started}

\section{Requirements}

\section{About this document}
#include "principia-latex/About.nw"

\section{Copyright}

Most of this document is actually source code from INRIA, so
those parts are copyright by INRIA.
The prose is mine and is licensed under the \license.

<<copyright header efuns>>=
(***********************************************************************)
(*                                                                     *)
(*                             Efuns                                   *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)
@

\ifallcode
<<copyright header>>=
(***********************************************************************)
(*                                                                     *)
(*                             ____________                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1999 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)
@

<<copyright header2>>=
(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)
@
\fi

\section{Acknowledgments}

I would like to acknowledge of course the author of
[[efuns]], Fabrice Le Fessant, 
who wrote in some sense most of this book.

% Stallman, original author, inspiration of Efuns, nice design.

\chapter{Overview}

\section{Text editor principles}

%history: punch cards, line editor ed (imaginary cursor) (cf wikipedia page)
%Important is can edit! move anywhere, and do backspace!
% As opposed to ed, can actually see the content! and update it
% and get feedback in real-time. wysiwyg!
% screen text editor


% navigating in file (fast, different granularities), random access!
% editing (inserting/deleting/moving/cut-copy-paste/transposing)
% search/replace

% display has a few subtleties: special chars (^M, Tabs), overflow (80 cols)

% efficient keyboard! combination of keys, macros! M-x, C-x o, prefixes.
% everything with keyboard!

% undo! multi steps undo! (TODO redo!) sessions so have also "macro-level" undo
% history! also for position navigation
% multi files/buffers, opening/saving/killing switching
% multi windows (a kind of window manager!) so can see different parts at
%  the same time (but I don't use that much in the end)

% specialised "major" modes: color!, font, indentation, navigating, compile,
%  outline, etc
%todo: semantic editing/visualizing!

% "Emacs is the extensible, customizable, self-documenting real-time
% display editor."

% "everything is a buffer!"
% When I needed to implement a shell/terminal, well
% a lot of what a terminal does is managing input, let user edit
% the line, and this is for free in a buffer! want to move around
% at the end of the line, eol, again, free or have all the building blocks!
% (actually for bol it's more tricky because you don't want to pass the prompt)
% Want completion, can reuse dabbrev! (not as powerful as eshell, but still)
% Also everything is a buffer with a customizable keymap! so can
% have TAB, return, C-a, etc means different things in different modes!

%emacs:
% extensible => open source, external commands
% customizable => configuration file
% self-documenting => not really yet? M-x a bit. Have Efuns.nw though :)

% interactive! M-x! C-h v!
% self discovery (when you type M-x foo, it can tell you which key does that)

% see <actions definitions>, pretty good overview of functionalities

% actions activated by = 
% - keyboard (self insert, keybinding, M-x)
% - mouse (menu, window clicks to quickly navigate)

\section{[[efuns]] interfaces}

\subsection{Command-line interface}

% trivial:
% ./efuns foo.txt

% ./efuns --help for more options
<<constant [[Efuns.usage_str]]>>=
let usage_str =
 "A small editor entirely written in Objective Caml 
by Fabrice LE FESSANT, INRIA Rocquencourt, FRANCE
http://pauillac.inria.fr/efuns
Options:
"
@
% see also *help* buffer

% see also efuns_client later so can cooperate with other programs (e.g. cm)

\subsection{Graphical user interface}

\section{Code organization}

%from guide.txt:

%Internals:
%text.ml: The GAP buffer (self-contained)
%efuns.ml: Types and basic values
 % highly mutually recursive types, but APIs on those types
 % are spread in other files
%main.ml: The main() function ...
%(e)buffer.ml: Functions to handle buffer structures internals
%window.ml: Handling of simulated text windows
%frame.ml: Functions to handle frame structures internals
%top_window.ml: Communication with the Xterm widget
%keymap.ml: Functions to handle keyboard mappings
%minibuffer.ml: Minibuffer functions
%%NOMORE misc.ml: Useful functions
%str2.ml: Addons to the Str module (replace_matched)
%
%Functions:
%simple.ml: Basic functions (insertion, etc ...)
%complex.ml: More complex functions (with minibuffer)
%interactive.ml: Interactive functions handling (M-x)
%abbrevs.ml: Static and Dynamic abbrevs
%system.ml:  Functions to handle external processes
%compile.ml: Functions for error search after compilation
%search.ml: Searchs and replacements
%NOMORE?time.ml: Time functions
%select.ml: Useful functions to ask the user in the minibuffer
%eval.ml: Dynamic load of external modules (Dynlink)
%multi_frames.ml: Handling of multiple text windows in one Xterm widget
%
%parsers.mly: Various useful parsers (/etc/passwd)
%lexers.mll: Various useful lexers (/etc/passwd, filenames)
%
%Major modes:
%ocaml_mode.mll: The Ocaml mode
%?? WHERE? ocamlc.ml:  Functions to read .cmi data from the Ocaml compiler
%?? WHERE?  printtyp.ml: The type pretty printer from the Ocaml compiler
%tex_mode.mll: The TeX mode
%c_mode.mll: The C mode
%lisp_mode.ml: The Lisp mode (is this really useful ? yes, I use GWM as
%  window-manager :)
%html_mode.mll: The HTML mode
%makefile_mode.ml: The Makefile mode (Tabulation)
%
%Minor modes:
%accents_mode.ml: Accents for QWERTY keyboards (e' => é, e'' => e', ...)
%
%Config:
%std_efunsrc.ml: Standard bindings (except those defined in other modules)


\section{Software architecture}

%FIGURE: show top graphical window first! so can see concepts
% of frames/windows, status line, minibuffer (which don't have status lines),
% etc! can actually show 2 windows, so can see 2 status line.

% the Editor (was called Location before) that encapsulates
%  Windows/Frames, with then Buffers, with then Text inside
%
% Event loop with keyboard dispatch to the right action and
% right focused frame, taking itself the frame in parameter
%
% redisplay engine (actually incremental line oriented display)
% triggered after each event (clean_display, handle key, update_display)

% nice archi where an action just have to modify some field such
% as frame.frm_point, and the rest is automatic (recentering, cursor).

%todo: choose between windows or frames term, pro/cons.
% - frames
%   * cons: emacs actually uses this term for different top windows, hmm
%   * pro: 
% - windows
%   * cons: they are not really windows in the traditional sense;
%     they are more tiled automatically windows
%   * pro: other tools like 'sam' use windows for that
% But maybe we can keep both DS, frame and window, in which case
% we use frame for the things related to the display of a window, 
% and window for the things related to subwindows.



\subsection{Trace of a file loading}

% scenario

\subsection{Trace of a line rendering}

% also important is the flow from the text string to the screen:
% data on disk -> 
% text.text_string in memory -> 
% text.text_newlines ->
%   boxes + repr_string to handle special chars ->
% frame.frm_table ->
%   boxes + frm_line that handles overflow lines ->
% screen

\subsection{Trace of a key press}

% event, event loop, keyboard dispatch, 
% try_map, find right map
% action (e.g. RETURN), effect
% rerendering!

% so if do M->, this has for effect to change the point to the end,
% and after the event loop it will trigger a display() for all
% frames that then will realize it needs to redraw itself
% because the point is now far away.

% The cool thing is that the code of M->  just has to care about
% moving a point, the rest is then automatic!

%\section{Bootstrapping}
% how entered code of very first text editor??

\section{Book structure}

% Core DS. Top-down main.
% Bottom up core DS functions. Top-down again UI perspective.




%##############################################################################

\chapter{Core Data Structures}

%toc:
% data = text -> buffer -> frame/window -> top_window -> editor
% control = action -> keymap
% config = var, option, hooks

\section{[[Text.t]]}

% text -> string | (lines -> ... boxes)
% with attrs at different level (text_attr, box_attr)

<<type [[Text.t]]>>=
type t = {
    mutable text_string : bytes;
    mutable text_size : int; (* Bytes.length text.text_string *)

    mutable text_newlines : line array;
    mutable text_nlines : int; (* Array.length text.text_newlines *)

    <<[[Text.t]] gap fields>>
    <<[[Text.t]] history fields>>
    <<[[Text.t]] attribute fields>>
    <<[[Text.t]] other fields>>
  } 
@
%pad: was Text.text before
%less: could put text_attrs also here.
%note: actually text_nlines can be more than text_newlines when start
% to extend the gap buffer

% need line because a text editor is line oriented, column number display,
% line display, lots of things are important to do at line level.

%todo: actually the real question is why you need text_string?
% because the line will not contain the content? they will just
% be indexed over text_string? except for repr_string but this
% is only used as a "cache" for what is displayed on the screen.


<<type [[Text.position]]>>=
type position = int
@
%history: was not used in .ml, was used in .mli and made abstract, but now 
% I use it also in .ml.
%less: could rename charpos too


<<type [[Text.line]]>>=
type line = {
    mutable position : position2; (* bol (beginning of line) *)

    <<[[Text.line]] representation fields>>
    <<[[Text.line]] other fields>>
  } 
@
% position2! see Text.set_position! many apis are taking position!
%  but internally Text manipulates position2
%  but need to delay explanation when will explain the gap
%less: position_user vs position_with_gap? positiong? position_intern? 
% raw_position?
%less: rename position here to bol (because now confusing anyway to
% have position: position2)

%old: was Line.position type
%$<<type Text.direct>>=
%type direct = int
%@
% but can use position above



<<type [[Text.version]]>>=
type version = int
@

<<[[Text.t]] history fields>>=
mutable text_modified : version;
@

<<function [[Text.version]]>>=
let version text = 
  text.text_modified
@
%old: was tree, because of wx_text stuff, but I removed it

%note that this goes up most of the time except when start to
% do some undo operations



%ctor
<<function [[Text.create]]>>=
let create str =
  let newlines = compute_newlines str in
  let attrs = (Array.make (String.length str) direct_attr) in

    {
      text_string = (Bytes.of_string str);
      text_size = String.length str;

      text_newlines = newlines;
      text_nlines = Array.length newlines;

      text_attrs = attrs;

      (* no gap at the beginning *)
      gpoint = { pos = 0; line = 0 };
      gsize = 0;
      text_points = [];

      text_modified = 0;
      text_clean = false;
      text_history = [];
      text_readonly = false;
    }
@
%old: was let rec text, weird
%old: make_text(), but was a noop actually

<<function [[Text.compute_newlines]]>>=
let compute_newlines string =
  let (nbr_newlines,_) = Utils.count_char string '\n' in
  let newlines = Array.make (nbr_newlines + 2) (mk_line_with_pos 0) in
  let curs = ref 0 in
  (* newlines.(0) is already set with 0 position for its bol *)
  for i = 1 to nbr_newlines do
    let pos = String.index_from string !curs '\n' in
    newlines.(i) <- mk_line_with_pos (pos+1);
    curs := pos + 1;
  done;
  newlines.(nbr_newlines+1) <- mk_line_with_pos (String.length string + 1);
  newlines
@
% we Array.create nbr_newlines + 2 because :
% - even if the string has no newline we still need a array[1] at least
% - we count the EOF has its own newline, a sentinel? maybe simpler
%   that way indeed, I remember I had many Commons.line_xxx functions
%   to handle those special cases.
%   For instance in compute_representation one can do:
%     let end_pos = text.text_newlines.(n+1).position - 1 in
%   without being scared of an array out of bound exception
% so an empty file will have first empty line, and then a line with just EOF.

<<function [[Text.nbr_lines]]>>=
let nbr_lines text = 
  text.text_nlines - 2
@


<<function [[Text.mk_line_with_pos]]>>=
let mk_line_with_pos pos = 
  {
   position = pos; 

   boxes = []; 
   repr_string = Bytes.of_string ""; 
   repr_len = 0; 
   line_modified = true; 
  }
@
%pad: I introduced this function; it factorized code
%old: was line_modified = 0, but boolean are better!

%crossref:
% will see those fields later


\section{[[Ebuffer.t]]}

%"The buffer corresponds either to a file (thus to a filename) either to
%a virtual file (for example, compilation messages). The file text itself
%is stored in the Text.t type."

<<type [[Efuns.buffer]]>>=
(* a buffer containing a file content in buffer.buf_text *)
and buffer =
  { 
    mutable buf_text : Text.t;

    (* should be unique; can be used as a primary key in editor.edt_buffers *)
    mutable buf_name : string;
    mutable buf_filename : string option;

    <<[[Efuns.buffer]] position fields>>
    <<[[Efuns.buffer]] history fields>>
    <<[[Efuns.buffer]] other fields>>
  } 
@
% string option because buffers like *Messages* are not connected to a file
% buf_name should be unique, because it's used as a key to
% the editor.edt_buffers hashtbl (see also get_unique_name())

% diff with Text? 
% - have a name, Text is really just the content. 
%   Here it's connected to a file. 
% - it has also a buf_point (and later a frame will have a cursor),
%   see below
% - it has a major mode, minor modes, a keymap, local variables
%   see in next chapters


<<type [[Ebuffer.t]]>>=
type t = Efuns.buffer
@
% Efuns because many DS are mutually recursive, so could not
% put type in separate file like Text.t, but the helper functions
% will be in ebuffer.ml


% point is an important notion!
<<type [[Text.point]]>>=
type point = {
    mutable pos : position2;
    mutable line : int;
}
@
% the first field is a charpos, not a column. The additional .line(was y) is
% to quickly know the line number so can index in the text.text_newlines array
% and do certain stuff.
% Most of the time what you care is really point.pos though.
%old: was point.point and point.point_y but it was confusing as you
% would expect then a point_x which the first field is really not. It's more
% consistent to have point_line. It was also ugly to have point.point
% everywhere and code like let point = point.point. It was confusing
% two notions, a position and a point!

%subtle: this is actually a cursor that is maintained in sync!
% things can change, text can be modified, so the trick is to remember
% all the points/cursors in the text and when you modify the text you update
% all the cursors. We'll see more later about this.
% The line can change too, so again a point needs to be maintained to
% be consistent with the text it references.

<<[[Efuns.buffer]] position fields>>=
mutable buf_point : Text.point;
mutable buf_start : Text.point;
@
% current!
% this will contain the saved value from frm_point
% when switch between buffers; the current frame is a view
% on different buffers, but when you go back to a buffer you
% want the cursor to be at the same position you used to be
% (and the screen start at the same starting point too).
%later: (hence the need for M-x pad-make-indirect-buffer)
%note: it's not really current position fields, it's more saved
% position fields

%FIGURE: with start and current illustration

% there are also a list of points maintained by the Text itself, why?
% because of the gap things can move so you need to update all
% the points. See section on Points later.

<<[[Efuns.buffer]] history fields>>=
mutable buf_modified : int; (* version *)
@
%less: diff with text_modified? seems to be about modification of the
% buffer property itself, not the underlying text


<<function [[Ebuffer.create]]>>=
let create name filename text local_map =
  let name = get_unique_name name in
  let buf =
    { 
      buf_text = text;

      buf_name = name;
      buf_filename = filename;

      buf_point = Text.new_point text;
      buf_start = Text.new_point text;

      buf_last_saved = Text.version text;
      buf_modified = 0;

      buf_map = local_map;

      buf_syntax_table = default_syntax_table;
      buf_map_partial = true;
      buf_vars = Store.new_store ();
      buf_major_mode = fondamental__mode;
      buf_minor_modes = [];

      buf_sync = false;
      buf_mark = None;
      buf_shared = 0;
      buf_finalizers = [];
      buf_history_pos = [||];

      <<[[Ebuffer.create()]] buffer other fields setup>>

    } in
  <<[[Ebuffer.create()]] adjust editor global fields>>
  <<[[Ebuffer.create()]] adjust charreprs>>
  <<[[Ebuffer.create()]] run hooks>>
  buf
@
% buf_shared to 0 at first because not associated with any frame


\section{[[Frame.t]]}

% It's actually not a frame in emacs terminology. hmmm.
% It's really a window, but with not just
%  the geometric info. It packs together geometric info (window type)
%  and buffer info (buffer type)
% The cursor is here! not in the buffer.

% can have different windows/frames over a single buffer.
% convenient so can view different parts of the file at once.
% (even though I prefer make-indirect-buffer to windows)

% "A frame is a text window with a buffer inside."

<<type [[Efuns.frame]]>>=
(* a frame: a view of a buffer for a window *)
and frame  =
  {
    mutable frm_buffer : buffer;

    mutable frm_xpos : int;
    mutable frm_ypos : int;
    
    mutable frm_width : int;
    mutable frm_height : int; (* including status line *)

    <<[[Efuns.frame]] current position fields>>
    <<[[Efuns.frame]] window fields>>
    <<[[Efuns.frame]] decoration fields>>
    <<[[Efuns.frame]] status field>>
    <<[[Efuns.frame]] history fields>>
    <<[[Efuns.frame]] other fields>>
  } 
@
%dead: mutable frm_force_point : bool;
%dead: mutable frm_force_cursor : bool;
%less: coordinates? seems redundant with frm.frm_window info no?
%note: xpos are in line x col dimentions, same for width and height,
% not pixels!
%later: if decide to have variable size fonts we'll have to revisit
% this no? emacs 21 did that?

<<type [[Frame.t]]>>=
type t = Efuns.frame
@

% note that we start to see the pb that the frame/window is a window
% slice over a text, and the file may have more than x col, so we need
% to handle that (hence frm_cut_line and the subtelities about representation)

<<[[Efuns.frame]] current position fields>>=
(* insert point *)
mutable frm_point : Text.point; 
@
% current!
% cursor!
% if you change that in an action, then at the redisplay (end of
% event loop) the screen will move to that place if it's not visible
% => API for actions are simple, just set the position and
% the redisplay will be automatic.


% v_cut_frame | start_command | ... -> <>
<<function [[Frame.create]]>>=
let create window mini buf =
  let frame = create_without_top window mini buf in
  <<[[Frame.create()]] adjust active frame>>
  frame
@

\ifallcode
% for completion, but useful really? -> <>
<<function [[Frame.create_inactive]]>>=
let create_inactive window buf =
  create_without_top window None buf
@
\fi


% Top_window.create | Frame.create | Frame.create_inactive -> <>
<<function [[Frame.create_without_top]]>>=
let create_without_top window mini buf =
  let text = buf.buf_text in

  let frm_start = Text.dup_point text buf.buf_start in
  let point     = Text.dup_point text buf.buf_point in
  let frm_end   = Text.dup_point text buf.buf_start in (* ?? *)

  buf.buf_shared <- buf.buf_shared + 1;

  <<[[Frame.create_without_top()]] let status>>

  let frame =
    { frm_buffer = buf;

      frm_window = window;
      frm_xpos = window.win_xpos;
      frm_ypos = window.win_ypos;
      frm_width = window.win_width;
      frm_height = window.win_height;

      frm_start = frm_start;
      frm_point = point;
      frm_end = frm_end;

      (* this will be set later in set_cursor called from update_display *)
      frm_cursor_x = 0;
      frm_cursor_y = 0;
      frm_cursor = Bytes.make 1 ' ';
      frm_cursor_attr = Text.direct_attr;

      frm_last_text_updated = 0;
      frm_last_buf_updated = 0;

      frm_redraw = true; (* ! *)
      frm_cutline = window.win_width - 1; (* ! *)

      frm_force_start = false;
      frm_x_offset = 0;
      frm_y_offset = 0;
      frm_table = [||];

      frm_has_status_line = 1;
      frm_status = status;
      frm_mini_buffer = mini;
      
      frm_prefix = [];
      frm_last_action = Keymap.dummy_action;

      frm_killed = false;
    } 
  in
  <<[[Frame.create_without_top()]] adjust status of frame>>

  install window frame;
  frame
@
% many many fields ...
% we will see install later, which prepares the frame for display
% by setting frm_table, adjusting frm_cutline if needed.
% less: should rename this install to prepare_for_display
%old:       frm_has_scrollbar = 0;

<<[[Efuns.buffer]] other fields>>=
mutable buf_shared : int; (* number of frames for that buffer *)
@
%less: why need that? ocaml has a gc anyway ...


\section{[[Window.t]]}

% It's a window in Emacs terminology. And it's really
% just the geometry part.

%todo: rename? frame_config? frame_window?

<<type [[Efuns.window]]>>=
and window =
  { 
    mutable win_xpos : int;
    mutable win_ypos : int;

    mutable win_width : int;
    mutable win_height : int; (* including status line *)

    <<[[Efuns.window]] other fields>>
  } 
@

<<type [[Window.t]]>>=
type t = Efuns.window
@

<<[[Efuns.frame]] window fields>>=
mutable frm_window : window;
@
%less: why need that field in frame? frm_xpos not enough?


<<[[Efuns.window]] other fields>>=
mutable win_down : window_down;
mutable win_up : window_up;
@
%subtle: up is to allow access to upper window; it was used
% for access top_location (but now I use a global), but
% I think it's still useful for Window.next to know
% what is up and do things. Also in a multiple toplevel windows
% context, we need that because we can't use
% a single top_window global.
% We will see later than the action type takes a frame as a parameter, and
% so each action must be able from a frame to access all 
% necessary information, hence the win_up field too.

<<type [[Efuns.window_down]]>>=
and window_down =
| WFrame of frame
| NoFrame

| HComb of window * window 
| VComb of window * window
@
%old: was NoFrame of unit

% that's the important part! 

<<type [[Efuns.window_up]]>>=
and window_up =
  Window of window
| TopWindow of top_window
@
% this makes the structures mutually recursive!
% from a top_window -> window and can get back the top_window back

%FIGURE: illustration of how get from frame to window and back
% from window to another frame, or even to the top_window information.
% Window acts as an intermediate.

<<function [[Window.create]]>>=
let create mini up_window xpos ypos width height =
  {
  win_xpos = xpos;
  win_ypos = ypos;

  win_width = width;
  win_height = height;

  win_down = NoFrame; 
  win_up = up_window;

  win_mini = mini;
  }
@
%todo: will see mini later (but seems redundant with frame.frm_mini_buffer?)


\section{[[Top_window.t]]}
%todo: LPize Topwindow in window_up and put it here

%"The top_window structure corresponds to an Xterm widget (one X window).
%From the top_window structure, you have access to text windows (window type)
%displayed inside the Xterm widget. Windows are organized as a binary tree,
%where branchs are either horizontal or vertical combinaisons, and leaves are
%frames (frame window). A frame is a text window with a buffer inside."

% Could merge this in Editors.t, but we may want one day to add back
% the possibility to have multiple top windows related to each other
% through the same efuns instance.


<<type [[Efuns.top_window]]>>=
(* a window containing some frames *)
and top_window = 
  { 
    mutable top_width : int;
    mutable top_height : int; (* including minibuffer line *)

    mutable window : window;

    <<[[Efuns.top_window]] other fields>>
  } 
@
% diff with window? no xpos, ypos here
%old: used to have a top_windows with an 's' but a bit weird,
%  and also to use top_windows where really it's windows,
%  so I renamed this field 'window' even though then it
%  breaks the conventions of having those top_xxx prefix
%less: rename window to windows? after all this window has some win_down

<<type [[Top_window.t]]>>=
type t = Efuns.top_window
@

<<[[Efuns.top_window]] other fields>>=
mutable graphics : Xdraw.graphics_backend option;
@
%(*
%mutable top_root : WX_root.t;
%mutable top_appli : WX_appli.t;
%mutable top_scrollbar : WX_adjust.t;
%mutable top_term : WX_xterm.t;
%top_attrs : WX_xterm.xterm_gc option array;
%*)

<<[[Efuns.top_window]] other fields>>=
mutable top_active_frame : frame;
@
%current!
% so C-x o (C-tab) should change this field
% this will be used for the cursor display too.


<<[[Frame.create()]] adjust active frame>>=
let top_window = Window.top window in
top_window.top_active_frame <- frame;
@
% kill_frame will reset top_active_frame?

<<function [[Window.top]]>>=
let rec top window = 
  match window.win_up with
  | TopWindow top_window -> top_window
  (* recurse *)
  | Window window -> top window
@
%old: was used to access the editor, but
% not sure why you need that since the editor
% is also accessible in the frame and buffer
% Anyway now editor is a global, so you need this function a bit less
%note: since an action takes a frame and many actions have effect
% on the top window, you need this function.



\section{[[Editor.t]]}
% full state

%"All the editor information is organised inside one structure: the location.
%The location grants access to all other structures inside the editor. This
%is done to easily save the editor state after a session (or to move it
%from one editor to another)."
%history: called location in LeFessant's terminology. Why? jocaml ancestry 
% I think. There is a "loc" keyword in jocaml, and efuns was originally a demo
% for jocaml.


%(* the world *)
<<type [[Efuns.editor]]>>=
type editor =
  { 
    (* key is buffer name (made unique via get_unique_name()) *)
    mutable edt_buffers : (string, buffer) Hashtbl.t;
    (* key is filename (should be unique? todo: use realpath?) *)
    mutable edt_files : (string (* filename *), buffer) Hashtbl.t;

    (* list when have one efuns running multiple top windows *)
    mutable top_windows : top_window list;

    (* pwd of efuns when started and then dirname of file of active frame *)
    mutable edt_dirname : string;

    (* general look, configurable via -xxx command line options or .efunsrc 
     * (dimension type is in characters)
     *)
    mutable edt_width : int;
    mutable edt_height : int;

    mutable edt_fg : string;
    mutable edt_bg : string;
    mutable edt_font : string;

    <<[[Efuns.editor]] other fields>>
  } 
@
%old: was called location, and loc_xxx -> edt_xxx now
%old: was loc_windows, but it's really top_windows
%(*loc_vars_table : (string, (Obj.t->string) * (string->Obj.t)) Hashtbl.t;*)  
%dead: mutable loc_counter : int;
%todo: put buffer_order stack here?

% head of list is current?


<<global [[Efuns.global_editor]]>>=
let global_editor = ref None
@
<<function [[Efuns.editor]]>>=
let editor () =
  match !global_editor with
  | None -> failwith "no global editor defined"
  | Some x -> x
@
%old: was called locations (), in reference to jocaml history

%old:
%<<[[Efuns.buffer]] other fields>>=
%(*buf_location : location;*)
%@
%<<[[Efuns.frame]] other fields>>=
%(* mutable frm_location : location; *)
%@
%<<[[Efuns.top_window]] other fields>>=
%(* mutable top_location : location; *)
%@
%old: so can access the global world info from a frame
% but what if location was global, then even easier
% to access global info
%history: I think LeFessant started it as a demo for jocaml, and so
% with migration idea of data, so he could not use
% globals so much, but I don't need jocaml or this feature.

<<[[Ebuffer.create()]] adjust editor global fields>>=
Hashtbl.add (Globals.editor()).edt_buffers name buf;
@
%less: what about edt_files? Ebuffer.create can be passed
% a Some file, in which case we should perhaps modify
% edt_files in Ebuffer.create (instead of doing it in
% the caller each time)



%FIGURE: showing relations between all of that.
% it's a bit complicated because of many fields that
% introduce cycles (mutually recursive data structures, e.g.
% with top_window pointer, with map with action),
% so does not only go down, it also can go back up.
% but maybe can restrict to the down path.

% note that it's hard to remove the recursion.
% For instance the keybinding have an action which takes a frame
% as a parameter, so bindings and frames are mutually recursive, as
% well as with buffer, window, and even top_window we
% need to go up sometimes. and a top window needs to know
% the active frame.



% sometimes have the buffer and want to find the frame
% (opposite of frame.frm_buffer)

% next_error | ??? -> <>
<<function [[Frame.find_buffer_frame]]>>=
let find_buffer_frame buf =
  try
    (Globals.editor()).top_windows |> List.iter (fun top_window ->
      top_window.window |> Window.iter (fun frame -> 
        if Common.phys_equal frame.frm_buffer buf 
        then raise (FoundFrame frame)
      )
    );
    raise Not_found
  with FoundFrame frame -> frame
@

<<exception [[Frame.FoundFrame]]>>=
exception FoundFrame of frame
@

%ex:
%<<function Select.find_completion_frame>>=
%let find_completion_frame frame =
%  let buf = Ebuffer.default "*Completions*" in
%  Frame.find_buffer_frame buf
%@
%but really it should be 
%  buf_name -> buffer -> frame
% with find_buffer_opt

\section{[[Action.t]]}

%trans:
% Have seen the data mostly: editor, frame, buffer, text.
% Now how modify all of that? The control?

<<type [[Efuns.action]]>>=
and action = frame -> unit
@
% Is abstract in the .mli.
% This actually causes many types to be mutually recursive, 
% because the keyboard handling stuff depends on frame and buffers
% and vice versa.
%less: could instead use a string here? that would remove
% some mutual recursivity, and may also help for other things
% such as -debug, or the 'lastcmd' trick, but it would be less typed!
%note: it will be the active frame, the one with the cursor

<<type [[Action.t]]>>=
type t = Efuns.action
@

% actions will be called from the keyboard event dispatcher.
% the only thing passed is the frame/window where the event
% occured (the active frame with the cursor), but sometimes an action
% then need to have global
% effects (in which case it can use editor()), or the upper
% frames/windows, which means we need from the frame to be able
% to access lots of information, hence the introduction of
% certain fields in the frame data structure.
% update: actually can now use editor global.

<<type [[Efuns.generic_action]]>>=
and generic_action =
| FrameAction of action
| BufferAction of (buffer -> unit)
@
%less: really need this BufferAction subtelity?
% We need a buffer action when something is done only once, e.g.
% setting up the major mode is a buffer operation and buffer property!
% A frame is more temporary.

<<function [[Keymap.dummy_action]]>>=
let dummy_action _frame = () 
@

\subsection{Action name}
\l can maybe now move with call interactive section?
%note: but maybe it's important to present early because this is useful for
% some hooks that are defined as options, for the configurable menu,
% and because M-x is a pretty important concept in Emacs.

<<type [[Efuns.action_name]]>>=
and action_name = string
@
%pad: I introduced this type

<<global [[Efuns.actions]]>>=
let (actions : (action_name, generic_action) Hashtbl.t) = 
  Hashtbl.create 63
@
% global!!
% for M-x! and also so can use string in menus/keybinding in config file/mouse
%less: rename generic_actions then?

% A bit annoying, but ocaml is not a dynamic language with
% eval string, so we have to do that. Fortunately recent OCaml have
% attributes that allows some easy metaprogramming forms.
%note: adding a @@interactive@@ requires to teach about ppx
% and this might make the porting to plan9 more difficult, but I can
% just remove them too; Most things would still work (just not M-x).


<<function [[Efuns.define_action]]>>=
let define_action action_name action_fun =
  <<sanity check action defined twice>>
  Hashtbl.add actions action_name (FrameAction action_fun)
@

<<function [[Efuns.define_buffer_action]]>>=
let define_buffer_action action_name action_fun =
  <<sanity check action defined twice>>
  Hashtbl.add actions action_name (BufferAction action_fun)
@
%less: worth it now that I have @@interactive? some exec_named_buf_hooks
%  expect a BufferAction


<<sanity check action defined twice>>=
(try 
    Hashtbl.find actions action_name |> ignore;
    Error.error (spf "action \"%s\" defined twice" action_name);
 with _ -> ()
);
@
%old: had a separate print_newline() but useless I think

%<<constant Efuns.no_action>>=
%let no_action = BufferAction (fun _ -> ())
%@
<<function [[Efuns.get_action]]>>=
let get_action action_name =
  try Hashtbl.find actions action_name
  with Not_found ->
    Error.error_exn (spf "Could not find action %s. Forgot define_action()?" 
        action_name) Not_found;
    BufferAction (fun _ -> ())
@
%pad: action -> action_name for the parameter

% ?? -> <> who will dispatch and know which frame?
% string -> ocaml code
<<function [[Efuns.execute_action]]>>=
let execute_action action_name = 
  match (get_action action_name) with
  | FrameAction f -> f 
  | BufferAction f -> (fun frame -> f frame.frm_buffer)
@
%note: it used to be let execute_action action frame = ...
% but then with that execute action return a closure each time,
% and then we can't in -debug find the action_name corresponding
% to an action in try_map, hence my rewrite.

\ifallcode
% exec_named_buf_hooks -> <>
<<function [[Efuns.execute_buffer_action]]>>=
let execute_buffer_action action_name buf =
  match (get_action action_name) with
    BufferAction f -> f buf
  | FrameAction _f -> 
      Error.error (spf "Can't apply action %s on buffer" action_name)
@
\fi




%old: many of the standard actions were defined in std_efunsrc.ml
% <<toplevel [[Config]] actions definitions>>=
% let _ =
%  <<actions definitions>>
%  ()
% @
% <<actions definitions>>=
% (* ----------------------------------------------------------- *)
% (* Loading *)
% (* ----------------------------------------------------------- *)
% <loading actions>
% (* ----------------------------------------------------------- *)
% (* Navigating (in the file) *)
% (* ----------------------------------------------------------- *)
% <<navigating actions>>
% (* ----------------------------------------------------------- *)
% (* Editing *)
% (* ----------------------------------------------------------- *)
% (* ------------------------- *)
% (* Inserting *)
% (* ------------------------- *)
% <<inserting actions>>
% (* ------------------------- *)
% (* Deleting *)
% (* ------------------------- *)
% <deleting actions>
% (* ------------------------- *)
% (* Moving (Cut, copy, paste) *)
% (* ------------------------- *)
% <<moving actions>>
% (* ------------------------- *)
% (* Transforming *)
% (* ------------------------- *)
% <<transforming actions>>
% (* ------------------------- *)
% (* Replacing *)
% (* ------------------------- *)
% <replacing actions>
% (* ----------------------------------------------------------- *)
% (* Searching *)
% (* ----------------------------------------------------------- *)
% <<searching actions>>
% (* ----------------------------------------------------------- *)
% (* Undoing *)
% (* ----------------------------------------------------------- *)
% <<undoing actions>>
% (* ----------------------------------------------------------- *)
% (* External commands *)
% (* ----------------------------------------------------------- *)
% <external command actions>
% (* ----------------------------------------------------------- *)
% (* Buffers/windows/frames *)
% (* ----------------------------------------------------------- *)
% <<buffer management actions>>
% <<buffer navigating actions>>
% <<frame management actions>>
% <<frame navigation actions>>
% (* ----------------------------------------------------------- *)
% (* Meta *)
% (* ----------------------------------------------------------- *)
% <<meta actions>>
% (* ----------------------------------------------------------- *)
% (* Saving *)
% (* ----------------------------------------------------------- *)
% <saving actions>
% (* ----------------------------------------------------------- *)
% (* Major mode *)
% (* ----------------------------------------------------------- *)
% <<major mode actions>>
% (* ----------------------------------------------------------- *)
% (* Misc *)
% (* ----------------------------------------------------------- *)
% <<misc actions>>
% @
% <<misc actions>>=
% define_action "revert_buffer" Complexe.reload;
% 
% define_action "open_display" Complexe.open_display;
% define_action "change_font"  Complexe.change_font;
% @  
% %(*  define_action "load_library" load_library;*)
%pad: I introduced the sections above, but in the end they duplicate what
% I already do for the keybindings, so better to have sections only for that
%alt:
% - all actions in std_efunsrc.ml, but then lack of cohesion
% - major actions in std_efunsrc.ml, but then inconsistent
% - spread in appropriate files (that's what I was doing for my major modes)
% - get rid of those; Actions are really just needed for functions we want
%   to call from M-x really, but this could be done via an attribute
%   (e.g., @@interactive@@). Moreover, you were still required to also
%   populate interactives_map if the function was not bound to a key
%   (because Keymap.add_global_key was also adding in the .interactives field



\section{[[Keymap.t]]}

%trans:
% have seen ocaml code corresponding to actions
% but how trigger those actions? via keyboard! binding!


% keyboard handling is important for an editor!
% different possibilities:
%  - emacs spirit: combos, prefix maps, minibuffer for multi entries
%  - vi spirit: modes
%  - sam spirit: the mouse ...

%less: mv stuff in Keyboard section? what is necessary to see before?

% like for variables that we will see after, have different maps for
% different "scopes":
% - global
% - major mode
% - minor mode
% - buffer itself (useful for dynamic setting of keys e.g. C-g in minibuffer)
%
% good so that each mode can redefine bindings! specialized mode!
% specialized keys! For instance when TAB to offer completion
% in minibuffer mode, or semantic completion in C buffer, or just
% insert a TAB in makefile mode.


<<type [[Efuns.map]]>>=
type map =
  { 
    (* 256 array, one character simple key = one action *)
    char_map : binding array;
    (* complex key, possible sub maps *)
    mutable complex_bindings : (key * binding) list;
  } 
@
%old: <<[[Efuns.map]] other fields>>

% char_map is essentially an optimisation, so that simple key
% dispatching goes quickly

<<type [[Keymap.t]]>>=
type t = Efuns.map
@

<<type [[Efuns.key]]>>=
and key = mod_ident * keySym
@

<<type [[Efuns.mod_ident]]>>=
and mod_ident = 
  NormalMap
| ControlMap
| MetaMap
| ControlMetaMap
@
% enough I think

%(*Xtypes.*)
<<type [[Efuns.keySym]]>>=
and keySym = int
@
% keySym = int (could be a Rune in plan9!)



<<type [[Efuns.keys]]>>=
and keys = key list
@


<<type [[Efuns.binding]]>>=
and binding = 
  Function of action
| Prefix of map
| Unbound
@
% mutually recursive type! find map again

%less: need Prefix? could just each time gives the full list?
% or it's convenient if want to rebind a big set of keys to another
% prefix?

<<function [[Keymap.create]]>>=
let create () =
  { char_map = Array.make 256 Unbound;
    complex_bindings = [];
  } 
@
%old:    interactives = [];
% not sure it's useful to have different interactives, one global,
% one for the buffer, and one for the major and minor. Simpler to have
% them just in a global (which we already have: actions hashtbl)

<<[[Efuns.buffer]] other fields>>=
buf_map : map;
@

<<[[Efuns.editor]] other fields>>=
edt_map : map;
@
% will see 2 other maps later, for major and minor modes.

<<function [[Ebuffer.get_binding]]>>=
let get_binding buf keylist =
  let binding = ref Unbound in
  try
    <<[[Ebuffer.get_binding()]] minor mode key search>>
    <<[[Ebuffer.get_binding()]] major mode key search>>
    (let b = Keymap.get_binding buf.buf_map keylist in
      match b with
      | Prefix _map -> binding := b;
      | Function _f -> binding := b; raise Exit
      | Unbound -> ()
    );
    <<[[Ebuffer.get_binding()]] if partial map>>
    !binding
  with Exit -> !binding
@
%crossref: see Keymap.get_binding later *)
%less: there is no loop, so why need this Exit trick? to bypass
% the partial map thing?

%\section{Partial maps}
<<[[Efuns.buffer]] other fields>>=
mutable buf_map_partial : bool;
@
% but always true no?
<<[[Ebuffer.get_binding()]] if partial map>>=
if buf.buf_map_partial then
  (let b = Keymap.get_binding (Globals.editor()).edt_map keylist in
    match b with
    | Prefix _map -> binding := b;
    | Function _f -> binding := b; raise Exit
    | Unbound -> ()
  );
@


<<function [[Keymap.add_global_key]]>>=
let add_global_key prefix action =
  add_binding (Globals.editor()).edt_map prefix action
@
%old:  interactive (Globals.editor()).edt_map prefix string action

%crossref: see Keymap.add_binding later *)

<<function [[Keymap.add_local_key]]>>=
let add_local_key buf prefix action = 
  add_binding buf.buf_map prefix action
@
%old: interactive buf.buf_map 

% each major mode can also use that to offer a specialized experience!
% (or use add_major_key).
% what about add_major_key? add_minor_key? will see later.


%old:
% add_local_key | add_global_key | add_major_key | add_minor_key -> <>?
% <<function [[Keymap.interactive]]>>=
% let interactive map =
%  fun keylist name f ->
%   <<[[Keymap.interactive()]] add keylist and name to interactives list>>
%   add_binding map keylist f
% @
%pad: there was too many ways to define key:
% add_binding, add_global_key, interactive, etc. I simplified.



\subsection{Configurable keymap}

%todo: move that later now
<<constant [[Config.global_map]]>>=
let global_map = define_option ["global_map"] "" 
  (list_option Keymap.binding_option) []
@

<<constant [[Simple.binding_option]]>>=
let binding_option = 
  Options.tuple2_option (Options.smalllist_option key_option, 
                         Options.string_option)
@
<<constant [[Simple.key_option]]>>=
let key_option = Options.define_type "Key" value_to_key key_to_value
@
% see configuration file library in appendix

%old:
% <<toplevel [[Config]] global map settings>>=
% let _ = 
%   if !!global_map = [] then begin
%       global_map =:= [
%         <<[[global_map]] initial entries>>
%       ]
%     end;
%   <<[[Config.toplevel]] set [[interactives_map]]>>
% @


% main -> Efuns.init -> List.iter f start_hooks -> <> 
%  (as ?? ?<- add_start_hook(<>) <- Config._5)
<<function [[Config.init_global_map]]>>=
let init_global_map () = 
  if !!global_map = [] 
  then 
    (core_map @ standard_map) |> List.iter (fun (keys, action) ->
        Keymap.add_global_key keys action
    )
  else 
  !!global_map |> List.iter (fun (keys, action) ->
      try
        Keymap.add_global_key keys (Action.execute_action action)
      with e ->
        Log.printf "Error for action %s" action;
        Log.exn "%s\n" e;
  );

  (* Mouse *)
  <<[[Config.init_global_map()]] mouse keys setup>>
  ()
@

\subsection{Standard Emacs/Efuns keymap}

% a few important keys

%\section{[[C-x]]}
<<constant [[Keymap.c_x]]>>=
let c_x = (ControlMap, Char.code 'x')
@
% e.g. C-x C-f
%\section{[[C-c]]}
<<constant [[Keymap.c_c]]>>=
let c_c = (ControlMap, Char.code 'c')
@
% for major mode, e.g. C-c C-c to compile
%\section{[[C-h]]}
<<constant [[Keymap.c_h]]>>=
let c_h = (ControlMap, Char.code 'h')
@
% for help

<<constant [[standard_map]]>>=
let standard_map = [
  <<[[standard_map]] entries>>
] 
@
%pad: I introduced that. It used to be in global_map, which
% was an Option (can be set in a .efunsrc config file)

<<[[standard_map]] entries>>=
(* -------------------------------------------------------- *)
(* Loading *)
(* -------------------------------------------------------- *)
<<loading keys>>

(* -------------------------------------------------------- *)
(* Navigating (in the file) *)
(* -------------------------------------------------------- *)
<<navigating keys>>

(* -------------------------------------------------------- *)
(* Editing *)
(* -------------------------------------------------------- *)

(* ------------- *)
(* Inserting *)
(* ------------- *)
(* see also the many self_insert_xxx in core_map *)
<<inserting keys>>
(* ------------- *)
(* Deleting *)
(* ------------- *)
<<deleting keys>>
(* ------------------------------ *)
(* Moving (Cut, copy, paste) *)
(* ------------------------------ *)
<<moving keys>>
(* ---------------------- *)
(* Transforming *)
(* ---------------------- *)
<<transforming keys>>

(* -------------------------------------------------------- *)
(* Search/replace *)
(* -------------------------------------------------------- *)
<<searching keys>>
<<replacing keys>>

(* -------------------------------------------------------- *)
(* Undoing *)
(* -------------------------------------------------------- *)
<<undoing keys>>

(* -------------------------------------------------------- *)
(* External commands *)
(* -------------------------------------------------------- *)
<<external commands keys>>

(* -------------------------------------------------------- *)
(* Buffers/windows/frames *)
(* -------------------------------------------------------- *)
<<buffer management keys>>
<<buffer navigating keys>>
<<frame management keys>>
<<frame navigation keys>>

(* -------------------------------------------------------- *)
(* Meta *)
(* -------------------------------------------------------- *)
<<meta keys>>

(* -------------------------------------------------------- *)
(* Saving *)
(* -------------------------------------------------------- *)
<<saving keys>>

(* -------------------------------------------------------- *)
(* Rectangles *)
(* -------------------------------------------------------- *)
[c_x; NormalMap, Char.code 'r'; NormalMap, Char.code 't'],
  Rectangle.rectangle_insert;
[c_x; NormalMap, Char.code 'r'; NormalMap, Char.code 'k'],
  Rectangle.rectangle_kill;

(* -------------------------------------------------------- *)
(* Compile/grep *)
(* -------------------------------------------------------- *)

(* -------------------------------------------------------- *)
(* Macros *)
(* -------------------------------------------------------- *)
[c_x; NormalMap, Char.code '('], Macros.start_macro;
[c_x; NormalMap, Char.code ')'], Macros.end_macro;
[c_x; NormalMap, Char.code 'e'], Macros.call_macro;

(* -------------------------------------------------------- *)
(* Misc *)
(* -------------------------------------------------------- *)
<<misc keys>>
@


\section{[[Var.t]]}

% polymorphic typed variables in the same store!
% trick using phantom types. See appendix (or put more of store.ml here?)

% Moreover the same variable can be looked in different stores.
% The trick is that you need to have an intermediate type that
% designs a variable symbolically which can refer to a global store,
% or buffer local store, or major mode store. So you need an 
% intermediate! They use indeed a "string" to store the name of
% the variable symbolically. Could be also a gensym.

% why need variables in emacs? to configure things! e.g. level
% of indentation for this major mode. You can overwrite also
% global settings. Configurable editor! Easy way to add
% properties to buffers. Otherwise we would have to have
% a huge efuns.ml with too many fields in buffer, frame, etc.

<<type [[Var.t]]>>=
type 'a t = 'a Store.var
@

<<[[Efuns.buffer]] other fields>>=
mutable buf_vars : Store.t;
@
% Note that no 'a here! And can contain variables with different type!
% And can still be typesafe! Magic! (in fact there is some use of 
% Obj.magic)

<<[[Efuns.editor]] other fields>>=
edt_vars : Store.t;
@

% different scopes again:
% - global
% - buffer
% - major mode
% - minor mode

<<function [[Var.set_global]]>>=
let set_global var value = 
  Store.set (Globals.editor()).edt_vars var value
@
<<function [[Var.set_local]]>>=
let set_local buf var value = 
  Store.set buf.buf_vars var value
@

<<function [[Var.get_global]]>>=
let get_global var = 
  Store.get (editor()).edt_vars var
@
%todo: put the type of the .mli here? subtle signature. polymorphic vars!
\t why want to use get_global? get_var should be the way to go always no?

<<function [[Var.get_local]]>>=
let get_local buf var = 
  Store.get buf.buf_vars var
@
% why want that? get_var should be the way to go

% buffer -> major -> minors -> global
<<function [[Var.get_var]]>>=
let get_var buf var = 
  try 
    Store.get buf.buf_vars var 
  with Not_found ->
    try 
      <<[[Var.get_var()]] try with major mode variables>>
    with Not_found ->
      try 
        <<[[Var.get_var()]] try with minor mode variables>>
      with Not_found ->
        Store.get (editor()).edt_vars var
@

% was not there originally
<<misc keys>>=
[c_h; NormalMap, Char.code 'v'], Interactive.describe_variable;
@

% can't understand yet everything (so move it later??)
% but this is an action! it takes a frame!
<<function [[Complex.get_variable]]>>=
let describe_variable frame = 
  Select.select frame "get_variable : " variable_hist "" 
    (all_variables frame)
    (fun s -> s) 
    (fun variable ->
      Top_window.mini_message frame 
        (Printf.sprintf "%s : %s" variable (
          let buf = frame.frm_buffer in
          try
            Store.print buf.buf_vars variable
          with _ ->
            Store.print (Globals.editor()).edt_vars variable)))
[@@interactive]
@
%old:
% <<misc actions>>=
% define_action "describe_variable"  Complexe.describe_variable;
% @

%old: was called get_variable
%crossref: will see Select far later.
%todo: use get_var instead of this Store.print thing?

<<constant [[Complex.variable_hist]]>>=
let variable_hist = ref []
@

\section{[[Option.t]]}

% This is used when you want something to be set in a config file.
% Use of !!. See the code to manage global_map before.

\section{Hooks}
% essentially a set of list refs

% different kind of hooks:
% - variable hook, below, use variables that we've just seen above.
% - startup hooks (add_start_hook() and start_hooks[] and Efuns.init())
%    will see in main chapter.
% - named hooks, for frame a buffer actions, so take a string (action name)
%   for parameter. why not does not take the action function directly?
%   because want to possibly save such hooks configuration in a file 
%   (meh?)

% again, configurable editor spirit so hooks to customize things,
% place where you can plug a customization at certain code points

\subsection{Variable hooks}

<<function [[Efuns.exec_hooks]]>>=
let exec_hooks hooks arg =
  hooks |> List.iter (fun f ->
    try f arg 
    with exn -> 
     (* less: could be nice to give names to hooks *)
     Error.error_exn  "exn in hook" exn
  )
@

<<function [[Efuns.add_hook]]>>=
let add_hook hook_var hook =
  let tail = try Var.get_global hook_var with _ -> [] in
  Var.set_global hook_var (hook :: tail)
@
\t why get_global? why not get_var so it can be altered? but then
\t  alter which store?


%example:
% of a hook var. What is the type of create_buf_hook? and get_global below?
<<constant [[Ebuffer.create_buf_hook]]>>=
let create_buf_hook = Store.create_abstr "create_buf_hook"
@
%less: remame create_buffer_hooks? more consistent?
% of use of this hook var
<<[[Ebuffer.create()]] run hooks>>=
let hooks = try Var.get_global create_buf_hook with Not_found -> [] in
Hooks.exec_hooks hooks buf;
@
% will be set to set_buffer_mode, which use the alist to automatically
% set the major mode!

% Why duplicate varname in string? It's for error message
% when try to retrieve the content of a variable? 

\subsection{Named action hooks}
% named so can be put in configuration file

<<function [[Frame.exec_named_hooks]]>>=
let exec_named_hooks hooks frame =
  hooks |> List.rev |> List.iter (fun action_name -> 
   try Action.execute_action action_name frame with _ -> ()
  )
@
%<<function Frame.exec_named_hooks_with_abort>>=
%(*
%let rec exec_named_hooks_with_abort hooks frame =
%  match hooks with
%    [] -> ()
%  | action :: hooks ->
%      exec_named_hooks_with_abort hooks frame;
%      execute_action action frame
%*)
%@

%example:
<<constant [[Frame.change_buffer_hooks]]>>=
let change_buffer_hooks = define_option ["change_buffer_hooks"] "" 
    (list_option string_option)
  [ "check_file" ]
@
% each time buffer change! -> <>

%old:
% <<misc actions>>=
% define_action "check_file" Complexe.check_file;
% @

%will see later this function, but it checks if the file needs
%to be reloaded (but really we should do that before each keystroke)

% ?? -> <>
<<function [[Ebuffer.exec_named_buf_hooks]]>>=
let exec_named_buf_hooks hooks frame =
  hooks |> List.rev |> List.iter (fun action_name ->
    try Action.execute_buffer_action action_name frame 
    with exn -> Error.error_exn "exec_named_buf_hooks" exn
  )
@

% ?? -> <>
<<function [[Ebuffer.exec_named_buf_hooks_with_abort]]>>=
let exec_named_buf_hooks_with_abort hooks frame =
  hooks |> List.rev |> List.iter (fun action_name ->
    Action.execute_buffer_action action_name frame
 )
@
% no try here

%example:
<<constant [[Ebuffer.save_buffer_hooks]]>>=
let save_buffer_hooks = define_option ["save_buffer_hooks"] "" 
    (list_option string_option)
  [ ]
@
% Here an Option.t, but it's better to use a Var.t for that

\subsection{Startup hooks}

% will see them soon, below.





\chapter{[[main()]]}

% there are actually no really main() in ocaml, instead
% a list of toplevels doing stuff (in the order of the linking)
%pad: but I reorganizeded the code to gather stuff in a main(), more readable.

<<toplevel [[Main]] call [[main()]]>>=
let _ =
  UCommon.main_boilerplate (fun () ->
(*
    let r = Gc.get () in
    r.Gc.verbose <- true;
    Gc.set r;
*)
    main () 
  )
@
\l remove Common.main_boilerplate for explanation? 
% provides good services? -profile at least.


% init files are not the .efunsrc, but the first set of files to open
% so when do efuns foo.c => init_files = ref ["foo.c"]
<<constant [[Efuns.init_files]]>>=
let initial_files = ref []
@
% should be used in Graphic.init
% efuns is a multi-file editor!

<<function [[Main.main]]>>=
let main () =
  <<[[main()]] set signal handlers>>
  Arg.parse ([
    <<[[main()]] command line options>>
   ] 
   (* @  Common2.cmdline_flags_devel () *)
   )

   (fun name -> initial_files := name :: !initial_files) 
   usage_str;

  Logs.info (fun m -> m "logging enabled");

  <<[[main()]] set options>>

  <<[[main()]] initial editor>>
  <<[[main()]] initialize the world>>
  <<[[main()]] misc initializations>>

  <<[[main()]] run the UI>>
  ()
@
% Common2.cmdline_flags_devel for -profile?



\section{Configuration file: [[.efunsrc]]}
% .efuns rc (but can be read as .efun src, so rename?)

<<[[main()]] set options>>=
<<[[main()]] set options filename>>
<<[[main()]] adjust options>>
@


% see appendix on configuration file library
<<[[main()]] set options filename>>=
Options.filename := 
  (try Utils.find_in_path (Utils.homedir :: !!Globals.load_path) ".efunsrc" 
   with _ -> Filename.concat Utils.homedir ".efunsrc"
  );
(try Options.load () 
 with exn -> Error.error_exn "init error" exn
);
@
%todo: Right now Options.init is a todo; it should call load() which
% is using Options.filename


<<function [[Config.save_options]]>>=
let save_options _frame = 
  Options.save ()
[@@interactive]
@
%old:
% <<misc actions>>=
% define_action "save_options" save_options;
% @



%<<constant Efuns.no_init>>=
%let no_init = ref false
%@
%% dead?
%<<[[main()]] command line options>>=
%  "-q", Arg.Set no_init,": Don't load init files";
%@
% can be useful; I use that with Emacs, but because my .emacs
%  is huge


%\section{General style parameters}
 
<<constants Main options>>=
(* old: I used to enforce 80, but many people sometimes write in col 80
 * so simpler go a little bit above
 *)
let width      = define_option ["width"] "" int_option 82
let height     = define_option ["height"] "" int_option 44
let foreground = define_option ["foreground"] "" string_option "wheat"
let background = define_option ["background"] "" string_option "DarkSlateGray"
@
%pad: was 25 for height, white, and black
%<<constant Efuns.height>>=
%let height = ref 27
%@
%redundant?

% Note that this is done at the toplevel, so this is executed even before
% we had the change the process the possible .efunsrc file, so how can it work?
% Because define_option does not compute anything? It's at the use time
% with !! that things get done? 
% Nope. There is a default value so any access to those options with !!
% before the Options.init will return the default value.

% used in some major modes
<<constant [[Efuns.font]]>>=
let font = define_option ["font"] "" string_option "Monospace 20"
@
%pad: was fixed; I've found different good fonts for Linux, macOS, and Windows

\section{Arguments processing}

<<constants [[Main.xxx_opt]]>>=
let width_opt   = ref None
let height_opt  = ref None
let fg_opt      = ref None
let bg_opt      = ref None
let font_opt    = ref None
@

<<[[main()]] command line options>>=
"-width"  , Arg.Int (fun i -> width_opt := Some i), "<len>: Width in chars";
"-height" , Arg.Int (fun i -> height_opt := Some i), "<len>: Height in chars";
"-fg"     , Arg.String(fun s -> fg_opt := Some s), "<color>: Foreground color";
"-bg"     , Arg.String(fun s -> bg_opt := Some s), "<color>: Background color";
"-font"   , Arg.String(fun s -> font_opt := Some s), "<font>: Font name";
@
% gymnastic with intermediate xxx_opt because options filename
% is set later because need first to process load_path
% but then once load the value we could possibly have overwritten
% the values passed by the command line, hence this intermediate

<<[[main()]] adjust options>>=
(match !width_opt  with None -> () | Some color -> width =:= color);
(match !height_opt with None -> () | Some color -> height =:= color);
(match !fg_opt     with None -> () | Some color -> foreground =:= color);
(match !bg_opt     with None -> () | Some color -> background =:= color);
(match !font_opt   with None -> () | Some color -> Globals.font =:= color);
@
% could use Common.do_option


<<global [[Efuns.displayname]]>>=
let displayname = ref ""
@
% for ipc/server too

%dead: X11. I now use Wayland, and even Gtk under X11 does not explose
% the management of $DISPLAY to the program.
% <<[[main()]] command line options>>=
% "-d",        Arg.String(fun s -> Globals.displayname := s),
% " <dpy>: Name of display";
% "--display", Arg.String(fun s -> Globals.displayname := s),
% " <dpy>: Name of display";
% @


<<constant [[Efuns.check]]>>=
let check = ref false
@
<<[[main()]] command line options>>=
"-check", Arg.Set Globals.check, ": only for testing";
@
%dead?
% (*    "-c", Arg.String Dyneval.compile,"<file.ml>: compile file";*)



\section{The default [[editor]]}

<<[[main()]] initial editor>>=
let editor = { Efuns.
    edt_buffers = Hashtbl.create 13;
    edt_files = Hashtbl.create 13;

    top_windows = [];

    edt_width = !!width;
    edt_height = !!height;
    edt_fg = !!foreground;
    edt_bg = !!background;
    edt_font = !!Globals.font;

    edt_map = Keymap.create ();
    edt_dirname = Sys.getcwd ();

    edt_vars = Store.new_store ();
    
    edt_colors_names = Array.make 256 "";
    edt_colors = Hashtbl.create 37;
    edt_colors_n = 0;

    edt_fonts_names = Array.make 256 "";
    edt_fonts = Hashtbl.create 37;
    edt_fonts_n = 0;

    edt_mutex = Mutex.create ()
} in
@
%less: need those edt_fonts_xxx and edt_colors_xxx?
%256 because of make_attr() that uses 8 bits for the colors or the fonts.

\section{Startup hooks}
% hooks on editor creation, hence they take an editor in parameter

<<[[main()]] initialize the world>>=
init_efuns editor (* launch first hooks *);
@

% not that this function reset also the start_hooks global!
%  so that can run it again later, if other hooks are setup later
%  (e.g. in the .efunsrc loading)
% main -> <>
<<function [[Efuns.init]]>>=
let init_efuns editor =
  Globals.global_editor := Some editor;
  let hooks = List.rev !Hooks.start_hooks in
  Hooks.start_hooks := [];
  hooks |> List.iter (fun f -> f ())

@
% List.rev because add_hooks add in head, see below
%old: used to be in efuns.ml, but better in main.ml


% init_efuns -> <> (as f <- List.iter hooks <- let hooks = <>)
<<constant [[Efuns.start_hooks]]>>=
(* Les hooks de lancement apres le chargement d'un module *)
let start_hooks = (ref []: (unit -> unit) list ref)
@
%less: private? rename _start_hooks?

<<function [[Efuns.add_start_hook]]>>=
let add_start_hook hook = 
  start_hooks := hook :: !start_hooks
@



<<toplevel [[Config]] starting hook>>=
let _ =
  Hooks.add_start_hook (fun () ->
    <<[[Config._5]] start hooks options>>
    init_global_map ();
    Hooks.add_hook Top_window.handle_key_start_hook Misc_features.check_file;
  )
@

\section{The graphical top window}

<<[[main()]] run the UI>>=
Graphics_efuns.init !initial_files;
@
%less: could just take ()


<<function [[Efuns.backend]]>>=
let backend top_window =
  match top_window.graphics with
    None -> raise Not_found
  | Some x -> x
@

\subsection{[[Graphics.init()]]}

% this is the not portable part!
% but it looks approximately like that:

% <<function Graphics_efuns.init>>=
%  Graphics_xxx.open_graphics
%  ...
%  let top_window = Top_window.create display in
%  ...
%  top_window.graphics <- Some (backend Graphic_xxx.context ...); 
%  ...
%  Top_window.update_display ();
%  ...
%  event loop
%    ...
%    Top_window.handler top_window () evt
%    ...
% @
% where the handler also call at some point Top_window.update_display;

% will see main functions called from init below

\subsection{[[Top_window.create()]]}

% main -> Graphics_efuns.init -> <>
<<function [[Top_window.create]]>>=
let create () =
  let edt = Globals.editor() in
  let buf = Ebuffer.default "*help*" in
  (* keep one line for the minibuffer, hence the -1 *)
  let window = Window.create_at_top  0 0 edt.edt_width (edt.edt_height - 1) in
  let frame = Frame.create_without_top window None buf in
  let top_window =
    { 
      top_width = edt.edt_width;
      top_height = edt.edt_height;
      window = window;
      top_active_frame = frame;

      top_name = buf.buf_name;

      top_mini_buffers = [];
      top_second_cursor = None;

      graphics = None;
    } 
  in

  (* adjust what Window.create_at_top could not do *)
  frame.frm_window.win_up <- TopWindow top_window;
  edt.top_windows <- top_window :: edt.top_windows;

  top_window
@
%old: was "window" instead of buf.buf_name but more consistent to use buf_name
%note: a few notes:
% - top_active_frame!
% - edt_height -1 for the minibuffer.
% - top_mini_buffers is empty at first, the minibuffer is created
%   on the fly when do M-x, but before that it does not really
%    exist (hmm what about Top_window.message() though?)
% - we use create_without_top() because mutually recursive :) we need
%   an active frame to create a top_window, and we need a top_window
%   for from.frm_window.win_up.
%old: this used to contain far more graphical stuff, but I've
% extracted it from it and moved instead in Graphics_efuns.init()
%todo:? redundant to have window? with top_active_frame.frm_window no?
% no because a nested frame could have the focus, but we want in display
% to iter from the top window.
%todo: window_at_top vs frame.create_without_top, a bit confusing

%(*
%      top_term = xterm;
%      top_attrs = Array.create 256 None;
%      top_root=  display.WX_xterm.root_oo;
%      top_appli = top;
%      top_scrollbar = ady;
%*)


<<function [[Ebuffer.default]]>>=
let default name =
  try
    Hashtbl.find (Globals.editor()).edt_buffers name
  with Not_found ->
    let str = 
      if name = "*help*" 
      then help_buffer_content
      else ""
    in
    create name None (Text.create str) (Keymap.create ())
@
%todo: maybe simpler to remove Ebuffer.default and have a separate
% find_buffer_of_name and an adhoc create_help_buffer?
%(*
%"
%Version is " ^ Version.efuns_version ^"
%built by "^ Version.builder ^ " " ^ Version.date ^ " 
%with
%Efuns installation directory : " ^ Version.efuns_lib ^ "
%Ocaml installation directory : " ^ Version.ocamllib ^ "
%
%Fabrice Le Fessant
%PARA/SOR Project
%INRIA Rocquencourt
%
%Help for Key Bindings: C-h K
%See changes in "^ Version.efuns_lib ^"/Changes
%"
%*)

% right now used by shell.ml only
<<function [[Ebuffer.find_buffer_opt]]>>=
let find_buffer_opt name =
  try Some (Hashtbl.find (Globals.editor()).edt_buffers name)
  with Not_found -> None
@

<<constant [[Ebuffer.help_buffer_content]]>>=
let help_buffer_content = 
"Welcome to Efuns, a small demo editor written in Ocaml.

Fabrice Le Fessant
PARA/SOR Project
INRIA Rocquencourt
"
@


% Top_window.create -> ()
<<function [[Window.create_at_top]]>>=
let create_at_top xpos ypos width height =
  let rec window = {
    win_xpos = xpos;
    win_ypos = ypos;
    win_width = width;
    win_height = height;

    win_down = NoFrame; 
    win_up = Window window; (* this will be adjusted in the caller *)

    win_mini = false;
  } in
  window
@
% let rec!! because it's used to bootstrap!
%less: rename? it has actually no_top ... it's a fake_win_up.
% but it's true it has no win_down so in some sense it's at the top
%note: could do without if were defining window, frame, and top_window
% with a 'let rec ... and ...'? or if were using globals for top_window?
% Do we need the win_up field that makes things mutually recursive and
% slightly complicated?
% I think there is no choice, we need win_up for certain actions.


%dead:?
%<<[[Top_window.create()]] create graphical window with right dimensions>>=
%(*
%let top = new WX_appli.t display.WX_xterm.root_oo [] in
%top#setWM_NAME "new_frame";
%top#setWM_CLASS "Efuns" "efuns";
%let hbar = new WX_bar.h top#container [] in
%top#container_add hbar#contained;
%let xterm = new WX_xterm.t 
%    hbar#container display
%    editor.edt_width
%    editor.edt_height in
%let ady = new WX_adjust.t () in
%let scrollbar = new WX_scrollbar.v hbar#container ady [] in
%hbar#container_add_s [xterm#contained; scrollbar#contained];
%*)
%@

%dead:?
%<<[[Top_window.create()]] misc stuff>>=
%(*
%  WX_xterm.install_handler display xterm (handler top_window xterm);
%  top#configure [Bindings [Key (anyKey, anyModifier), (fun _ ->
%          handler top_window xterm (WX_xterm.XTKeyPress (
%              !WX_types.modifiers_event, !key_string, !key_sym));
%          WX_xterm.update_displays ()
%    )]];
%*)
%@

\subsection{[[Top_window.update_display()]]}
% or mv in  its own \section, redisplay engine? after the event loop

% Graphics_xxx.init | (event loop -> handle_key) -> <>
<<function [[Top_window.update_display]]>>=
let update_display () =
  (Globals.editor()).top_windows |> List.iter (fun top_window ->
     top_window.window |> Window.iter (fun frm -> 
       Frame.display top_window frm
     );
     (match top_window.top_mini_buffers with
      | [] -> ()
      | frm :: _ -> Frame.display top_window frm
     );
     cursor_on top_window;
     let graphic = Efuns.backend top_window in
     graphic.Xdraw.update_display();
  ) 
[@@profiling]
@

% Why have a list of top_windows? Because of Emacs "Frames" which 
% could supported by efuns (need to extend graphic_efuns.ml for that?).
% Get rid of top_windows and just have one? Could, but does not hurt
% to give the possibility to add back this feature if someone wants it.

%todo: Why have a list for minibuffer? recursive minibuffer?
% and Frame.display only the first minibuffer? 

% minibuffer is a frame!
% status line? it's attached to a frame actually
% (and minibuffer is a frame, but special without a status line, hmm)

% will see Frame.display() later
% will see cursor_on() later

% we call the graphic backend update_display so it knows
% things need to be refreshed (queue the pixmap widget)

\section{The event loop}

% again not portable part

%  let rec loop () =
%      let evt = ... in
%      ...
%      Top_window.handler top_window () evt
%  in
%  loop ()


\subsection{[[Event]]}

% event type?

\subsection{[[Top_window.handler()]]}

% will see later why need mutex, when use threads
% for external process (e.g. M-!) in which case
% we must ensure exclusive access to the shared data

<<function [[Top_window.handler]]>>=
let handler top_window event =
  Globals.with_lock (fun () ->
    match event with
    <<[[Top_window.handler()]] match event cases>>
  )
@
%old: was using top_window.top_location.edt_mutex in 2 cases of 3
% more consistent to always use the same form
%pad: I factorized code with with_lock


<<function [[Efuns.with_lock]]>>=
let with_lock f =
  let edt = editor () in
  Mutex.lock edt.edt_mutex;
  Common.finalize f (fun () -> Mutex.unlock edt.edt_mutex)
@  


\subsection{[[Top_window.handle_key()]]}

<<[[Top_window.handler()]] match event cases>>=
| Xtypes.XTKeyPress (modifiers, _s, keysym) ->
    handle_key_and_macro top_window modifiers keysym
@
%dead:?
%  (*
%    if (keysym < XK.xk_Shift_L || keysym > XK.xk_Hyper_R)
%    then 
%  *)


<<function [[Top_window.handle_key]]>>=
let handle_key top_window modifiers keysym =
  keypressed := keysym;
  let frame = top_window.top_active_frame in
  let buf = frame.frm_buffer in

  clean_display (); (* set cursor off *)
  clear_message top_window;

  Hooks.exec_hooks(try Var.get_var buf handle_key_start_hook with _ ->[]) frame;

  let mod_ = 
    <<[[Top_window.handle_key()]] compute mod>>
  in
  let key = (mod_, keysym) in
  begin
    try
      (* should lead to an action being triggered and modifying things! *)
      try_map frame key
    with
    <<[[Top_window.handle_key()]] handle exception of [[try_map]]>>
  end;

  Hooks.exec_hooks (try Var.get_global handle_key_end_hook with _ -> []) ();

  update_display () (* will set cursor back on and many other things *)
@
% seen top_active_frame buffer!
% update_display() again!! each key down trigger a redisplay action
% will see try_map() later in keyboard section
%old: the handle_key_start used to take unit, but now it takes a frame,
% so can do more complex stuff, e.g. in eshell to try to go
% to the end of the buffer if type regular key


<<constant [[Top_window.keypressed]]>>=
let keypressed = ref 0
@
% who uses that? self_insert_command. Convenient otherwise
% will have to define 26 action strings and 26 functions
% to handle all the alphabet keys.

<<constant [[Top_window.handle_key_start_hook]]>>=
let handle_key_start_hook = Store.create_abstr "handle_key_start_hook"
@
<<constant [[Top_window.handle_key_end_hook]]>>=
let handle_key_end_hook = Store.create_abstr "handle_key_end_hook"
@
% who uses that? handle_key_start_hook can be used by eshell


<<constant [[Top_window.meta]]>>=
let meta = ref Xtypes.mod1Mask
@
% default meta key

<<[[Top_window.handle_key()]] compute mod>>=
let mask = Xtypes.controlMask lor !meta in
let diff = modifiers land mask in
match () with
| _ when diff =|= 0 -> NormalMap 
| _ when diff =|= Xtypes.controlMask -> ControlMap
| _ when diff =|= !meta -> MetaMap
| _ -> ControlMetaMap
@
% I don't handle Esc-x for now.

% so for now remains Frame.display(), and Top_window.try_map()
% which are big pieces to understand that we have not seen.

%todo: does not work well under Linux. When you switch between windows
% then it's like M- is always on (I have to press another time on M-
% to cancel the effect)

%less: put here the binding for the very basic keys? 'a', 'b', etc?





\chapter{Text Management}

% text.ml

%How moe, sam, vi, emacs, gedit manage their textual data:
% http://ecc-comp.blogspot.com/2015/05/a-brief-glance-at-how-5-text-editors.html
% https://news.ycombinator.com/item?id=11244103

% apparently emacs is using a gap buffer too.

%alt: a few alternatives (including gap buffer)
% http://www.averylaird.com/programming/editor/2017/09/30/the-piece-table/

\section{The gap buffer}

%from guide.txt:
%The Text.t type implements a gap-buffer. A gap-buffer is a buffer with
%a big hole inside. Why ? To insert one char inside a buffer, you need to move
%all the end of the buffer by one char before inserting. This is too expensive
%for very large buffers. Instead, gap-buffers have a hole. To insert one char
%in the buffer, you only need to move the hole to your position, and to insert
%the char at the first position of the hole. Then, to insert a second char
%just after the first one (the most used operation in an editor), you only
%need to put it at the new first position of the hole.
%
%                       v
%aaaaaaaaaaa-------aaaaaaaaaaaaaaaaaa
%
%=> move the hole
%                       v
%aaaaaaaaaaaaaaaaaaaaaaa-------aaaaaa
%
%=> insert your char
%                       v
%aaaaaaaaaaaaaaaaaaaaaaab------aaaaaa
%
%=> move the cursor
%                        v
%aaaaaaaaaaaaaaaaaaaaaaab------aaaaaa
%
%=> insert the second char without moving any chars :)
%
%                        v
%aaaaaaaaaaaaaaaaaaaaaaabc-----aaaaaa
%
%Inside the Text.t structure, cursors are represented by Text.point structures.
%Indeed, when the gap (the hole) moves inside the buffer, all cursors must
%be updated with the new offset of the gap. This might be expensive, however,
%thanks to Ocaml modules, other Text implementations could be tested without
%breaking the editor.

%src:
% http://en.wikipedia.org/wiki/Gap_buffer
% http://scienceblogs.com/goodmath/2009/02/18/gap-buffers-or-why-bother-with-1/
%alternative used in emacs:
% http://en.wikipedia.org/wiki/Rope_(data_structure)
%
% http://ned.rubyforge.org/doc/buffer-gap.txt

%'Gap Buffers Are Not Optimized for Multiple Cursors'
% http://nullprogram.com/blog/2017/09/07/


% already seen Text.text_size, Text.text_string in core DS chapter

% So the gap buffer is a good amortized DS. You pay the first insertion,
% but later one are cheap. And in practice when you edit a file you usually
% type lots of characters after one another, so the gap buffer optimizes
% for this!


<<[[Text.t]] gap fields>>=
(* g for gap *)
mutable gpoint : point;
mutable gsize : int;
@
%old: used to have gpoint and gline fields, but it was confusing.
% better to merge in a gpoint that is actually a Text.gpoint.
% A gpoint should be a point ... not a position.

% code looks like that then:
% let gap_end = gpoint.pos + text.gsize in

<<function [[Text.size]]>>=
let size text = 
  text.text_size - text.gsize
@
% gsize is 0 at the very beginning



% the cursor may be on the empty gap, but when
% code want to access what is under the cursor we actually
% want what is after!
<<function [[Text.get_char]]>>=
let get_char text point =
  let pos = point.pos in
  let gpos = text.gpoint.pos in
  let pos = 
    if pos = gpos 
    then pos + text.gsize 
    else pos
  in
  if pos < text.text_size 
  then Bytes.get text.text_string pos
  else '\000'
@

% because of this gap lots of functions has to be modified
% to handle the gap, insertion, deletion, but also search, blit,
% setting and getting positions, etc.

\section{Positions}

\subsection{User positions}

% point.pos are actually not really the final charpos position;
% the gap has to be taken care of.

<<misc keys>>=
[c_x; NormalMap, Char.code '='], Misc_features.cursor_position;
@


<<function [[Complex.get_pos]]>>=
let describe_position frame =
  let (_, text, point) = Frame.buf_text_point frame in
  Message.message frame
    (Printf.sprintf "Char position %d" (Text.get_position text point))
[@@interactive]
@
%old:
% <<misc actions>>=
% define_action "describe_position" Complexe.describe_position;
% define_action "cursor_position" Complexe.cursor_position;
% @
% <<[[interactives_map]] initial entries>>=
% "describe_position";
% @

<<function [[Misc.cursor_position]]>>=
let cursor_position frm =
  let (_, text, point) = Frame.buf_text_point frm in
  let char = Text.get_char text point in
  let coord = Text.point_coord text point in
  Message.message frm
    (Printf.sprintf "Char: '%c' (%d, #o%o, #x%x) point=%d line=%d column=%d" 
       char 
       (Char.code char) (Char.code char) (Char.code char)
       (Text.get_position text point)
       (coord.Text.c_line + 1) 
       coord.Text.c_col
    )
[@@interactive]
@

% seen Point type in core DS chapter with Buffer type.

<<function [[Text.get_position]]>>=
let get_position text point = 
  (* gap handling *)
  if point.pos > text.gpoint.pos 
  then point.pos - text.gsize
  else point.pos
@
% note that point can never be in the middle of the hole.
% either it's the gpoint, or it's before or after the hole.

% so from a position2 in point to a regular position!

\subsection{Internal positions}


<<type [[Text.position2]]>>=
type position2 = int
@

% pos is user pos!
<<function [[Text.set_position]]>>=
let set_position text point pos =
  move_point_to_pos text point
    (if pos > text.gpoint.pos 
     then pos + text.gsize
     else pos
     )
@
% rename move_point_to_pos2?

% note that if you extend the gap, move, you need
% to update pos, but also line! because this can change too
% which makes points really dependent of the text it references.

\section{Points}

% optimizing markers:
% http://blog.atom.io/2015/06/16/optimizing-an-important-atom-primitive.html

% seen Point type in core DS chapter with Buffer type.

% they are used as "cursors" that goes through the text.

%todo: could add to which text they belong to avoid
% bugs where use point of a text to another text
% (easy mistake)


<<[[Text.t]] other fields>>=
mutable text_points : point list;
@

% There are a list of points maintained by the Text itself. Why?
% because the gap can move so you need to update all
% the points references. So need to create points by using specific
% APIs that maintain somewhere this list of points.
%subtle, but nice, because if save position points somewhere,
% then even if the text moves, you can go back to the same
% position!


<<function [[Text.new_point]]>>=
let new_point text =
  let p = { pos = 0; line = 0; } in    
  text.text_points <- p :: text.text_points;
  p
@
%old: was called add_point, but clearer new_point

<<function [[Text.dup_point]]>>=
let dup_point text point =
  let p = { pos = point.pos; line = point.line } in
  text.text_points <- p :: text.text_points;
  p
@
% note that can't do let p = point; we need to allocate a new
% record because later we use == to remove it.

<<function [[Text.remove_point]]>>=
let remove_point text p =
  text.text_points <- 
    text.text_points |> List.fold_left (fun points point ->
        if point == p 
        then points 
        else point :: points
    ) [];
  (* being defensive *)
  p.pos <- -1;
  p.line <- -1;
  ()
@
%note: use of == not =
%note: you should use with_dup_point() if you can, instead of manually using
% dup_point ... remove_point

<<function [[Text.goto_point]]>>=
let goto_point _text p1 p2 =
  (* less: could assert they references the same text *)
  p1.pos <- p2.pos;
  p1.line <- p2.line
@
% order of argument is not super good, not very readable.

\ifallcode
<<function [[Text.compare]]>>=
let compare _text p1 p2 = 
  compare p1.pos p2.pos
@
\fi
% but actually no code almost is using it (except fill()),
% and they use the generic < which should work


<<function [[Text.with_dup_point]]>>=
let with_dup_point text point f =
  let p = dup_point text point in
  Common.finalize (fun () -> f p) (fun () -> remove_point text p)
@

<<function [[Text.with_new_point]]>>=
let with_new_point text f =
  let p = new_point text in
  Common.finalize (fun () -> f p) (fun () -> remove_point text p)
@
%pad: I introduced that; it factorizes code and remove some bugs I think

\section{Delta}

<<type [[Text.delta]]>>=
type delta = int
@

%val distance : t -> point -> point -> delta

% helper often used when want compute a delta from 2 pos

% user delta! not just p2.pos - p1.pos

<<function [[Text.distance]]>>=
let distance text p1 p2 =
  low_distance text p1.pos p2.pos
@

<<function [[Text.low_distance]]>>=
let low_distance text p1 p2 =
  if p1 >= p2 
  then 0 
  else
    if p1 <= text.gpoint.pos 
    then
      if p2 <= text.gpoint.pos 
      then p2 - p1
      else p2 - p1 - text.gsize
    else
      if p2 <= text.gpoint.pos 
      then p2 - p1 + text.gsize
      else p2 - p1
@

\section{Lines and columns}
% coordinates?

% already seen Text.text_newlines, Text.text_nlines, and 
% Text.line (very partial for now) type

<<type [[Text.coord]]>>=
type coord = {
  c_col: int;
  c_line: int;
}
@

% we will see actually later than have also the notions of screen coord (x y),
% and even frame coord and that they are different than col x line
% because of lines cut and ^M.

% status line display the line of the cursor -> <>
<<function [[Text.point_line]]>>=
let point_line text point = 
  (* defensive: *)
  if (point.line <> find_line_of_pos text point.pos)
  then UCommon.pr2 (Common.spf "TODO: point.line = %d != find_line ... = %d"
                     point.line (find_line_of_pos text point.pos));
  point.line
@
% note that it's 0 based! status_line displays it as starting
% at line 1, but internally it's 0 based.
%less: rename? line_of_point?

% status line display the co of the cursor -> <>
<<function [[Text.point_col]]>>=
let point_col text point = 
  let pos = point.pos in
  let gpos = text.gpoint.pos in
  let bol = text.text_newlines.(point.line).position in
  (* gap handling *)
  if bol <= gpos && gpos < pos
  then pos - bol - text.gsize
  else pos - bol
@


<<function [[Text.point_coord]]>>=
let point_coord text point =
  { c_col = point_col text point;
    c_line = point_line text point;
  }
@


% ?? -> <>
<<function [[Text.move_point_to]]>>=
let move_point_to_pos text point pos =
  point.pos <- pos;
  point.line <- find_line_of_pos text pos
@
%old: was move_point_to but better rename to move_point_to_pos
%todo: or maybe move_point_to_pos_internal ? and find_line_of_pos_intern?
%old: let _x,y = find_xy text text.gpoint.pos text.gpoint.line pos in
% but xy should be reserved for screen coord, and anyway find_xy
% is too complex for what we need

<<function [[Text.find_line_of_pos]]>>=
let find_line_of_pos text pos =
  let gpos = text.gpoint.pos in
  let gline = text.gpoint.line in
  let gap_end = gpos + text.gsize in

  if pos >= gap_end then
    (* go forward *)
    let rec iter line =
      if line >= text.text_nlines 
      then text.text_nlines - 1
      else
        if text.text_newlines.(line).position > pos 
        then line - 1
        else iter (line + 1)
    in
    iter (gline+1) 
  else
     (* go backward *)
     let rec iter line =
       if line > 0 
       then
         if text.text_newlines.(line).position > pos 
         then iter (line - 1)
         else line
      else 0
     in
     iter gline
[@@profiling]
@
%opti: could use binary search instead of linear iteration


% when moving the cursor, the work to do is to maintain the line field

<<function [[Text.fmove_res]]>>=
let fmove_res text p delta =
  if delta = 0 then 0 else
  let gpos = text.gpoint.pos in
  let size = text.text_size in
  let gap_end = gpos + text.gsize in
  let gline = text.gpoint.line in
  let pos = p.pos in
  let old_pos = pos in
  let lines = text.text_newlines in
  let rec iter y point end_point =
    if end_point > point 
    then
      let end_line = lines.(y+1).position in
      if end_point >= end_line 
      then iter (y+1) end_line end_point
      else (y, end_point)
    else (y,point)
  in
  let (y,pos) = 
    if pos + delta <= gpos 
    then iter p.line pos (pos+delta)
    else
      if pos >= gap_end 
      then
        let delta = min delta (size - pos) in
        iter p.line pos (pos + delta)
      else
        let delta = min (delta - (gpos - pos)) (size - gap_end) in
        iter gline gap_end (gap_end + delta) 
  in
  p.pos <- pos;
  p.line <- y;
  low_distance text old_pos pos
@

<<function [[Text.bmove_res]]>>=
let bmove_res text p delta =
  if delta = 0 then 0 else
  let gpos = text.gpoint.pos in
  let gap_end = gpos + text.gsize in
  let gline = text.gpoint.line in
  let pos = p.pos in
  let old_pos = pos in
  let lines = text.text_newlines in
  let rec iter y end_point =
    let start_line = lines.(y).position in
    if end_point >= start_line then
      (y, end_point)
    else
      iter (y-1) end_point
  in
  let (y,pos) = 
    if pos - delta >= gap_end then
      if pos - delta < lines.(gline+1).position then
        (
          gline, pos - delta)
      else
        iter p.line (pos-delta)
    else
    if pos <= gpos then
      let delta = min delta pos in
      iter p.line (pos - delta)
    else
    let delta = min (delta - (pos - gap_end)) gpos in
    iter gline (gpos - delta) 
  in
  p.pos <- pos;
  p.line <- y;
  low_distance text pos old_pos
@


<<function [[Text.bmove]]>>=
let bmove text p delta = 
  bmove_res text p delta |> ignore
@
<<function [[Text.fmove]]>>=
let fmove text p delta = 
  fmove_res text p delta |> ignore
@

<<function [[Text.move_res]]>>=
let move_res text point n =
  if n > 0 
  then fmove_res text point n
  else bmove_res text point (-n)
@

<<function [[Text.move]]>>=
let move text point n = 
  move_res text point n |> ignore
@


\section{Inserting characters}

% insert | ... -> <>
<<function [[Text.low_insert]]>>=
let low_insert text pos str =
  let strlen = String.length str in
  <<[[Text.low_insert()]] fail if readonly buffer>>

  <<[[Text.low_insert()]] move gap to point>>
  (* subtle: don't move those 'let' earlier, because moving the gap do side
   * effects on the position and line of the gpoint. 
   *)
  let gpos = text.gpoint.pos in
  let gline = text.gpoint.line in

  cancel_repr text gpos gline;
  <<[[Text.low_insert()]] extend gap if not enough space>>
  (* all points should have their point.pos correctly adjusted *)

  String.blit  str 0   text.text_string gpos    strlen;
  (* todo: should refontify! *)
  Array.fill text.text_attrs gpos strlen direct_attr;

  let (nbr_newlines, _nbr_chars) = Utils.count_char str '\n' in
  if nbr_newlines > 0 then 
  begin
    <<[[Text.low_insert()]] adjust newlines when str contains newlines>>
  end;
  let gline = text.gpoint.line in
  text.text_points |> List.iter (fun p ->
    if p.pos > gpos 
      (* bugfix: there was extra condition line = gline. But bug! unit test *)
    then p.line <- p.line + nbr_newlines;

  );
  text.gpoint <- { pos = gpos + strlen; line = gline + nbr_newlines };
  text.gsize <- text.gsize - strlen;
  (gpos, strlen, text.text_modified) 
@
%  (*let gchars = gpoint - text.text_newlines.(gline).position in*)
% (* p.point_x <- (p.point_x - (if nbr_newlines > 0 then gchars else 0)) + nbr_chars; *)

%todo: unit test the condition

% will see higher insert API later in Basic features chapter.
% (insert, insert_res, ...)

\subsection{Moving the gap}

<<[[Text.low_insert()]] move gap to point>>=
move_gpoint_to text pos;
@


% low_insert | low_delete | clean_text  -> <>
<<function [[Text.move_gpoint_to]]>>=
let move_gpoint_to text pos =
  let gpos = text.gpoint.pos in
  let gsize = text.gsize in
  let gline = text.gpoint.line in
  let gap_end = gpos + gsize in

  <<[[Text.move_gpoint_to()]] reset [[text_clean]]>>
  if pos <> gpos then
    if pos < gpos then begin
      <<[[Text.move_gpoint_to()]] when pos is before gpos>>
    end else begin
      <<[[Text.move_gpoint_to()]] when pos is after gpos>>
      end
[@@profiling]
@
%text_clean? see clean_text()


<<[[Text.move_gpoint_to()]] when pos is before gpos>>=
let delta = gpos - pos in
let (delta_line,_) = 
  Utils.count_char_sub (Bytes.to_string text.text_string) pos delta '\n'
in
Bytes.blit text.text_string pos   text.text_string (pos + gsize)   delta;
Array.blit text.text_attrs  pos   text.text_attrs  (pos + gsize)   delta;
for i = gline - delta_line + 1 to gline do
  text.text_newlines.(i).position <- text.text_newlines.(i).position + gsize 
done;
text.text_points |> List.iter (fun p -> 
  if p.pos > pos && p.pos <= gpos 
  then p.pos <- p.pos + gsize
);
text.gpoint <- { pos = pos; line = gline - delta_line };
@
%FIGURE:
% p.pos > pos? it's not p.pos >= pos?

<<[[Text.move_gpoint_to()]] when pos is after gpos>>=
let delta = pos - gap_end in
let (delta_line,_) = 
  Utils.count_char_sub (Bytes.to_string text.text_string) gap_end delta '\n' in
Bytes.blit text.text_string gap_end   text.text_string gpos   delta;
Array.blit text.text_attrs  gap_end   text.text_attrs  gpos   delta;
for i = gline + 1 to gline + delta_line do
  text.text_newlines.(i).position <- text.text_newlines.(i).position - gsize
done;
text.text_points |> List.iter (fun p -> 
    if p.pos >= gap_end && p.pos <= pos 
    then p.pos <- p.pos - gsize
);
text.gpoint <- { pos = pos - gsize; line = gline + delta_line }
@
%FIGURE:
% for text.gpoint <- { pos = pos - gsize ... } ?? it's not pos?
% no because it was pos in the text where the gap was before, but
% now that the gap has moved, it's pos - gsize!

% blit but what about the content of the moved gap? clean_text
% reset it lazily as it's needed only for certain things (search)


\subsection{extending the gap}

<<[[Text.low_insert()]] extend gap if not enough space>>=
if strlen > text.gsize 
then extend_gap text strlen;
@

% extending the gap is simple

<<constant [[Text.add_amount]]>>=
let add_amount = define_option ["add_amount"] "Size of the gap in the buffer"
  int_option 200
@

% ?? -> <>
<<function [[Text.extend_gap]]>>=
let extend_gap text amount =
  let add_size = max !!add_amount 
      ((amount / !!add_amount) * !!add_amount + !!add_amount) in
  let old_size = text.text_size in
  let gsize = text.gsize in

  let gpos = text.gpoint.pos in
  let gap_end = gpos + gsize in

  let new_text = Bytes.create (old_size + add_size) in
  Bytes.blit  text.text_string 0   new_text 0    gpos; 
  Bytes.blit  text.text_string gap_end   new_text (gap_end + add_size) 
    (old_size - gap_end);
  text.text_string <- new_text;

  let new_attrs = Array.make (old_size + add_size) direct_attr in
  Array.blit   text.text_attrs 0   new_attrs 0   gpos; 
  Array.blit   text.text_attrs gap_end    new_attrs (gap_end + add_size) 
    (old_size - gap_end);
  text.text_attrs <- new_attrs;

  for i = text.gpoint.line + 1 to text.text_nlines - 1 do
    text.text_newlines.(i).position <- 
      text.text_newlines.(i).position + add_size
  done;
  text.text_points |> List.iter (fun p -> 
      if p.pos > gpos 
      then p.pos <- p.pos + add_size
  );
  text.gsize <- gsize + add_size;
  text.text_size <- old_size + add_size;
  ()
[@@profiling]
@
%FIGURE:

\subsection{Adjusting newlines information}

<<[[Text.low_insert()]] adjust newlines when str contains newlines>>=
if (Array.length text.text_newlines - text.text_nlines) < nbr_newlines then
  begin
    <<[[Text.low_insert()]] grow newlines>>
  end;

Array.blit
  text.text_newlines (gline+1) 
  text.text_newlines (gline+1+ nbr_newlines) 
 (text.text_nlines - gline -1);
text.text_nlines <- text.text_nlines + nbr_newlines;

(* similar to compute_newlines() but just for lines after gpos *)
let rec iter n pos =
  let new_pos = 
   Bytes.index_from text.text_string pos '\n' in
  text.text_newlines.(gline+n) <- mk_line_with_pos (new_pos + 1);
  if n < nbr_newlines 
  then iter (n+1) (new_pos + 1)
in
iter 1 gpos;
@
%old:tree_insert text text text.gpoint.line nbr_newlines;
%<<function Text.tree_insert>>=
%let tree_insert text t gline nbr = ()
%@


<<[[Text.low_insert()]] grow newlines>>=
let old_size = text.text_nlines in
let new_cache = Array.make (old_size + (max 20 nbr_newlines)) 
  { (mk_line_with_pos (-1)) with line_modified = false }
in
Array.blit 
  text.text_newlines 0 
  new_cache 0 
  old_size;
text.text_newlines <- new_cache;
@
% not sure needs this subtle line_modified = - 1 

%\subsection{Adjusting points}

\section{Deleting characters}

% delete | ... -> <>
<<function [[Text.low_delete]]>>=
let low_delete text pos len =
  <<[[Text.low_insert()]] fail if readonly buffer>>

  <<[[Text.low_insert()]] move gap to point>>
  (* subtle: don't move those 'let' earlier, because moving the gap do side
   * effects on the position and line of the gpoint. 
   *)
  let gpos = text.gpoint.pos in
  let gline = text.gpoint.line in

  cancel_repr text gpos gline;

  let gap_end = gpos + text.gsize in
  let len = min (text.text_size - gap_end) len in

  let str = Bytes.sub_string text.text_string gap_end len in

  let (nbr_newlines, _nbr_chars) = Utils.count_char str '\n' in
  if nbr_newlines > 0 then begin
    <<[[Text.low_delete()]] adjust newlines when str contained newlines>>
  end;
  text.text_points |> List.iter (fun p -> 
      if p.pos > gap_end + len 
      then p.line <- p.line - nbr_newlines
      else
        (* points that were in deleted region *)
        if p.pos > gpos then begin
           p.pos <- gpos;
           p.line <- gline
         end
  );
  text.gsize <- text.gsize + len;
  (gpos, str, text.text_modified) 
@
%dead:?
%          (*if p.line = gline + nbr_newlines then
%            p.point_x <- (p.point_x - nbr_chars) + 
%              (if nbr_newlines > 0 then gchars else 0);*)
%         (* p.pos_x <- gchars; *)
% no need extend the gap this time.

<<[[Text.low_delete()]] adjust newlines when str contained newlines>>=
Array.blit 
  text.text_newlines (gline + nbr_newlines + 1)
  text.text_newlines (gline + 1) 
 (text.text_nlines - gline - nbr_newlines - 1);
text.text_nlines <- text.text_nlines - nbr_newlines;
@

% will see higher delete API later in Basic features chapter
% (delete_res, delete, ...)

\section{Attributes}

<<type [[Text.attribute]]>>=
type attribute = int
@
% int, because need to be efficient!
% attribute is an encoded int, 
% direct_attr (below) = black fg, white bg, no highlight regular font. 
% Want efficient representation here because each
% character will have this attribute.
%old: was used only in .mli before, but now I used it
% in in Text.text.attrs too

<<[[Text.t]] attribute fields>>=
mutable text_attrs : attribute array;
@
% note that when you copy paste text we don't copy the attributes,
% so a paste to another place will have no attribute and so no color

<<function [[Text.make_attr]]>>=
let make_attr fg bg font highlighted =
  let attr = 
     fg + 
     (bg lsl 8) + 
     (font lsl 16) + 
     (if highlighted then highlight_bit else 0)
  in
  attr
@
% 8 bits fg, 8 bigs bg, 8 bits font, 1 bit highlight
% color map = 0 -> black, 1 -> white?

<<constant [[Text.highlight_bit]]>>=
let highlight_bit = 1 lsl 24
@


<<constant [[Text.direct_attr]]>>=
let direct_attr =  make_attr 0 1 0 false
@
<<constant [[Text.inverse_attr]]>>=
let inverse_attr =  make_attr 1 0 0 false
@
% let no_attr = 0?

% remember that colors have index and 0 correspond to foreground color
% and 1 the background color.

% highlight bit dead? just use inverse_attr? could, but different
% purpose and actually we will use a different color (cyan).



<<function [[Text.get_attr]]>>=
let get_attr text point =
  let pos = 
    (* gap handling *)
    if point.pos = text.gpoint.pos
    then point.pos + text.gsize 
    else point.pos
  in
  if pos < text.text_size 
  then text.text_attrs.(pos)
  else direct_attr
@
%less: could print a warning if overflow no?

<<function [[Text.set_attr]]>>=
let set_attr text point attr =
  let y = point.line in
  let pos = 
    (* gap handling *)
    if point.pos = text.gpoint.pos
    then point.pos + text.gsize 
    else point.pos
  in
  if pos < text.text_size then begin
    cancel_repr text pos y;
    text.text_attrs.(pos) <- attr
  end
@
% cancel_repr? a cache.
%old: was called set_char_attr, but better to use set_attr for that

<<function [[Text.set_attrs]]>>=
let set_attrs text point len attr = (* should not exceed one line *)
  if len > 0 then
    let gap_end = text.gpoint.pos + text.gsize in

    cancel_repr text point.pos point.line;

    let pos = point.pos in
    let gpos = text.gpoint.pos in
    let before, after, after_pos =
      if pos > gap_end then
        0, (min (text.text_size - pos) len), pos
      else
      if pos + len <= gpos then
        0, len, pos
      else
      let before = gpos - pos in
      let after = min (len - before) (text.text_size - gap_end) in
      before, after, gap_end
    in
    if before > 0 
    then Array.fill text.text_attrs pos before attr;
    Array.fill text.text_attrs after_pos after attr
@
%FIGURE: where show 3 different configs depending
% on where is the covered area regarding the hole
%old:  let x,y = find_xy text text.gpoint.pos text.gpoint.line point.pos in
% but point.line should be enough ...
%old: was called set_attr, but I prefer set_char_attr to be the set_attr


<<function [[Text.unset_attrs]]>>=
let unset_attrs text =
  Array.fill text.text_attrs 0 (Array.length text.text_attrs) direct_attr;
  text.text_newlines |> Array.iter (fun line -> line.line_modified <- true)
@
%old: was called unset_attr

%old:
% <<misc actions>>=
% define_action "unset_attr" Simple.unset_attr;
% @

%dead:
% <<function [[Simple.unset_attr]]>>=
% let unset_attr frame =
%   let (buf, text, _) = Frame.buf_text_point frame in
%   Text.unset_attrs text
% @



\subsection{Colors}

% color map

<<[[Efuns.editor]] other fields>>=
edt_colors_names : string array;
edt_colors : (string,int) Hashtbl.t;
mutable edt_colors_n : int;
@
% 0 1 are used!
% can seem limited to have a color map, but to have
% an efficient representation for text attributes, it's
% better to use an int which then indexes a map (color map, font map)

% have side effect of setting the color if it's not there before!
<<function [[Window.get_color]]>>=
let get_color color_name =
  let edt = Globals.editor() in
  try
    Hashtbl.find edt.edt_colors color_name
  with Not_found ->
    if edt.edt_colors_n = 256 
    then raise Not_found
    else begin
      let n = edt.edt_colors_n in
      edt.edt_colors_n <- n + 1;
      edt.edt_colors_names.(n) <- color_name;
      Hashtbl.add edt.edt_colors color_name n;
      n
    end
@



<<[[main()]] misc initializations>>=
(* color 0 is foreground *)
Attr.get_color !!foreground |> ignore;
(* color 1 is background *)
Attr.get_color !!background |> ignore;
(* color 2 is highlight *)
Attr.get_color !!highlight_color |> ignore;
@
% actually if some of the color are identical it will not increment
% the counter ...

% standard! just like stdin/stdout/stderr convention. Sometimes
% conventions are convenient.
% alternative: "foreground", "background", "highlight" color name

% see makefile_color() function, switching to makefile_mode
% will then trigger coloration of the buffer

% makefile_color | ... -> <>
<<function [[Simple.color]]>>=
let color buf regexp strict attr =
  let text = buf.buf_text in
  Text.with_new_point text (fun point ->
  try
    while true do
      let len = Text.search_forward text regexp point in
      let before =
        if Text.bmove_res text point 1 = 1 then begin
          let c = Text.get_char text point in
          Text.fmove text point (len+1);
          c
        end else begin
          let c = Text.get_char text point in
          Text.fmove text point (len+1); 
          c
        end
      in
      let after = Text.get_char text point in
      if not (strict && (buf.buf_syntax_table.(Char.code before) ||
                         buf.buf_syntax_table.(Char.code after))) then
        begin
          Text.bmove text point len;
          Text.set_attrs text point len attr;
          Text.fmove text point len;
          ()
        end
    done
  (* at some point Text.search_forward will return Not_found *)
  with Not_found -> 
    buf.buf_modified <- buf.buf_modified + 1
  )
[@@profiling]
@
% not really incremental as font-lock-mode.
% but can be a simple starting point!
%less: strict means implicit \b\b around? but then it never colorizes, so bug?

%todo: have also a region variant, start/end

\subsection{Highlights}

<<constant [[Main.highlight_color]]>>=
let highlight_color = define_option ["highlight_color"] "" color_option "cyan"
@
% color 2 by convention, see main misc initializations above.

%old: See Text.highlight_bit
%<<constant [[Simple.highlight_bit]]>>=
%@
% see also make_attr

% highlight | ??? -> <>
<<function [[Simple.highlight_region]]>>=
let highlight_region buf debut fin =
  let text = buf.buf_text in
  Text.with_new_point text (fun curseur ->
  Text.with_new_point text (fun final ->
    Text.set_position text curseur debut;
    Text.set_position text final fin;
    while curseur < final do
      let attr = Text.get_attr text curseur in
      Text.set_attr text curseur (attr lor Text.highlight_bit);
      Text.fmove text curseur 1
    done;
    buf.buf_modified <- buf.buf_modified + 1
  ))
@
%todo: have Text.iter_range_pos ?

% unhighlight -> <>
<<function [[Simple.unhighlight_region]]>>=
let unhighlight_region buf debut fin =
  let text = buf.buf_text in
  Text.with_new_point text (fun curseur ->
  Text.with_new_point text (fun final ->
    Text.set_position text curseur debut;
    Text.set_position text final fin;
    while curseur < final do
      let attr = Text.get_attr text curseur in
      Text.set_attr text curseur (attr land (lnot Text.highlight_bit));
      Text.fmove text curseur 1;
    done;
    buf.buf_modified <- buf.buf_modified + 1
  ))
@
% could factorize code with previous func


% some stuff can highlight, but we need to remember it
% because when we type a key we want to unhighlight because
% highlights are usually very temporary


%val highlighted : (Efuns.frame * Text.position * Text.position) option ref
<<constant [[Simple.highlighted]]>>=
(* hightlighting of a region *)  
let highlighted = ref None
@

% Simple.mouse_save_then_kill -> <>
<<function [[Simple.highlight]]>>=
let highlight frame =
  let frame =
    match !H.highlighted with
    | None -> frame
    | Some (frame, _d, _f) -> frame
  in    
  let (buf, text, point) = Frame.buf_text_point frame in
  let mark = Ebuffer.get_mark buf point in
  let pt_debut, pt_fin =
    if point < mark 
    then point, mark
    else mark, point
  in
  let pos1 = Text.get_position text pt_debut in
  let pos2 = Text.get_position text pt_fin in
  let pos_debut_to_hl, pos_fin_to_hl =
    match !H.highlighted with
    | None -> pos1, pos2
    | Some (_frame, d, f) ->
        if pos1 > d
        then H.unhighlight_region buf d pos1; 
        if pos2 < f
        then H.unhighlight_region buf pos2 f;
        if pos1 < d 
        then pos1, d
        else
          if pos2 > f 
          then f, pos2
          else pos1, pos1
  in
  H.highlighted := Some (frame, pos1, pos2);
  H.highlight_region buf pos_debut_to_hl pos_fin_to_hl
@
% was using debut/fin for some position and some position2, so confusing
%less: useful this opti? can't just unhighlight the min/max and then rehighlight
% the new part?

<<function [[Frame.buf_text_point]]>>=
let buf_text_point frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  (buf, text, point)
@
%pad: I introduced this; it factorizes code and makes it more readable IMHO

% Top_window.handle_key -> <> 
% (as hook <- Top_window.handle_key_start_hook <- Highlight._)
<<function [[Simple.unhighlight]]>>=
let unhighlight _frame =
  <<[[Simple.unhighlight()]] handle highlighted chars>>
  match !highlighted with
  | None -> ()
  | Some (frame,debut,fin) -> 
     (*   if !keypressed <> XK.xk_Pointer_Drag1 then *)
     highlighted := None;
     let (buf, text, _) = Frame.buf_text_point frame in
     Hooks.exec_hooks (Var.get_global unhighlight_hook) (text, debut, fin);
     unhighlight_region buf debut fin
@

<<toplevel [[Highlight]] starting hook>>=
let _ =
  Hooks.add_start_hook (fun () ->
    Hooks.add_hook Top_window.handle_key_start_hook unhighlight;      
  )
@

% so for instance in paren_mode we will highlight some chars
% and each key stroked we want to undo that, enter highlighted chars
% global


<<[[Simple.highlight_paren()]] remember highlighted chars>>=
H.highlighted_chars := (buf,cursor,attr) :: !H.highlighted_chars;
@

%val highlighted_chars : (Efuns.buffer * Text.point * Text.attribute) list ref
<<constant [[Simple.highlighted_chars]]>>=
let highlighted_chars = ref []
@
% who sets that? highlight_paren!

<<[[Simple.unhighlight()]] handle highlighted chars>>=
!highlighted_chars |> List.iter (fun (buf,curseur,old_attr) ->
  let text = buf.buf_text in
  (* less: could reset highlight bit instead of having to store old_attr *)
  Text.set_attr text curseur old_attr;
  buf.buf_modified <- buf.buf_modified + 1;
  Text.remove_point text curseur
);
highlighted_chars := [];
@
% because if you move or type anything you want to reset what
% was highlighted!




%dead:?
%<<[[Text.line]] other fields>>=
%mutable line_hlt : int; (* highlighting *)
%@
%dead:? seems never set. subsumed by color attribute? with special
% higlight bit?
%
%
%<<[[Text.compute_representation()]] handle highlighting>>=
%(* once we have computed the simple representation, we can add more
% * complicated things, such as highlighting ... 
% *)
%(match line.line_hlt with
%| 0 -> ()
%| x when x > 0 ->
%    (* the line is hightlighted from the beginning to pos the
%     * line.line_hlt char 
%     *)
%      <<[[Text.compute_representation()]] if line_hlt is positive>>
%| x when x < 0 ->
%  (* the line is hightlighted from then end to pos line.line_hlt *)
%      <<[[Text.compute_representation()]] if line_hlt is negative>>
%| _ -> raise Impossible
%);
%@
%
%
%
%<<[[Text.compute_representation()]] if line_hlt is positive>>=
%let first = line.line_hlt - 1 in
%let rec iter list tail =
%  match list with
%  | [] -> List.rev tail 
%  | repr :: list_r ->
%      if repr.box_pos > first 
%      then iter list_r (repr :: tail)
%      else
%        let len = first - repr.box_pos + 1 in
%        (List.rev tail) @
%          (let before, after = 
%             if len = repr.box_len 
%             then [], list
%             else [ 
%              { repr with
%                box_pos = repr.box_pos + len;
%                box_len = repr.box_len - len;
%                box_size = repr.box_charsize * (repr.box_len - len);
%                box_pos_repr = repr.box_pos_repr + (len*repr.box_charsize)
%              }
%              ], ({ repr with
%                    box_len = len;
%                    box_size = repr.box_charsize * len;
%                   } :: list_r)
%        in
%        after |> List.iter (fun repr ->
%          repr.box_attr <- repr.box_attr lor (1 lsl 24)
%        );
%        before @ after
%      )
%in
%line.boxes <- iter line.boxes []
%@
%
%<<[[Text.compute_representation()]] if line_hlt is negative>>=
%let first = line.line_hlt - 1 in
%let rec iter list tail =
%  match list with
%  | [] -> List.rev tail 
%  | repr :: list_r ->
%      if repr.box_pos > first 
%      then iter list_r (repr :: tail)
%      else
%        let len = first - repr.box_pos + 1 in
%        (List.rev tail) @
%          (let before, after = 
%             if len = repr.box_len 
%             then [], list
%             else [ 
%              { repr with 
%                box_pos = repr.box_pos+len;
%                box_len = repr.box_len - len;
%                box_size = repr.box_charsize * (repr.box_len - len);
%                box_pos_repr = repr.box_pos_repr + (len * repr.box_charsize)
%              }
%              ], ({ repr with
%                    box_len = len;
%                    box_size = repr.box_charsize * len;
%                  } :: list_r)
%        in
%        after |> List.iter (fun repr ->
%          repr.box_attr <- repr.box_attr lor (1 lsl 24)
%        );
%        before @ after
%       )
%in
%line.boxes <- iter line.boxes []
%@

\subsection{Fonts}
% with an 's'?

<<[[Efuns.editor]] other fields>>=
edt_fonts : (string,int) Hashtbl.t;
edt_fonts_names : string array;
mutable edt_fonts_n : int;
@

% similar to get_color, have the side effect of "allocating" a new font
<<function [[Window.get_font]]>>=
let get_font font_name =
  let edt = Globals.editor() in
  try
    Hashtbl.find edt.edt_fonts font_name
  with Not_found ->
    if edt.edt_fonts_n = 256 
    then raise Not_found
    else begin
      let n = edt.edt_fonts_n in
      edt.edt_fonts_n <- n + 1;
      edt.edt_fonts_names.(n) <- font_name;
      Hashtbl.add edt.edt_fonts font_name n;
      n
    end
@

<<[[main()]] misc initializations>>=
(* font 0 is initial font *)
Attr.get_font !!Globals.font |> ignore;
@

%todo: variable sized font?



% <<misc keys>>=
% [c_x; NormalMap, Char.code 'F'], Misc.change_font;
% @
% 
% <<function [[Complex.change_font]]>>=
% let change_font frame =
%   Minibuffer.create_return frame (Keymap.create ()) "Find font: " "fixed"
%     (fun old_frame name ->
%       let window = frame.frm_window in
%       let _top_window = Window.top window in
%       (*WX_xterm.change_font xterm name*)
%       failwith "Complex.change_font??"
%   ) |> ignore
% @



\section{Line representation}
% Line display?

% data -> text_string -> text_newlines -> Text.line with repr_string
% we will get closer to an actual display because we will handle
% special chars, to get the "line representation" in repr_string.

% it's subtle because many coordinates are positions in the original
% text (point, pos, line) and other coordinates are positions in
% the representation (x, y), with first string representation that
% handles tabs, special ^M chars, and then the frame line representation
% that handles overflow lines.

\subsection{Line boxes}
% (cached) representation
%less: mv later? Keep Text Management section to be only about text_string?

% text.text_newlines is array of Text.line, where have seen
% already the line.position which is the bol pos.
% here is another field of Text.line record:

<<[[Text.line]] representation fields>>=
mutable boxes : box list; (* sorted in reverse; head is last box on the line *)
@
%old: the field was called representation, and box was called line_repr 
% (or repr_line), but I prefer to keep the representation term
%  for the actual repr_string!
%note: this a cache? because at the beginning it's empty, see
% mk_line_with_pos(). It's not a cache really, but it's computed
% on demand for the line we actually want to display (in which case
% we need the line "representation").

% why need that? opti? to avoid sending too many graphic
% commands? can put every chars using the same attribute together?
% well we need anyway the repr_string at least, for ^M special display.

<<type [[Text.box]]>>=
and box = 
  { 
    box_col : int;        (* col of box *)
    box_len : int;        (* len of box in Text.t string *)
    mutable box_attr : int;    (* common attribute *)

    <<[[Text.box]] other fields>>
  } 
@
%old: I renamed things, clearer, there was too many line_repr or repr_line
% so repr -> box, repr_line_pos -> box_pos, repr_line_len -> box_len, etc
%bugfix: the comment about repr_line_pos was (*pos of box in Text.t string *)
% but it's not a pos, it's actually
% a column! I found the bug when putting position2 here and making
% abstract position2 in text.mli which help find code comparing column
% number with repr_line_pos! types ftw!


\subsection{Characters representation, handling [[^M]]}

% text.text_string is a string, an array of chars where
% a char is a byte. But while some chars
% take one "char" space in the display, some special chars
% have no direct representation, and so to represent them
% we "cheat", and display them like ^M. Same for tabs (see advanced topics).
% in which case they take 2 chars!

<<[[Efuns.buffer]] other fields>>=
mutable buf_charreprs : Text.charreprs; (* 256 array *)
@


<<type [[Text.charreprs]]>>=
type charreprs = string array
@
% not char array! string array.


<<[[Ebuffer.create()]] buffer other fields setup>>=
buf_charreprs = Array.init 256 (fun i -> String.make 1 (Char.chr i));
@

%less: when need special values? why keep that a buffer property?
% could share at least?

% 26 letters of the alphabet, but for special chars!
<<[[Ebuffer.create()]] adjust charreprs>>=
for i=0 to 25 do
  let s = Bytes.make 2 '^' in
  Bytes.set s 1 (Char.chr (97+i));    
  buf.buf_charreprs.(i) <- (Bytes.to_string s);
done;
@
% ^M, ^R, etc
% 97 = Char.code 'A' ?

<<function [[Ebuffer.compute_representation]]>>=
let compute_representation buf n =
  Text.compute_representation buf.buf_text buf.buf_charreprs n
@


\subsection{Line string representation}

% really "representation" this time.

<<[[Text.line]] representation fields>>=
mutable repr_string : bytes;
mutable repr_len : int;
@
% this is how the line will be represented as a string, which
% is slighly different than the slice of text_string.
% this is useful for tabs, ^M, etc



<<[[Text.box]] other fields>>=
box_charsize : int; (* common size *)
box_size : int;
@
% for tabs, but also to display special chars like ^M with two chars.
%later: could be used for unicode stuff? hmmm need to change 
% how text_string is indexed too then. At least for unicode
% will see the characters?

<<[[Text.box]] other fields>>=
box_pos_repr : int;  (* pos of box in representation string *)
@


\subsection{[[Text.compute_representation()]]}

% most important is computing repr_string, and then the boxes
% which contain the appropriate colors for the different subparts
% of repr_string (boxes are used as index over repr_string with
% the attr info)

% this allow to handle variable-size characters in some sense
% e.g. 'a' vs '^M' vs 'TABS' so maybe this model can be used
% also for unicode?

<<function [[Text.compute_representation]]>>=
(* On devrait reprendre la representation la ou elle est ... *)
let compute_representation text charreprs n =
  <<[[Text.compute_representation]] if n is too big, return dummy line>>
  else
    let line = text.text_newlines.(n) in
    if line.line_modified then begin

      repr_string := line.repr_string;
      repr_len    := Bytes.length line.repr_string;
      let boxes = ref [] in

      let text_cursor = ref line.position in
      let repr_cursor = ref 0 in

      let end_pos = text.text_newlines.(n+1).position - 1 in

      <<[[Text.compute_representation()]] locals>>
      
      <<[[Text.compute_representation()]] adjust [[text_cursor]] if in gap>>
      while !text_cursor < end_pos do
        <<[[Text.compute_representation()]] loop [[text_cursor]] to [[end_pos]]>>
      done;
      <<[[Text.compute_representation()]] adjust line fields after loop>>
    end;
    line
[@@profiling]
@
%FIGURE: where see the different kind of pos. it's too complicated.
% cursor on text_string, and cursor on repr_string.
%old: was line_curs (line cursor), but I prefer text_cursor and repr_cursor.



<<[[Text.line]] other fields>>=
mutable line_modified : bool;
@
%old: was int before, see commented Optimisation section below,
% but I changed it to bool; simpler code.




<<[[Text.compute_representation()]] loop [[text_cursor]] to [[end_pos]]>>=
let charcode = Char.code (Bytes.get text.text_string !text_cursor) in
let charattr = text.text_attrs.(!text_cursor) in
let charrepr =
  <<[[Text.compute_representation()]] compute charrepr, special char>>
  else charreprs.(charcode) 
in
let charsize = String.length charrepr in

let box_len = ref 0 in

while !text_cursor < end_pos && 
  begin
    let char_code = Char.code (Bytes.get text.text_string !text_cursor)
    in
    let char_attr = text.text_attrs.(!text_cursor) in
    char_repr := 
       <<[[Text.compute_representation()]] compute [[char_repr]], special char>>
       else charreprs.(char_code);
    char_size := String.length !char_repr;

    !char_size = charsize && char_attr = charattr
  end
do
  <<[[Text.compute_representation()]] grow [[repr_string]] if needed>>
  String.blit !char_repr 0 !repr_string !repr_cursor charsize;
  repr_cursor := !repr_cursor + charsize;
  text_cursor := !text_cursor + 1;
  box_len := !box_len +1;
  <<[[Text.compute_representation()]] adjust [[text_cursor]] if reach gap>>
done;

let box = {
  box_col = !box_col_start;
  box_len = !box_len;
  box_attr = charattr;

  box_charsize = charsize;
  box_size = !box_len * charsize;
  box_pos_repr = !repr_start;
} in
repr_start := !repr_cursor;
box_col_start := !box_col_start + !box_len;
boxes := box :: !boxes;
@

%old: was using ==, not sure you need that
%    !char_size == charsize && charattr == text.text_attrs.(!text_cursor)


<<[[Text.compute_representation()]] locals>>=
let box_col_start = ref 0 in
let repr_start = ref 0 in

let char_repr = ref "" in
let char_size = ref 0 in
@


<<constant [[Text.repr_string]]>>=
let repr_string = ref (Bytes.of_string "")
@
<<constant [[Text.repr_size]]>>=
let repr_len = ref 0
@
%old: was repr_size, but better to match the fields

<<[[Text.compute_representation()]] grow [[repr_string]] if needed>>=
if !repr_cursor + charsize >= !repr_len then begin
    (* find a better heuristic to realloc the line string *)
    let new_len = !repr_len + 
        (low_distance text end_pos !text_cursor) + charsize * 2 
    in
    let new_repr = Bytes.create new_len in
    Bytes.blit !repr_string 0 new_repr 0 !repr_cursor;
    repr_string := new_repr;
    repr_len := new_len;
end;
@



<<[[Text.compute_representation()]] adjust line fields after loop>>=
line.boxes <- !boxes;
line.repr_string <- !repr_string;
line.repr_len <- !repr_cursor;
line.line_modified <- false;
@
%old: was line_modified <- -1; which now is false
% !repr_cursor maybe be smaller than !repr_len ?

\subsubsection{Gap management}

<<[[Text.compute_representation()]] locals>>=
let gpos = text.gpoint.pos in
let gsize = text.gsize in
@

<<[[Text.compute_representation()]] adjust [[text_cursor]] if in gap>>=
if !text_cursor >= gpos && !text_cursor < gpos + gsize 
then text_cursor := !text_cursor + gsize;
@

<<[[Text.compute_representation()]] adjust [[text_cursor]] if reach gap>>=
if !text_cursor = gpos 
then text_cursor := gpos + gsize;
@



\subsubsection{Dummy lines}

<<constant [[Text.dummy_line]]>>=
let (dummy_line : line) = 
  {
    position = max_int;
    boxes = [];
    repr_len = 0;
    repr_string = Bytes.of_string "";
    line_modified = true;
  } 
@
%old: was line_modified = 0;, but it should not be -1? (and so now false)

<<[[Text.compute_representation]] if n is too big, return dummy line>>=
if n >= text.text_nlines - 1 then begin
    dummy_line.position <- text.text_size;
    dummy_line
end
@



%\subsubsection{Optimisations}
%
%% useless opti I think; it complicates the code; I removed it.
%
%%old:
%%    if line.line_modified >= 0 then begin
%%
%%      repr_string := line.repr_string;
%%      repr_len    := String.length line.repr_string;
%%
%%      let (repr_tail, next_pos, repr_pos) = 
%%        next_pos_xxx line.line_modified line.boxes 
%%      in
%%      let end_pos = text.text_newlines.(n+1).position - 1 in
%%      let text_cursor = ref (line.position + next_pos) in
%%      let repr_cursor = ref repr_pos in
%
%
%<<[[Text.line]] other fields>>=
%mutable line_modified : int; (* first modified position *)
%@
%% -1 if not modified since last time (=~ false), see cancel_repr.
%% this is an opti, we could simply do line_modified: bool;
%% that force a (not so expensive) recomputation.
%
%
%<<function Text.next_pos_xxx>>=
%let rec next_pos_xxx line_modified boxes =
%  match boxes with
%  | [] -> [], 0, 0
%  <<[[Text.next_pos_xxx()]] if had some boxes already>>
%@
%% at the beginning there is no boxes at all, so next_pos and repr_pos
%% is really 0, 0
%
%
%<<[[Text.next_pos_xxx()]] if had some boxes already>>=
%| box :: tail ->
%    let next_pos = box.box_pos + box.box_len in
%    if next_pos < line_modified 
%    then boxes, next_pos, box.box_pos_repr + box.box_size
%    else next_pos_xxx line_modified tail
%@
%% the boxes are sorted in reverse! so the head is the last box
%% hence the code above
%
%let line_start = ref next_pos in
%let repr_start = ref repr_pos in
%let repr_tail = ref repr_tail in


\subsection{[[Text.cancel_repr()]]}

<<function [[Text.cancel_repr]]>>=
let cancel_repr text _point n =
  let line = text.text_newlines.(n) in
  line.line_modified <- true
@

%old: when had line_modified: int
%let cancel_repr text point n =
%  let line = text.text_newlines.(n) in
%  let pos =  point - line.position in
%  line.line_modified <- 
%    (if line.line_modified < 0
%    then pos
%    else min line.line_modified pos
%    )




\chapter{Main Top Window}

% menu
% windows/frames with buffers
% status line (for each frame get this actually)
% minibuffer (a single one)

% see graphics_graphics.ml

% good way I think to present the code, because people don't understand
% the code but they interstand the interface, so let's start
% from that!

\section{Menus}

<<toplevel [[Config]] menu settings>>=
let _ =
  <<[[Config]] file menu setup>>
  <<[[Config]] edit menu setup>>
  <<[[Config]] help menu setup>>
  <<[[Config]] buffers menu setup>>
@



%<<[[Top_window.create()]] create menus>>=
%(*
%  top#add_button "Buffers" (!buffers_menu top_window);
%  top#add_menu "File" (Array.map (fun (name,action) ->
%        wrap_item top_window (name, execute_action action)
%    ) (Array.of_list !!file_menu));
%  top#add_menu "Edit" (Array.map (fun (name,action) ->
%        wrap_item top_window (name, execute_action action)
%    ) (Array.of_list !!edit_menu));
%  List.iter (fun (menu_name, items) ->
%      top#add_menu menu_name 
%        (Array.map (fun (name,action) ->
%            wrap_item top_window (name, execute_action action)
%        ) (Array.of_list items))
%  ) !!menus;
%  top#add_separator;
%  top#add_menu "Help" (Array.map (wrap_item top_window) !help_menu);
%  top#show;
%*)
%@


\subsection{File menu}

<<constant [[Top_window.file_menu]]>>=
let file_menu = define_option ["file_menu"] "" (list_option string2_option) []
@

<<[[Config]] file menu setup>>=
if !!Top_window.file_menu = [] then begin
  Top_window.file_menu =:= [
    "Open File", "load_buffer";
    "Save Buffer", "save_buffer";
    <<file menu entries>>
    "", "";
    "Quit", "exit";
  ]
  end;
@
%old: open file was: (* "select_open_file";*)

% cool, everything is configurable :)



\subsubsection{Opening a file}

% C-x C-f!
<<loading keys>>=
[c_x; ControlMap, Char.code 'f'], Multi_buffers.load_buffer;
@


% in Complex because requires select and minibuffer
<<function [[Complex.load_buffer]]>>=
let load_buffer frame = 
  set_previous_frame frame;
  Select.select_file_from_pwd frame "Find file: " (fun str -> 
    Frame.load_file frame.frm_window str |> ignore
  )
[@@interactive]
@
%old:
% <<loading actions>>=
% (* C-x map *)
% define_action "load_buffer"  Complexe.load_buffer;
% @

% see later select_filename, quite complicated, use minibuffer
% and completion buffer. But nice that can use the buffer
% machinery for more complex interactions :)

%\subsection{Helpers}

<<function [[Frame.load_file]]>>=
let load_file window filename =
  let buf = Ebuffer.read filename (Keymap.create ()) in
  let frame = create window None buf in
  Hooks.exec_named_hooks !!change_buffer_hooks frame;
  status_name frame buf.buf_name;
  frame
@
% and then the auto redisplay after event will handle the rest!
%note: most of the time nobody uses the returned frame, but the server
% and eval_library uses it.

\l what if file already opened
<<function [[Ebuffer.read]]>>=
let read filename local_map =
  let edt = Globals.editor() in
  let filename = Utils.normal_name edt.edt_dirname filename in
  try
    Hashtbl.find edt.edt_files filename
  with Not_found ->
    let text =
      try
        let inc = open_in filename in
        let text = Text.read inc in         
        close_in inc; 
        text
      with exn -> 
        Error.error_exn (spf "error reading file %s" filename) exn;
        Text.create ""
    in
    let buf = create filename (Some filename) text local_map in
    Hashtbl.add edt.edt_files filename buf;
    buf
@
%todo: use realpath? normal_name?

<<function [[Text.read]]>>=
let read inc =
  create (Utils.read_string inc)
@

%\subsubsection{Normalized filenames}
% realpath? fullpath? Utils.normal_name?



%%less: optional I think, this use the toolkit to offer a file
%% browser, but could redirect instead to "load_buffer" which
%% use the minibuffer to open a file
%<<loading actions>>=
%define_action "select_open_file" select_open_file;
%@
%
%<<function Config.select_open_file>>=
%let select_open_file frame =
%  let window = frame.frm_window in
%  let _top_window = Window.top window in
%  let _cdir = Frame.current_dir frame in
%  failwith "Config.select_open_file???"
%(*
%  let info = {
%      filter = Filename.concat cdir "*";
%      current_selection = cdir;
%      predicat = (fun _ -> true);
%      action = (fun _ -> ());
%      cancel = (fun _ -> ());
%    } in
%
%  (* X11 *)
%  let query = new WX_filesel.t top_window.top_root info [] in
%  query#setWM_TRANSIENT_FOR (top_window.top_appli#top :> WX_types.container);
%  info.action <- (fun name ->
%      wrap top_window (fun top_window ->
%          query#destroy;
%          Frame.load_file window name |> ignore
%      ) ());
%  info.cancel <- (fun () ->
%      wrap top_window (fun top_window ->
%          query#destroy;
%      ) ());        
%  query#show
%*)
%@



\subsubsection{Inserting a file}
% not in the menu, but related

<<loading keys>>=
[c_x; NormalMap, Char.code 'i'], Multi_buffers.insert_file;
@

<<function [[Complex.insert_file]]>>=
let insert_file frame =
  Select.select_file_from_pwd frame "Insert file: " (fun str ->
    let inc = open_in str in
    Edit.insert_string frame (Utils.read_string inc);
    close_in inc
  )
[@@interactive]
@
%old:
% <<loading actions>>=
% (* C-x map *)
% define_action "insert_file"  Complexe.insert_file;
% @

<<function [[Simple.insert_string]]>>=
let insert_string frame str =
  let (_, text, point) = Frame.buf_text_point frame in
  Text.insert text point str;
  Text.fmove text point (String.length str)
@




\subsubsection{Saving the buffer}

<<saving keys>>=
[c_x; ControlMap, Char.code 's'], Multi_buffers.save_buffer; 
@

<<function [[Complex.save_buffer]]>>=
let save_buffer frame =
  let buf = frame.frm_buffer in
  match buf.buf_filename with
  | Some _ -> Ebuffer.save buf
  | None -> write_buffer frame
[@@interactive]
@
%old:
% <<saving actions>>=
% (* C-x map *)
% define_action "save_buffer"  Complexe.save_buffer; 
% @


<<[[Efuns.buffer]] history fields>>=
mutable buf_last_saved : Text.version;
@
% for the ** in the status line.

<<function [[Ebuffer.save]]>>=
let save buf =
  Hooks.exec_named_buf_hooks_with_abort !!save_buffer_hooks buf;

  let filename =
    match buf.buf_filename with
      None -> raise Not_found
    | Some name -> name
  in
  let outc = open_out filename in
  Text.save buf.buf_text outc;
  close_out outc;
  buf.buf_last_saved <- Text.version buf.buf_text;

  let hooks = try Var.get_var buf saved_buffer_hooks with Not_found -> [] in
  Hooks.exec_hooks hooks buf
@
%bug: was saved_xxx two times before
%old: was using Option.t (!!) for saved_buffer_hooks, but more useful
% to use a Var.t
%  Hook.exec_named_buf_hooks !!saved_buffer_hooks buf

<<function [[Text.save]]>>=
let save text outc =
  let str = text.text_string in
  let gpos = text.gpoint.pos in
  let gsize = text.gsize in
  output outc str 0 gpos;
  (* skipping the gap *)
  output outc str (gpos + gsize) (text.text_size - gpos - gsize)
@


\subsubsection{Save and change buffer hooks}
% reload

% see also in core DS chapter
% - create_buf_hook  (check_file)
% - change_buffer_hooks
% - save_buffer_hooks
% - saved_buffer_hooks


<<constant [[Ebuffer.saved_buffer_hooks]]>>=
let saved_buffer_hooks = Store.create_abstr "saved_buffer_hooks"
@
%old:
% let saved_buffer_hooks = define_option ["saved_buffer_hooks"] "" 
%    (list_option string_option)
%  ["update_time" ]
% but more flexible to use a Var (so can customize it in a major mode)
%old:
% <<misc actions>>=
% define_buffer_action "update_time" Complexe.update_time;
% @

%\subsubsection{Vars}

<<constant [[Complex.buf_mtime]]>>=
let buf_mtime = Store.create_float "buf_mtime"
@
% why not create_float then?
% who uses this local var? update_time below sets it, but who uses it?
% check_files uses it, which is in change_buffer_hook

<<function [[Complex.update_time]]>>=
let update_time buf =
  try
    buf.buf_filename |> Option.iter (fun file ->
      let st = Unix.lstat file in
      if st.Unix.st_kind = Unix.S_REG 
      then Var.set_local buf buf_mtime st.Unix.st_mtime;
    )
  with _ -> ()
@


% load_file | change_buffer -> <> (as change_buffer_hook <- add_hook(<>))
<<function [[Complex.check_file]]>>=
let check_file frame =
  try
    let buf = frame.frm_buffer in
    buf.buf_filename |> Option.iter (fun file ->
      let st = Unix.lstat file in
      if st.Unix.st_kind = Unix.S_REG then
        try
          let time = Var.get_local buf buf_mtime in
          Var.set_local buf buf_mtime st.Unix.st_mtime;
          if time <> st.Unix.st_mtime then
            (Select.select_yes_or_no frame 
               (Printf.sprintf "%s changed on disk; reload (y/n) ?" 
                    buf.buf_name) 
                (fun bool ->
                   if bool 
                   then reload frame 
                   else Frame.status_modified frame true
                 )) |> ignore
       with _ -> Var.set_local buf buf_mtime st.Unix.st_mtime
    )
  with _ -> ()
[@@interactive]
@
%less: should do that at each keystroke, not just at change_buffer



\subsubsection{More saving operations}

<<saving keys>>=
[c_x; NormalMap,  Char.code 's'], Multi_buffers.save_some_buffers;
[c_x; ControlMap, Char.code 'w'], Multi_buffers.write_buffer; 
@


<<function [[Complex.save_some_buffers]]>>=
let save_some_buffers frame =
  let buffers = Utils.list_of_hash (Globals.editor()).edt_buffers in
  save_buffers_and_action frame buffers (fun _ -> ())
[@@interactive]
@
%old:
% <<saving actions>>=
% (* C-x map *)
% define_action "save_some_buffers"  Complexe.save_some_buffers;
% (* C-x map *)
% define_action "write_file"  Complexe.write_buffer; 
% @

<<function [[Complex.write_buffer]]>>=
let write_buffer frame = 
  let buf = frame.frm_buffer in
  Select.select_file_from_pwd frame "Save file as: " (fun str -> 
    Ebuffer.change_name buf str;
    Ebuffer.save buf
  )
[@@interactive]
@

%\subsection{Helpers}
<<function [[Frame.save_buffer]]>>=
let save_buffer frame =
  Ebuffer.save frame.frm_buffer
@
% dead?



<<exception [[Ebuffer.BufferAlreadyOpened]]>>=
exception BufferAlreadyOpened
@

% like for Ebuffer.read, ensure some unicity for filename
<<function [[Ebuffer.change_name]]>>=
let change_name buf filename =
  let edt = Globals.editor() in
  Hashtbl.remove edt.edt_buffers buf.buf_name;
  buf.buf_filename |> Option.iter (fun filename ->
    Hashtbl.remove edt.edt_files filename
  );
  let filename = 
    if Filename.is_relative filename 
    then Filename.concat edt.edt_dirname filename
    else filename
  in
  if Utils.hashtbl_mem edt.edt_files filename
  then raise BufferAlreadyOpened;
  let filename = Utils.normal_name edt.edt_dirname filename in
  let name = get_unique_name filename in
  Hashtbl.add edt.edt_buffers name buf;
  Hashtbl.add edt.edt_files filename buf;
  buf.buf_filename <- Some filename;
  buf.buf_name <- name
@
% realpath here too? normal_name seems good,
% but why do the test on the hashtbl before??


<<function [[Complex.save_buffers_and_action]]>>=
let rec save_buffers_and_action frame buffers action =
  match buffers with
    [] -> let () = action frame in ()
  | (_,buf) :: buffers ->
      let text = buf.buf_text in
      if buf.buf_last_saved = Text.version text  ||
        buf.buf_name.[0] = '*'
      then
        save_buffers_and_action frame buffers action
      else
      let map = Keymap.create () in
      let request = Printf.sprintf "Save buffer %s ? (y,n,!,a)" buf.buf_name
      in
      let yes mini_frame =
        Minibuffer.kill mini_frame frame;
        Ebuffer.save buf;
        save_buffers_and_action frame buffers action
      in
      let no mini_frame =
        Minibuffer.kill mini_frame frame;
        save_buffers_and_action frame buffers action; ()
      in
      let action_immediately mini_frame = 
        Minibuffer.kill mini_frame frame;
        let () = action mini_frame in ()
      in
      let abort mini_frame =
        Minibuffer.kill mini_frame frame
      in
      Keymap.add_binding map [NormalMap, Char.code 'y'] yes;
      Keymap.add_binding map [NormalMap, Char.code 'Y'] yes;
      Keymap.add_binding map [NormalMap, Char.code 'n'] no;
      Keymap.add_binding map [NormalMap, Char.code 'N'] no;
      Keymap.add_binding map [NormalMap, Char.code '!'] action_immediately;
      Keymap.add_binding map [NormalMap, Char.code 'a'] abort;
      Keymap.add_binding map [NormalMap, Char.code 'A'] abort;
      Keymap.add_binding map [ControlMap, Char.code 'g'] abort;
      Minibuffer.create frame map request |> ignore
@
\t move later? too early? use too many concepts

\subsubsection{Exit}

<<misc keys>>=
[c_x; ControlMap, Char.code 'c'], Misc_features.exit; 
@

<<function [[Complex.exit_efuns]]>>=
let exit frame =
  let buffers = Utils.list_of_hash (Globals.editor()).edt_buffers in
  let hooks = Var.get_global exit_hooks in
  Hooks.exec_hooks hooks ();
  Multi_buffers.save_buffers_and_action frame buffers (fun _ -> 
    raise (Common.UnixExit 0)
  )
[@@interactive]
@
%old:
% <<misc actions>>=
% (* C-x map *)
% define_action "exit"  Complexe.exit_efuns; 
% @


%(*Graphics.close_graph ();*)

\subsection{Edit menu}

<<constant [[Top_window.edit_menu]]>>=
let edit_menu = define_option ["edit_menu"] "" (list_option string2_option) []
@

<<[[Config]] edit menu setup>>=
if !!Top_window.edit_menu = [] then begin
    Top_window.edit_menu =:= [ 
      "Cut",    "kill_region";
      "Paste",  "insert_killed";

      "Undo",    "undo";
      "", "";
      <<[[edit_menu]] entries>>
    ];
  end;
@
% will see later

\subsection{Buffers menu}

% will see later again

\subsection{Help menu}

<<constant [[Top_window.help_menu]]>>=
let help_menu = ref ([| |]: (string * action) array)
@
% this one is not configurable apparently, and so use ref instead of option
% was an array, need an array?

<<[[Config]] help menu setup>>=
Top_window.help_menu := [|
  "Key Bindings", (fun frame ->
    Frame.change_buffer frame.frm_window "*bindings*"
  );
  "About Efuns", (fun frame ->
    Frame.change_buffer frame.frm_window "*help*"
  );
  "Changes", (fun _frame ->
    (*
      let _ = Frame.load_file frame.frm_window (
          Version.efuns_lib ^"/Changes") in ()
    *)
    failwith "Std_xxx.menu changes: TODO"
  );
|];
@
% see Frame.change_buffer later

%dead:?
%   (*
%        let top_window = Window.top frame.frm_window in        
%        let dialog = new WX_dialog.t top_window.top_root 
%            "Efuns,\nVersion 015\nFabrice Le Fessant\nFabrice.Le_Fessant@inria.fr" [] in
%        dialog#add_button "OK" (fun _ -> dialog#destroy);
%        dialog#show;
%    *)




\section{Sub-windows}
% Frames

\subsection{Frames and windows creation}

% have see create_without_top() in core DS chapter
% and its use in Top_window.create in the main chapter.
% Will see later more functions to create frames.

% let's see Frame.install though.


% ((Top_window.create | ...) -> Frame.create_without_top) | v_cut | ... -> <>
<<function [[Frame.install]]>>=
let install window frame =
  <<[[Frame.install()]] sanity check frame is not a minibuffer>>

  window |> Window.iter (fun f -> 
     (* TODO? != or <> ? *)
     if (Common.phys_not_equal f frame) 
     then kill f
  );
  window.win_down <- WFrame frame;

  frame.frm_xpos <- window.win_xpos;
  frame.frm_ypos <- window.win_ypos;
  frame.frm_width <- window.win_width;
  frame.frm_height <- window.win_height;
  frame.frm_window <- window;

  <<[[Frame.install()]] adjust [[frm_cutline]]>>
  <<[[Frame.install()]] set [[frm_table]]>>
  frame.frm_redraw <- true
@
%less: rename prepare_for_display?

% kill all the frame! that's how you get the buffer ref down to zero.
% so by using Frame.create frm.frm_window you in effect kill the
% previous frame.

\subsection{Windows display}

% Seen before the iteration Window.iter in Top_window.update_display.
% Will focus on one window (frame) display.

\subsection{Frame display}

% the redisplay function!!!

%later: tile-based opti
% see http://blog.atom.io/2015/06/24/rendering-improvements.html


\subsubsection{[[Frame.display()]]}

% (main -> Graphics.init | event loop -> ...) -> Top_window.update_display -> <>
% called for each frame (including the minibuffer's frame when in use)
<<function [[Frame.display]]>>=
let display top_window frame =
  let (buf, text, point) = buf_text_point frame in

  let width = frame.frm_width in
  let height = frame.frm_height - frame.frm_has_status_line in

  let graphic = Efuns.backend top_window in

  <<[[Frame.display()]] if buf sync goto end of text>>
  if
    <<[[Frame.display()]] conditions for redraw>>
  then begin
    <<[[Frame.display()]] redraw>>
  end;
  <<[[Frame.display()]] draw status line or minibuffer>>
[@@profiling]
@
% was called Frame.update, but I prefer Frame.display,
% to avoid all those update_xxx that are not in the same category
% (e.g.  update_line, update_table, etc)
%old:   let width = frame.frm_width - frame.frm_has_scrollbar in


\subsubsection{Frame decorations display}

%old:
%<<[[Efuns.frame]] decoration fields>>=
%(* 0 for no scrollbar, 2 for scrollbar *)
%mutable frm_has_scrollbar : int;
%@

<<[[Efuns.frame]] decoration fields>>=
(* 0 for minibuffer, 1 for normal frame *)
mutable frm_has_status_line : int;
(* Some for minibuffer, None for normal frame *)
mutable frm_mini_buffer : string option;
@
% Some means it's a mini buffer frame, in which case
% we don't want status line
%less: redundant frm_has_status_line?

<<[[Frame.display()]] draw status line or minibuffer>>=
match frame.frm_mini_buffer with
| None -> 
    <<[[Frame.display()]] draw status line>>
| Some request ->
    <<[[Frame.display()]] draw minibuffer request string>>
@
% hmm but if minibuffer, it will also redraw its content?
% no cos minibuffer is one line? so does not move?


% will see later those special draw.
% Let's go back to the main window for now.

\subsubsection{Conditions for redraw}

<<[[Frame.display()]] conditions for redraw>>=
<<[[Frame.display()]] conditions for redraw, point outside frame>>
<<[[Frame.display()]] conditions for redraw, buffer modified>>
<<[[Frame.display()]] conditions for redraw, forced redraw>>
@

% a frame is a view over a buffer, from line x to line y
% and cursor at point.

<<[[Efuns.frame]] current position fields>>=
(* first point of the first buffer-line on screen *)
mutable frm_start : Text.point;
(* last point on screen, -1 if modified *)
mutable frm_end : Text.point;
@


<<[[Frame.display()]] conditions for redraw, point outside frame>>=
(point < frame.frm_start) ||
(point > frame.frm_end)  || 
@
% > ?? because use the first field anyway?



<<[[Efuns.frame]] history fields>>=
mutable frm_last_text_updated : int;
mutable frm_last_buf_updated : int;
@
% frm_last_text_updated actually seems to decrement in undo
% and seems used only there

% so if have 2 frames on the same buffer, then
% modifying in one frame will cause the other frame to be updated too.

<<[[Frame.display()]] conditions for redraw, buffer modified>>=
(version text <> frame.frm_last_text_updated) ||
(buf.buf_modified <> frame.frm_last_buf_updated) ||
@
% when the text can be modified?? when a buffer can be modified?

<<[[Efuns.frame]] other fields>>=
mutable frm_redraw : bool;    
@
% when switch back or create a new frame, nothing has
%  been computed in frm_table, so we force a redraw.
% Used also when modify some text in which case we don't
% need to redraw the other lines. But if we end up scrolling,
% then we want to redraw all the lines.

<<[[Frame.display()]] conditions for redraw, forced redraw>>=
frame.frm_redraw
@

% if you modify frm_start, you want to redraw, even if
% the point is always in the range frm_start..frm_end

\subsubsection{Redraw}

<<[[Frame.display()]] redraw>>=
if !Globals.debug_display
then UCommon.pr2 "redraw";
<<[[Frame.display()]] redraw, possibly update [[frm_y_offset]]>>
<<[[Frame.display()]] redraw, possibly update [[frm_x_offset]]>>
(* invariant: now frm_start is at a bol *)
update_table frame;
(* invariant: now frm_end has been correctly set *)

if (point > frame.frm_end) || (point < start) then begin
    <<[[Frame.display()]] redraw, if [[frm_force_start]]>>
    else begin
      (* center around point *)
      Text.goto_point text start point;
      <<[[Frame.display()]] redraw, update [[frm_y_offset]] again>>
      (* invariant: now frm_start is at a bol again *)
      update_table frame;
   end
end;

frame.frm_force_start <- false;

frame.frm_last_text_updated <- version text;
frame.frm_last_buf_updated <- buf.buf_modified;

for y = 0 to height - 1 do
  <<[[Frame.display()]] redraw, draw line y if line changed>>
done;
frame.frm_redraw <- false
@
%bug:! there was a point > start instead of point < start!
% so then when going back it was not redisplaying!
% it's because of some past (wrong) refactoring,
% because before it was 'if (frame.frm_end < point)  || (start > point)'
%old:
% <<[[Frame.display()]] redraw, scrollbar adjustments>>

% need to do the first update_table when point outside <frm_start,frm_end>?
% seems unecessary. Then we could have a proper if then else with
% the second update_table.

\subsection{Line display, cutting long lines}

% text -> x,y display (and cursor below is the reverse)

% data -> text_string -> 
% text_newlines -> 
%  repr_string (^M) ->
% frm_table ->
%  frm_line (\)

%FIGURE:! where see how text_string with special char
% lead to a different repr_string which then when too longs leads
% to multiple frm_line for one of text_newlines.

% frame have a width!

<<[[Efuns.frame]] other fields>>=
(* where do we put a \ for overflowing lines *)
mutable frm_cutline : int; (* max_int for no, else length *)
@
%e.g. 79, the width of the window - 1 (because 0 indexed so col 79)

<<[[Frame.install()]] adjust [[frm_cutline]]>>=
if frame.frm_cutline < max_int 
then frame.frm_cutline <- window.win_width - 1;
@

% below we will try to consistently use col line (text_string) vs xy (repr)
% and actually there is even xy in frame, and xy in screen
% (see Frame.move_point). Need more types!


\subsubsection{The frame table}
%[[Frame.update_table()]]

<<[[Efuns.frame]] other fields>>=
mutable frm_table : frm_line array;
@
% line 0 is the line that you see in the frame,
% so this table is a sort of slice of the original text_newlines.
% But it also manages the overflow lines! so it's not exactly a slice!
% diff with frm.frm_buffer.buf_text.newlines? well it handles overflow
% some some Text.line corresponds sometimes to 2 frm_line, but
% with different repr_xxx values.

<<type [[Efuns.frm_line]]>>=
and frm_line =
  { 
    mutable frm_text_line : Text.line;

    (* sorted normally, head = first box in line *)
    mutable frmline_boxes : Text.box list; 
    mutable first_box_extra_offset : int;

    <<[[Efuns.frm_line]] other fields>>
  } 
@
%old: was line_repr (or repr_line), but there was also line_repr, so better
% rename this frm_line. otherwise had line_repr.repr_line.boxes.box_pos, hmmm
%old: was repr_y, repr_x, repr_offset, but again, there was
% too many repr_xxx where actually you don't know what they reference
% (text_string? text_newlines? repr_string? frm_table?)
%dead: repr_x, was not used.

%why need frmline_boxes? why not use frm_text_line.repr_reprs instead?
% because it could have changed in the mean time? 
% it is mainly for the overflow I think, in which case the boxes are 
% actually different!

%why need frm_text_line then? just for the repr_string it contains?
% then why not replace frm_text_line by that then? It's used for ==
% another line in set_cursor, so maybe it's needed.


<<[[Efuns.frm_line]] other fields>>=
mutable lineidx_in_text : int;
@
% why need that? frm_text_line not enough? for cursor_to_coord?
%less: mv later?
% anyway can be good to show that frm_line do not match directly
% text_newlines table


<<[[Frame.install()]] set [[frm_table]]>>=
frame.frm_table <- (Array.init window.win_height (fun _i -> 
   {
     frm_text_line = Text.dummy_line;
     frmline_boxes = [];

     lineidx_in_text = 0;
     first_box_extra_offset = 0;

     repr_prev_offset = 0;
     prev_frmline_boxes = [];
   } 
));
@

\subsubsection{[[Frame.update_table()]]}

% y goes from 0 to height below, which are the entries
% for frm_table that we need to fill.

% pre? start is at a bol?
% Top_window.update_display -> Frame.display -> <>
<<function [[Frame.update_table]]>>=
let update_table frame =
  let (buf, text, _) = buf_text_point frame in

  let start = frame.frm_start in
  let height = frame.frm_height - frame.frm_has_status_line in

  let current_n = ref (Text.point_line text start) in
  let current_line = ref (Ebuffer.compute_representation buf !current_n) in

  <<[[Frame.update_table()]] adjust current line when [[frm_y_offset]] negative>>
  <<[[Frame.update_table()]] adjust current line when [[frm_y_offset]] positive>>

  (* update frame.frm_start *)
  Text.goto_line text start !current_n; 

  (* update frame representation *)
  <<function [[Frame.update_table.iter_line]]>>
  <<function [[Frame.update_table.iter_repr]]>>

  iter_line (- frame.frm_y_offset) !current_n !current_line
[@@profiling]
@


<<function [[Frame.update_table.iter_line]]>>=
let rec iter_line y n line =
  if y < height then begin
    let reprs = List.rev line.boxes in
    if y >= 0 then begin
        let frm_line = frame.frm_table.(y) in
        frm_line.frm_text_line <- line;
        frm_line.frmline_boxes <- reprs;
        frm_line.lineidx_in_text <- n;
        frm_line.first_box_extra_offset <- 0;
    end;
    iter_repr frame.frm_cutline (y+1) n line reprs
  end
  else Text.goto_line text frame.frm_end (n-1)
@
% setting frm_end!!

<<function [[Frame.update_table.iter_repr]]>>=
and iter_repr xcutline y n line boxes =
  <<[[Frame.update_table.iter_repr()]] if line too big>>
  else  
    let line = Ebuffer.compute_representation buf (n+1) in
    iter_line y (n+1) line
in
@


\subsubsection{[[Frame.display_line()]]}

%old: was called update_line, but was a good name? 
% as opposed to update_table, here it's more
% about the display that updating some internal structure. 
% So I renamed it.

<<[[Frame.display()]] redraw, draw line y if line changed>>=
let frm_line = frame.frm_table.(y) in

if not ((Common.phys_equal frm_line.prev_frmline_boxes frm_line.frmline_boxes) &&
        (Common.phys_equal frm_line.repr_prev_offset frm_line.first_box_extra_offset)) 
   || frame.frm_redraw
then
  begin
    frm_line.prev_frmline_boxes <- frm_line.frmline_boxes;
    frm_line.repr_prev_offset <- frm_line.first_box_extra_offset;

    display_line graphic frame 
        (Bytes.to_string frm_line.frm_text_line.repr_string)
        y;
  end;
@
%todo: old: was line.repr_line.repr_string, ugly

<<[[Efuns.frm_line]] other fields>>=
(* previous values, so can check if the line changed *)
mutable repr_prev_offset : int;
mutable prev_frmline_boxes : Text.box list;
@
% it's an opti, not sure it's that useful

% finally reach the graphic backend!

<<function [[Frame.display_line]]>>=
let display_line graphic frame repr_string y = 
  let frm_line = frame.frm_table.(y) in

  let rec iter x offset boxes =
    if x < frame.frm_width then
      match boxes with
      | [] -> 
          graphic.Xdraw.clear_eol (x+frame.frm_xpos) (y+frame.frm_ypos)
            (frame.frm_width - x)
      | box :: tail ->
          let len = min (frame.frm_width-x) (box.box_size - offset) in
          graphic.Xdraw.draw_string (x+frame.frm_xpos) (y+frame.frm_ypos)
            repr_string (box.box_pos_repr+offset) len
            box.box_attr;
          iter (x+len) 0 tail
    else
      <<[[Frame.display_line()]] in iter, line overflow [[frm_width]]>>
  in
  iter 0 (frm_line.first_box_extra_offset + frame.frm_x_offset) frm_line.frmline_boxes
@
%old: was called update_line, but confusing with update_table
% which is quite different.

\subsubsection{Overflowing lines}


% xcutline is originally frm_cutline = frm_width - 1
<<[[Frame.update_table.iter_repr()]] if line too big>>=
if line.repr_len > xcutline then
  match boxes with
  | box :: tail ->
      if box.box_pos_repr <= xcutline && 
         box.box_pos_repr + box.box_size > xcutline
      then
        if y =|= height 
        then Text.goto_line text frame.frm_end n 
        else begin
            if y>= 0 then begin
              let frm_line = frame.frm_table.(y) in
              frm_line.frm_text_line <- line;
              frm_line.lineidx_in_text <- n;
              frm_line.first_box_extra_offset <- xcutline - box.box_pos_repr;
              frm_line.frmline_boxes <- boxes;
            end;
            iter_repr (xcutline+frame.frm_cutline) (y+1) n line boxes
        end
      else iter_repr xcutline y n line tail
  | [] -> 
      let line = Ebuffer.compute_representation buf (n + 1) in
      iter_line (y+1) (n+1) line
@
% generate multi frm_line for one text_newline
%old: frm_line.repr_x <- repr.box_pos_repr;

%FIGURE: again, where see skip the first few boxes, because
% they are handled by the previous line, and will not overflow
% because of the code below:

<<[[Frame.display_line()]] in iter, line overflow [[frm_width]]>>=
graphic.Xdraw.draw_string 
   (frame.frm_width+frame.frm_xpos-1) (y+frame.frm_ypos)
   "/" 0 1 Text.direct_attr
@
% the / at the end of the line!


\subsection{Cursor display}
% Focus just on cursor display? will see more code in the Mouse section?

% pretty important :) when I did the plan9 port there was no cursor
% at the beginning and it's really annoying

% The flow is that some functions modify top_active_frame.frm_point
% (and sometimes also modify first top_active_frame), and now we need to put
% the cursor at the right place.
% Because of tabs and ^M and frm_cutline there are a few complications.

% we need to redo some of the logic done by update_table where
% we need to manage frm_cutline because we don't want to polluate
% update_table with cursor issues I think.

\subsubsection{Cursor on}

% Top_window.update_display -> Frame.display ; ...;  <>
<<function [[Top_window.cursor_on]]>>=
let cursor_on top_window =
  let frame = top_window.top_active_frame in
  set_cursor_on top_window frame;
  <<[[Top_window.cursor_on()]] set top window name>>
  <<[[Top_window.cursor_on()]] display secondary cursor>>
@
% when can have second_cursor? for C-s! you edit in mini_frame
%  but the cursor is on the searched frame



<<[[Efuns.frame]] other fields>>=
(* frame coordinates, so x is between 0 and frm_width - 1 *)
mutable frm_cursor_x : int;
(* frame coordinates, so y is between 0 and frm_height - 1 *)
mutable frm_cursor_y : int;

mutable frm_cursor : bytes;
mutable frm_cursor_attr : Text.attribute;
@
% a frame has a cursor!
% x and y here are coordinates in the frame, not top_window coordinates,
% and not text_string coordinates.
% frm_cursor and frm_cursor_attr are the old value, what text
% was under the cursor before (a string because of compute_representation)



<<function [[Top_window.set_cursor_on]]>>=
let set_cursor_on top_window frame = 
  Frame.set_cursor frame;

  if (Bytes.get frame.frm_cursor 0) <> '\000' then
    let graphic = Efuns.backend top_window in
    graphic.Xdraw.draw_string
      (frame.frm_xpos + frame.frm_cursor_x-frame.frm_x_offset)
      (frame.frm_ypos + frame.frm_cursor_y) 
      (Bytes.to_string frame.frm_cursor) 0 1 Text.inverse_attr
@
% ugly \000 special trick.


<<function [[Frame.set_cursor]]>>=
let set_cursor frame =
  let (buf, text, point) = buf_text_point frame in

  match point_to_xy_opt frame point with
  | None ->
      (* insert cursor is not on frame *)
      Bytes.set frame.frm_cursor 0 '\000'
  | Some (x, y) ->
      frame.frm_cursor_x <- x;
      frame.frm_cursor_y <- y;
      let col = point_col text point in
      let line_ = point_line text point in
      let line = Ebuffer.compute_representation buf line_ in

      let rec iter boxes =
        match boxes with
        | [] -> 
            Bytes.set frame.frm_cursor 0 ' '
        | box :: tail ->
            if box.box_col <= col && box.box_col + box.box_len > col
            then begin
              let pos_repr =
                box.box_pos_repr + box.box_charsize * 
                (col - box.box_col)
              in
              Bytes.set frame.frm_cursor 0 
                  (Bytes.get line.repr_string pos_repr);
              frame.frm_cursor_attr <- box.box_attr;
            end else
              iter tail
      in
      let frm_line = frame.frm_table.(frame.frm_cursor_y) in
      iter frm_line.frmline_boxes
@

\subsubsection{Point coordinates vs xy screen coordinates}

<<function [[Frame.point_to_xy_opt]]>>=
let point_to_xy_opt frame point =
  let (buf, text, _) = buf_text_point frame in

  let x_nocut = point_to_x_when_no_cutline buf point in
  let line = Ebuffer.compute_representation buf (point_line text point) in

  let xref = ref 0 in
  let yref = ref 0 in
  
  try
    for i = 0 to frame.frm_height - 1 do
      let line_repr = frame.frm_table.(i) in
      if Common.phys_equal line_repr.frm_text_line line then
        let x,y =
          if x_nocut =|= 0 
          then 0,i
          else
            <<[[Frame.point_to_xy_opt()]] x y value handling overflow lines>>
        in
        xref := x;
        yref := y;
        raise Exit
    done;
    None
  with Exit ->
    Some (!xref, !yref)
@
%pad: I added this function. This simplify Frame.set_cursor by 
% extracting lots of code from it

% x is not 0
<<[[Frame.point_to_xy_opt()]] x y value handling overflow lines>>=
((x_nocut-1) mod frame.frm_cutline) + 1, i + (x_nocut-1) / frame.frm_cutline
@
% ex: x = 1, cutline = 80 => x = 1, y = i, x = 80 => x = 80, y = i
%  x = 82 => x =  2, y = i + 1



% set_cursor -> <>
<<function [[Frame.point_to_cursor]]>>=
let point_to_x_when_no_cutline buf point =
  let text = buf.buf_text in
  let line = Ebuffer.compute_representation buf (Text.point_line text point) in
  let xpos = Text.point_col text point in
  let rec iter boxes =
    match boxes with
    | [] -> 0
    | box :: tail ->
        if xpos < box.box_col
        then iter tail
        else box.box_pos_repr + box.box_charsize *  (xpos - box.box_col)
  in
  iter line.Text.boxes
@
%todo: compare xpos to box.box_pos????? when is a col, the other a position2
%note: remember that the boxes are sorted in reverse, head is last box
%old: was point_to_cursor, but it's actually just one part
% of the cursor, and it's not even an x! it's an x when have no cutline
%note: have a point_to_y where do the iteration over frm_table?
% but harder cos point_to_y will also compute point_to_x, so the
% best I can do is point_to_xy_opt that calls point_to_x_...


%\subsection{[[Top_window.clean_display()]]}
\subsubsection{Cursor off}

% event loop -> ... -> handle_key -> ...; <>; Top_window.update_display()
<<function [[Top_window.clean_display]]>>=
let clean_display () =
  (Globals.editor()).top_windows |> List.iter (fun top_window ->
     cursor_off top_window;
     <<[[clean_display()]] sanity check second cursor and minibuffer>>
   )
@

% update_display -> clean_display -> <>
<<function [[Top_window.cursor_off]]>>=
let cursor_off top_window =
  let frame = top_window.top_active_frame in
  set_cursor_off top_window frame;
  <<[[Top_window.cursor_off()]] hide secondary cursor>>
@

<<function [[Top_window.set_cursor_off]]>>=
let set_cursor_off top_window frame =
  if (Bytes.get frame.frm_cursor 0) <> '\000' then
    let graphic = Efuns.backend top_window in
    graphic.Xdraw.draw_string
      (frame.frm_xpos + frame.frm_cursor_x) 
      (frame.frm_ypos + frame.frm_cursor_y) 
      (Bytes.to_string frame.frm_cursor) 0 1 frame.frm_cursor_attr
@

\subsection{Frame offsets}

<<[[Efuns.frame]] other fields>>=
(* offset(+/-) of screen-lines after frm_start *)
mutable frm_y_offset : int;
(* ?? *)
mutable frm_x_offset : int;
@
% screen lines! not text lines

% why not modify instead frm_start and decrement its line?
% because we don't know how many text lines translate in frame lines
% because of the compute_representation and the 80col overflow.



\subsubsection{Y offset}

<<[[Frame.display()]] redraw, possibly update [[frm_y_offset]]>>=
let start = frame.frm_start in
let start_c = point_to_x_when_no_cutline buf start in
if start_c > 0 then begin
  frame.frm_y_offset <- frame.frm_y_offset - start_c / frame.frm_cutline;
  Text.bmove text start start_c
end;
@
% when can this happen? someone mv frm_start to a col > 0?
% in which case we adjust to the bol? but why need
% to adjust frm_y_offset?
% because we may have used already a screenline by relocating frm_start?


% do 'Text.goto_point text start point', when want to recenter
% on the point that moved outside the current frame, so for
% sure start may not be in col 0, so need to adjust.

<<[[Frame.display()]] redraw, update [[frm_y_offset]] again>>=
frame.frm_y_offset <- - height / 2;
let start_c = point_to_x_when_no_cutline buf start in
if start_c > 0 then begin
  frame.frm_y_offset <- frame.frm_y_offset - start_c / frame.frm_cutline;
  Text.bmove text start start_c
end;
@





<<[[Frame.update_table()]] adjust current line when [[frm_y_offset]] positive>>=
(* assert current_line is the first line *)

while frame.frm_y_offset > !current_line.repr_len / frame.frm_cutline
    && !current_n < nbr_lines text
do
  frame.frm_y_offset <- frame.frm_y_offset - 
    (!current_line.repr_len / frame.frm_cutline) - 1;
  current_n := !current_n + 1;
  current_line := Ebuffer.compute_representation buf !current_n;
done;

if !current_n =|= nbr_lines text && 
   frame.frm_y_offset > !current_line.repr_len / frame.frm_cutline
then frame.frm_y_offset <- !current_line.repr_len / frame.frm_cutline;
@

<<[[Frame.update_table()]] adjust current line when [[frm_y_offset]] negative>>=
(* assert frame.frm_y_offset >= 0 *)

while frame.frm_y_offset < 0 && !current_n > 0 do
  current_n := !current_n - 1;
  current_line := Ebuffer.compute_representation buf !current_n;
  let lines = !current_line.repr_len / frame.frm_cutline in
  frame.frm_y_offset <- frame.frm_y_offset + lines + 1;
done;
if !current_n =|= 0 && frame.frm_y_offset <0 
then frame.frm_y_offset <- 0;
@

\subsubsection{X offset}

<<[[Frame.display()]] redraw, possibly update [[frm_x_offset]]>>=
let point_c = point_to_x_when_no_cutline buf point in
if point_c < frame.frm_x_offset then begin
    frame.frm_x_offset <- max (point_c - width / 2) 0;
    frame.frm_redraw <- true;
end else if frame.frm_cutline =|= max_int && 
            (point_c mod frame.frm_cutline >= frame.frm_x_offset + width - 3)  
  then begin
    frame.frm_x_offset <- point_c - (width / 2);
    frame.frm_redraw <- true;
end;
@

\subsubsection{Recenter}

<<misc keys>>=
[ControlMap, Char.code 'l'], Scroll.recenter;
@

<<function [[Simple.recenter]]>>=
let recenter frame =
  let (_, text, point) = Frame.buf_text_point frame in

  frame.frm_force_start <- true;
  frame.frm_redraw <- true;
  Text.goto_point text frame.frm_start point;
  frame.frm_y_offset <- - frame.frm_height/2
[@@interactive]
@
%old:
% <<misc actions>>=
% define_action "recenter"  Simple.recenter;
% @

<<[[Efuns.frame]] other fields>>=
mutable frm_force_start : bool;
@
% I thought it was related only to scrollbar thing, but it's not

<<[[Frame.display()]] redraw, if [[frm_force_start]]>>=
if frame.frm_force_start then begin
  let coord = cursor_to_coord frame frame.frm_cursor_x frame.frm_cursor_y in
  Text.goto_line text frame.frm_point coord.Text.c_line;
  Text.fmove text frame.frm_point coord.Text.c_col
end 
@
%todo: why not return a point and just to goto_point?
%old: was let x,y but confusing! it's col x line, but 
% we should not confuse them when frame coord (the cursor actually)
% where we use x and y.

%todo: so code setting frm_force_start actually set frm_cursor_x
% and frm_cursor_y? apparently no code does this, so why
% this code? for the mouse? that actually set x/y but does not set
% frm_point? so this is a way to set frm_point from the cursor?
% a bit ugly, could do that instead in the mouse handler?


%\subsection{Scrollbar}

% minimap is better than scrollbar?
% not worth the porting effort from original efuns to modern efuns

%semi: have sublime style scrollbar!
%later: or firefox style with search highlight? or disappearing animation?
% https://atom.io/packages/minimap
% codemap spirit!

%<<[[Top_window.create()]] optional scrollbar setup>>=
%(* ady#add_subject (fun () -> *) (
%(*
%      let ady = () in
%      let frame = top_window.top_active_frame in
%      if not frame.frm_force_start then
%        wrap top_window (scroll_to_frame ady) ()
%*)
%  ()
%  );
%@

%todo: comment? need that?

<<function [[Top_window.scroll_to_frame]]>>=
(*
let scroll_to_frame ady top_window =
  let frame = top_window.top_active_frame in
  let (buf, text, _) = Frame.buf_text_point frame in
  let pos_start = Text.get_position text frame.frm_start in
  let _size = Text.size text in
  UCommon.pr2 "ady#get_pos size";
  let y = 1
(*    ady#get_pos size  *)
  in
  if abs (y - pos_start) > 80 then
  (* the position has changed *)
    begin
      frame.frm_force_start <- true;
      frame.frm_redraw <- true;
      Text.set_position text frame.frm_start y
    end
*)
@
%(*
%    Text.set_position text point y;
%      Text.with_new_point text (fun point -> 
%        let curline = Text.point_line text frame.frm_start in
%        let newline = Text.point_line text point in
%        frame.frm_y_offset <- frame.frm_y_offset + (newline - curline);
%      );
%  *)



%old:
%<<[[Frame.display()]] redraw, scrollbar adjustments>>=
%if frame == top_window.top_active_frame then begin
%  frame.frm_force_start <- true; (* AVOID CYCLING IN SCROLLBAR *)
%  let _pos_start = get_position text frame.frm_start in
%  let _pos_end   = get_position text frame.frm_end in
%
%  Common.pr2_once "Frame.display: TODO scrollbar";
%  (*top_window.top_scrollbar#set_params pos_start (pos_end - pos_start) 
%     (size text);
%   *)
%end;
%@
%todo: how frm_force_start can ever be true? it's true only temporarily
% so I don't get how the flow can go two times in Frame.display?

\subsection{Top windows name}

<<[[Efuns.top_window]] other fields>>=
mutable top_name : string;
@

<<[[Top_window.cursor_on()]] set top window name>>=
let name = frame.frm_buffer.buf_name in
if name <> top_window.top_name then begin
  let graphic = Efuns.backend top_window in
  graphic.Xdraw.update_window_title name;
  top_window.top_name <- name
end;
@
% was using not (==), so I should use !=, but not sure why he didn't use <>

\section{[[Status]] Line}

%less: delete lots of the code below. My code in the end is simpler.
%no need those blit stuff and modified opti cache.

\subsection{Status line creation}


<<[[Efuns.frame]] status field>>=
mutable frm_status : status;    
@

<<type [[Efuns.status]]>>=
and status =
  { 
    mutable stat_name : string;
    mutable stat_file : string;
    mutable stat_line : int;
    mutable stat_col : int;

    mutable status_modified : bool;
    mutable stat_modified : bool;
    <<[[Efuns.status]] other fields>>
  }
@
%todo: redundant, used for some opti to know if things have
% changed, but not worth it I think.

<<[[Frame.create_without_top()]] let status>>=
let status = {
    stat_name = "";
    stat_file = "";
    stat_line = -1;
    stat_col = -1;
    status_modified = true;
    stat_modified = (buf.buf_last_saved =|= Text.version buf.buf_text);

    stat_modes = [];
    stat_mode = dummy_mode;

    status_format = !status_format;

    status_string = Bytes.make 256 '-';
  } in
String.blit editname 0 status.status_string 5 (String.length editname);
@

<<constant [[Frame.dummy_mode]]>>=
let dummy_mode = Ebuffer.new_major_mode "" None
@

<<constant [[Frame.editname]]>>=
let editname = "Efuns:"
@

<<[[Frame.create_without_top()]] adjust status of frame>>=
status_name frame buf.buf_name;
@

<<function [[Frame.status_name]]>>=
let status_name frame name =
  let status = frame.frm_status in
  if status.stat_name <> name then begin
    status.stat_name <- name;
    status_print status name StatName
  end
@

\subsection{Status line format}

<<[[Efuns.status]] other fields>>=
(* the pair of int is a:   pos * max_len *)
mutable status_format : (status_info * (int * int)) list;
@

<<type [[Efuns.status_info]]>>=
and status_info =
| StatName
| StatFile
| StatLine
| StatCol
| StatModified
| StatMode
@
% also clock, load, etc

<<constant [[Frame.status_format]]>>=
let status_format = ref [
    StatModified, (1, 2);
    StatName, (5, 20);
    StatMode, (30,30);
    StatLine, (65, 5);
    StatCol, (70, 5);
    StatFile, (35,15);
  ]
@
% meaning? see below, it's a (pos, maxlen)

\subsection{[[Frame.status_print()]]}

% status_name | status_modified | ... -> <>
<<function [[Frame.status_print]]>>=
let status_print status str stat_type =
  status.status_modified <- true;
  try
    let (pos,maxlen) = List.assoc stat_type status.status_format in
    let len = min (String.length str) maxlen in
    Bytes.blit_string str 0 status.status_string pos len;
    Bytes.fill status.status_string (pos + len) (maxlen - len) ' '
  with Not_found -> ()
@

<<[[Efuns.status]] other fields>>=
(* the string! --- ... --- *)
mutable status_string : bytes;
@
% this will then be the only thing used in the rendering

\subsection{[[Frame.status_xxx()]]}

% Frame.display -> <>
<<function [[Frame.status_modified]]>>=
let status_modified frame modified =
  let status = frame.frm_status in
  if status.stat_modified <> modified then begin
    status_print status (if modified then "**" else "--") StatModified;
    status.stat_modified <- modified
  end
@

% Frame.display -> <>
<<function [[Frame.status_line]]>>=
let status_line frame line =
  let status = frame.frm_status in
  if status.stat_line <> line then begin
    status.stat_line <- line;
    status_print status (Printf.sprintf "L%d" (line+1)) StatLine
  end
@
% note the +1

% Frame.display -> <>
<<function [[Frame.status_col]]>>=
let status_col frame col =
  let status = frame.frm_status in
  if status.stat_col <> col then begin
    status.stat_col <- col;
    status_print status (Printf.sprintf "C%d" (col+1)) StatCol
  end
@
% note the +1


%<<function Frame.status_file>>=
%let status_file frame name =
%  let status = frame.frm_status in
%  if status.stat_file <> name then
%    begin
%      status.stat_file <- name;
%      status_print status name StatFile
%    end
%@
% dead? status_name is used instead.

\subsection{Status line display}

<<[[Frame.display()]] draw status line>>=
(*
let status = frame.frm_status in

status_modified frame (version text <> buf.buf_last_saved);
status_line frame  (point_line text frame.frm_point);
status_col  frame  (point_col  text frame.frm_point);
status_name frame buf.buf_name;
status_major_mode frame;

if status.status_modified 
then
  graphic.Xdraw.draw_string 
    frame.frm_xpos (frame.frm_ypos + frame.frm_height - 1)
    status.status_string 
    0 width Text.inverse_attr
*)
let str = spf "-%s- %s  %s L%-6d (%s) --"
  (if (version text <> buf.buf_last_saved) then "**" else "--")
  (buf.buf_name ^ 
   String.make (max 1 ((width / 3) - String.length buf.buf_name)) ' ')
  (match () with
  | _ when Text.get_position text point =|= 0 -> "Top"
  | _ when Text.get_position text point =|= Text.size text -> "Bot"
  | _ -> spf "%2d%%" 
    (Text.point_line text point * 100 / Text.nbr_lines text)
  )
  (Text.point_line text point + 1)
  (let xs = buf.buf_minor_modes |> List.map (fun m -> m.min_name) in
   let xs = buf.buf_major_mode.maj_name :: xs in
   xs |> String.concat " "
  )
in
let minuses = String.make 256 '-' in
let str = str ^ minuses in
graphic.Xdraw.draw_string 
  frame.frm_xpos (frame.frm_ypos + frame.frm_height - 1)
  str
  0 width Text.inverse_attr
@

%todo: actually if not active_frame should do Text.direct_attr

\section{Minibuffer}

% way to ask for user input (that is different from the text user input).

% Alternative would be to have some popup windows, with some forms,
% but minibuffer was a way maybe in terminal world to make it easy
% to enter additional info.
% Sublime does not have this area, instead it uses popup windows
% or inline windows.
% An advantage of the minibuffer is that it does not clutter your
% main window.

\subsection{Minubuffer creation}

% when it's created? each time enter M-x or use some Select.xxx functions.

<<[[Efuns.top_window]] other fields>>=
mutable top_mini_buffers : frame list;
@
% there are many mini_buffers??

% ?? -> <>
<<function [[Minibuffer.create]]>>=
let create frame local_map request =
  let window = frame.frm_window in
  let top_window = Window.top window in

  let qlen = String.length request in
  let request = 
     if qlen < 50 
     then request 
     else String.sub request 0 47 ^ "..."
  in

  let mini_text = 
    Text.create "" in
  let mini_buf = 
    buf_create mini_text local_map in
  let mini_window = 
    Window.create true (*mini*) (TopWindow top_window) 
      qlen (top_window.top_height - 1) (top_window.top_width - qlen) 1 in
  let mini_frame = 
    Frame.create mini_window (Some request)(*mini*) mini_buf in    

  mini_frame.frm_cutline <- max_int;
  mini_frame.frm_has_status_line <- 0;

  top_window.top_mini_buffers <- mini_frame :: top_window.top_mini_buffers;

  Keymap.add_binding local_map [ControlMap, Char.code 'g']
    (fun mini_frame -> kill mini_frame frame);
  mini_frame
@
% C-g :)


<<[[Efuns.window]] other fields>>=
mutable win_mini : bool;
@
% which is what is used in Window.create true
% why need that? redundant with frame.mini_xxx?

% Minibuffer.create -> <>
<<function [[Minibuffer.buf_create]]>>=
let buf_create text local_map =
  { 
    buf_text = text;

    buf_name = "*Minibuffer*";
    buf_filename = None; (* no connected file! *)

    buf_point = Text.new_point text;
    buf_start = Text.new_point text;

    buf_last_saved = Text.version text;
    buf_modified = 0;


    buf_map = local_map;
    buf_map_partial = true;
    buf_charreprs = charreprs;
    buf_syntax_table = Ebuffer.default_syntax_table;
    buf_vars = Store.new_store ();
    buf_major_mode = Ebuffer.fondamental__mode;
    buf_minor_modes = [];

    buf_sync = false;
    buf_mark = None;
    buf_shared = 0;
    buf_finalizers = [];
    buf_history_pos = [||];
  }
@
% why not simply call Buffer.create? because no filename, 
% and specific buf_name


<<[[Frame.install()]] sanity check frame is not a minibuffer>>=
(* TODO: dunno why but can't use =:= for bool *)
if window.win_mini =*= (frame.frm_mini_buffer =*= None) then begin 
  kill frame; 
  failwith "Cannot install in minibuffer"
end;
@


\subsection{Minubuffer kill}

<<function [[Minibuffer.kill]]>>=
let kill mini_frame old_frame =
  let window = mini_frame.frm_window in
  let top_window = Window.top window in
  Top_window.clear_message top_window;
  top_window.top_mini_buffers <- List.tl top_window.top_mini_buffers;
  if old_frame.frm_killed 
  then Frame.unkill window old_frame;
  top_window.top_active_frame <- old_frame;
  Frame.kill mini_frame
@

<<exception [[Frame.BufferKilled]]>>=
exception BufferKilled
@

<<function [[Frame.unkill]]>>=
let unkill window frame =
  let (buf, text, _) = buf_text_point frame in
  if buf.buf_shared < 0 
  then raise BufferKilled;
  install window frame;
  frame.frm_start <- Text.dup_point text buf.buf_start;
  frame.frm_end <- Text.dup_point text buf.buf_start;
  frame.frm_point <- Text.dup_point text buf.buf_point;
  frame.frm_y_offset <- 0;
  buf.buf_shared <- buf.buf_shared + 1;
  frame.frm_killed <- false
@

<<[[Efuns.frame]] other fields>>=
mutable frm_killed : bool;
@

<<[[Frame.kill()]] setting [[frm_killed]] field>>=
frame.frm_killed <- true;
@

\subsection{Minibuffer display}

<<[[Frame.display()]] draw minibuffer request string>>=
graphic.Xdraw.draw_string
 0 (top_window.top_height-1)  
 request 
 0 (String.length request) Text.direct_attr
@

% (event loop -> ... -> Top_window.handle_key) | C-g -> <>
<<function [[Top_window.clear_message]]>>=
let clear_message top_window =
  match top_window.top_mini_buffers with
  | [] -> 
      let graphic = Efuns.backend top_window in
      graphic.Xdraw.clear_eol 
        0 (top_window.top_height - 1) 
        top_window.top_width; 
  | _ -> ()
@


\subsection{[[Top_window.message()]]}
% convenient to communicate info, like a status bar.

% (even though it's actually not really a minibuffer thing;
% it's just located at the same place than the minibuffer)

<<function [[Top_window.message]]>>=
(* note: I could get rid of the top_window parameter and compute top_window
 * by getting List.hd (Globals.editors()).top_windows, but maybe
 * one day I will add back the possibility to have multiple top_windows,
 * in which case we will need to know to which top_window to display
 * a message.
 *)
let message top_window msg =
  let graphic = Efuns.backend top_window in
  let len = String.length msg in

  graphic.Xdraw.draw_string 0 (top_window.top_height - 1)
    msg 0 len Text.direct_attr;
  graphic.Xdraw.clear_eol len (top_window.top_height - 1)
    (top_window.top_width - len);

  match top_window.top_mini_buffers with
  | [] -> (* No mini-buffer ... *) ()
  | mini_buffer :: _ -> (* one mini-buffer is active *)
      graphic.Xdraw.update_display ();
      (* let _ = Unix.select [] [] [] 0.2 in *)
      mini_buffer.frm_redraw <- true
@
%less: do a sleep 0.2?


%\section{Status bar}
% in Gtk, but status line is enough

\chapter{Input Management}

\section{Keyboard}

% see before Map, event loop, handle_key, keypressed global,
% and start of key dispatch where finally call try_map!

\subsection{Keys to action: [[try_map()]]}

<<exception [[Efuns.UnboundKey]]>>=
exception UnboundKey
@

<<[[Efuns.frame]] other fields>>=
mutable frm_prefix : key list;
@
% store prefix, when have to wait for another key press

% Top_window.handle_key -> <>(top_window.top_active_frame, ...)
<<function [[Top_window.try_map]]>>=
let try_map frame key =
  let keylist = frame.frm_prefix @ [key] in
  match Ebuffer.get_binding frame.frm_buffer keylist with
  | Function f ->
      frame.frm_prefix <- [];
      (* dispatch the action *)
      <<[[Top_window.try_map()]] if debug, print action name>>
      f frame; 
      <<[[Top_window.try_map()]] set last action>>
  | Prefix _map ->
      frame.frm_prefix <- keylist;
      let top_window = Window.top frame.frm_window in
      message top_window (Keymap.print_key_list frame.frm_prefix);
  | Unbound -> raise UnboundKey
@
%old:      <<[[Top_window.try_map()]] set repeat action>>


% Ebuffer.get_binding is essentially trying to find the right map
% (buffer map, major mode map, global map)

% Ebuffer.get_binding -> <>
<<function [[Keymap.get_binding]]>>=
let rec get_binding map keylist =
  match keylist with
    [] -> Unbound
  | [key] ->
        <<[[Keymap.get_binding()]] find key in map>>
  | key :: tail ->
      match
        <<[[Keymap.get_binding()]] find key in map>>
      with
      | Prefix map -> get_binding map tail
      | _ -> Unbound
@
% lookup


<<[[Keymap.get_binding()]] find key in map>>=
(match key with
  (NormalMap,key) when key >= 0 && key < 256 -> 
    map.char_map.(key)
| _ -> 
    try List.assoc key map.complex_bindings
    with Not_found -> Unbound
 )
@

<<[[Top_window.handle_key()]] handle exception of [[try_map]]>>=
| UnboundKey -> 
    message top_window
      (Printf.sprintf "Unbound key %s"
        (Keymap.print_key_list (frame.frm_prefix @ [key])));
    frame.frm_prefix <- [];
(* bugfix: it is nice for Failure to have a simpler error message
 *  than for the general 'e' case below; it allows efuns plugins to
 *  give nice error messages to the user. However, in the end you want
 *  also a backtrace because non-efuns code sometimes also
 *  uses failwith (e.g., Common2.foldl1).
 * less: maybe have a Efuns.Error instead of using failwith?
 *)
 | Failure str ->
    let bt = Printexc.get_backtrace () in
    message top_window str;
    let buf = Ebuffer.default "*backtrace*" in
    let text = buf.buf_text in
    Text.insert_at_end text str;
    Text.insert_at_end text "\n";
    Text.insert_at_end text bt;
    Text.insert_at_end text "\n"

| (Common.UnixExit _) as x -> raise x
@


% useful for undo. Also useful for goal-column!
<<[[Efuns.frame]] other fields>>=
mutable frm_last_action : action;
@
<<[[Top_window.try_map()]] set last action>>=
frame.frm_last_action <- f
@

\subsection{Action to keys: [[add_binding()]]}

% basic key bindings | ... -> <>
<<function [[Keymap.add_binding]]>>=
let rec add_binding map key_list binding =
  match key_list with
    [] -> failwith "ERROR add_complex_binding: empty key list"
  | [key] -> set_binding map key (Function binding)
  | key :: tail ->
      match
        match key with
          (NormalMap,key) when key >= 0 && key < 256 -> 
            map.char_map.(key)
        | _ -> 
            try
              List.assoc key map.complex_bindings
            with
              Not_found -> Unbound
      with
        Prefix map -> add_binding map tail binding
      | Unbound ->
          let newmap = create () in
          set_binding map key (Prefix newmap);
          add_binding newmap tail binding;
      | _e -> 
          failwith "ERROR add_complex_binding: Unable to add prefix"
@


<<function [[Keymap.set_binding]]>>=
let set_binding map key binding =
  match key with
  | (NormalMap,key) when key >= 0 && key < 256 -> 
      map.char_map.(key) <- binding
  | _ -> 
      map.complex_bindings <- (key,binding) :: map.complex_bindings
@

\subsection{Basic key bindings}
% how get the basic keys!

<<constant [[core_map]]>>=
let core_map = 
 <<[[core_map]] entries>>
 []
@

<<[[core_map]] entries>>=
(* standard chars *)
(List_.enum 32 127 |> List.map (fun key ->
  [NormalMap, key], Edit.self_insert_command
)) @
@

<<function [[Simple.self_insert_command]]>>=
let self_insert_command frame =
  let char = Char.chr !Top_window.keypressed in
  let buf = frame.frm_buffer in
  <<[[Simple.self_insert_command()]] if overwrite mode>>
  else insert_char frame char
@

\subsection{Entering special chars: [[^M]]}

% seen how to display them, but how to enter them?
% C-q C-m => you will see a ^m in the buffer (which is considered
% really as one character because the arrow will move 2 chars when on it)

<<[[core_map]] entries>>=
(let c_q = (ControlMap, Char.code 'q') in
(List_.enum 65 (65+25) |> List.map (fun key ->
  [c_q;ControlMap, key], Misc_features.insert_special_char
)) @
(* needed? *)
(List_.enum 97 (97+25) |> List.map (fun key ->
  [c_q;ControlMap, key], Misc_features.insert_special_char
))) @
@

<<function [[Simple.insert_special_char]]>>=
let insert_special_char frame =
  let key = !Top_window.keypressed in
  let char = Char.chr key in
  if char >= 'a' && char <= 'z' 
  then Edit.insert_char frame (Char.chr (key - 97))
  else Edit.insert_char frame (Char.chr (key - 65))
@
% should also set attribute to blue, so can not confuse ControlM with ^M 

\subsection{Bindings display}

<<misc keys>>=
[c_h; NormalMap, Char.code 'K'], Frame.help_bindings;
@

<<function [[Frame.bindings_help]]>>=
let help_bindings frame =
  let window = frame.frm_window in
  change_buffer window "*bindings*"
[@@interactive]
@
%old:
% <<misc actions>>=
% (* C-h map *)
% define_action "help_bindings"  Frame.bindings_help;
% @

% how can change_buffer with just window info? don't pass the frame?
% no need because can go back to top_window and active_frame?



% Graphics_efun.init -> <>
<<function [[Interactive.create_bindings]]>>=
let create_bindings_help_buffer () =
  let s = Keymap.all_bindings () in
  let text = Text.create s in
  Ebuffer.create "*bindings*" None text (Keymap.create ())
@


<<function [[Keymap.all_bindings]]>>=
let all_bindings () =
  let s = ref "Default bindings:" in
  (* TODO *)
  !s
@
%old: 
%todo: implement all_bindings
%  (Globals.editor()).edt_map.interactives |> List.iter(fun (name,(_,binding)) ->
%    match binding with
%    | None -> ()
%    | Some key_list ->
%        s := Printf.sprintf "%s\n%20s : %s" !s 
%              (print_key_list key_list) name
%  );

% used to be copy pasted in create_bindings, with only diff was
% the %s\n%20s : %s" and the use of List.rev.

<<function [[Keymap.print_key]]>>=
let print_key (map,keysym) =
  let prefix =
    match map with
    | NormalMap -> ""
    | ControlMap -> "C-"
    | MetaMap -> "M-"
    | ControlMetaMap -> "CM-"
  in
  let kname =
    try List.assoc keysym XK.keysym_to_name
    with Not_found -> 
      try Printf.sprintf "%c" (Char.chr keysym)
      with Invalid_argument _ -> "?"
  in
  prefix^kname
@

<<function [[Keymap.print_key_list]]>>=
let rec print_key_list key_list =
  match key_list with
  | [] -> ""
  | [key] -> Printf.sprintf "%s" (print_key key)
  | key :: tail ->
      Printf.sprintf "%s %s" (print_key key) (print_key_list tail)
@

%dead:?
% ?? -> <>
%<<function Keymap.print>>=
%let print map =
%  Printf.printf "MAP:\n";
%  List.iter (fun (key, binding) ->
%    (match binding with
%      Prefix _ -> print_string "Prefix "; 
%    | Function _ -> print_string "Function"
%    | Unbound -> print_string "Unbound"
%          );
%    print_string (print_key key);
%    print_newline ()
%      ) map.complex_bindings
%@
% dumper? could mv in debugging section



\section{Mouse}

<<constant [[Top_window.mouse_x]]>>=
let mouse_x = ref 0
@
<<constant [[Top_window.mouse_y]]>>=
let mouse_y = ref 0
@
% a bit like for keypressed, so action can access more information

<<[[Top_window.handler()]] match event cases>>=
| Xtypes.XTButtonPress (modifiers,button,x,y) -> 
    mouse_x := x;
    mouse_y := y;
    handle_key top_window modifiers (XK.xk_Pointer_Button_Dflt + button)
@

<<[[Top_window.handler()]] match event cases>>=
| Xtypes.XTMouseMotion (modifiers,button,x,y) ->
    mouse_x := x;
    mouse_y := y;
    handle_key top_window modifiers (XK.xk_Pointer_Drag_Dflt + button)
@

\subsection{Mouse navigation}

<<[[Config.init_global_map()]] mouse keys setup>>=
Keymap.add_global_key [NormalMap, XK.xk_Pointer_Button1] Mouse.mouse_set_frame;
@

<<function [[Simple.mouse_set_frame]]>>=
let mouse_set_frame frame =
  let top_window = Window.top frame.frm_window in
  let frame = Top_window.mouse_set_active top_window in
  let (buf, text, point) = Frame.buf_text_point frame in
  let mark = Ebuffer.get_mark buf point in
  Text.goto_point text mark point;
  ()
[@@interactive "set_active_frame"]
@
% mark so can then have copy paste via mouse

<<function [[Top_window.mouse_set_active]]>>=
let mouse_set_active top_window =
  let x = !mouse_x in
  let y = !mouse_y in
  let frame = find_selected_frame top_window in
  Frame.move_point frame frame.frm_point x y;
  frame
@
% this move_point is special! it's in screen coordinates

\subsubsection{Frame selection}
% but will see more later in Multi_frames section

% can select different frame!
<<function [[Top_window.find_selected_frame]]>>=
let find_selected_frame top_window =
  let x = !mouse_x in
  let y = !mouse_y in
  let frame = 
    if y > top_window.top_height - 2 then
      match top_window.top_mini_buffers with
      | [] -> raise Not_found
      | mini_frame :: _ -> mini_frame
    else
      find_frame top_window.window x y
  in
  Frame.active frame;
  frame
@
% will see Frame.active later

<<function [[Top_window.find_frame]]>>=
let rec find_frame window x y =
  match window.win_down with
    NoFrame -> raise Not_found
  | WFrame frame -> frame
  | HComb (w1,w2) -> 
      if w2.win_xpos > x 
      then find_frame w1 x y
      else find_frame w2 x y
  | VComb (w1,w2) ->
      if w2.win_ypos > y 
      then find_frame w1 x y
      else find_frame w2 x y
@
%old: was assert false, but seems more logic to raise Not_found

\subsubsection{Point selection}

%\subsection{Cursor}
% an output, but strongly related also to input devices 
% (input device feedback essentially)

% find back the subtleties we've seen before about ^M, 80cols overflow
% with box_charsize, frm_cutline.

% for the mouse
% x y are actually screen coordinates!
% mouse_save_then_kill -> <>
<<function [[Frame.move_point]]>>=
let move_point frame point x y =
  let (_, text, _) = buf_text_point frame in
  let coord = cursor_to_coord frame (x - frame.frm_xpos) (y - frame.frm_ypos) in
  Text.goto_line text point coord.Text.c_line;
  Text.fmove text point coord.Text.c_col
@
%less: could have instead a cursor_to_point and do a Text.goto_point


% x,y display -> text (colxline coord) (reverse of display_line stuff)
% Frame.display (when frm_force_start) -> <>
<<function [[Frame.cursor_to_point]]>>=
let cursor_to_coord frame x y =
  <<[[Frame.cursor_to_point()]] sanity check parameters in range>>
  let frm_line = frame.frm_table.(y) in
  let line = frm_line.lineidx_in_text in
  let rec iter x boxes default =
    match boxes with
      [] -> default
    | box :: tail -> 
        if x < box.box_size
        then box.box_col +   x / box.box_charsize
        else iter (x - box.box_size) tail (box.box_col + box.box_len)
  in
  let col = iter (x + frame.frm_x_offset + frm_line.first_box_extra_offset) 
    frm_line.frmline_boxes 0 
  in
  { Text.c_col = col; Text.c_line = line }
@
% useful for? the mouse!
%old: was cursor_to_point, but it was returning a coord
%less: why not return an actual point then? it's more a (line x col) actually


<<[[Frame.cursor_to_point()]] sanity check parameters in range>>=
if (y < 0) || (x<0) || (y >= frame.frm_height-1) || (x>frame.frm_cutline) 
then raise Not_found;
@



\subsection{Mouse selection}

%todo: should highlight! actually Highlight.highlight
% has some Drag button related code.

<<toplevel [[Mouse]] starting hook>>=
let _ =
  Hooks.add_start_hook (fun () ->
    Keymap.add_global_key [NormalMap, XK.xk_Pointer_Drag1] mouse_drag_region;
    Hooks.add_hook Highlight.unhighlight_hook unhighlight_hook;
  )
@
% why not put instead in this chunk?
%<<[[Config.init_global_map()]] mouse keys setup>>=

<<function [[Simple.mouse_drag_region]]>>=
(* C'est tout simple. On arrive dans cette fonction quand on est en train
de bouger la souris avec le bouton appuyer. La frame courante est donc 
correcte. On peut utiliser la position de la souris pour trouver la 
nouvelle position du curseur dans la frame. Si on en sort, on peut
ou prendre la derniere position, ou la premiere.
*)
let mouse_drag_region _frame =
  failwith "Simple.mouse_drag_region: TODO"
[@@interactive]
(*
  let top_window = Window.top frame.frm_window in
  let point = frame.frm_point in
  begin
    try
      move_point frame point !mouse_x !mouse_y
    with
      Not_found ->
        let (buf, text, _) = Frame.buf_text_point frame in
        let y = !mouse_y - frame.frm_ypos in
        if y < 0 then
          ( scroll_line frame (y-1);
            goto_point text point frame.frm_start;
            bmove text point 1; ())
        else
        if y >= frame.frm_height - 1 then
          (
            scroll_line frame (y - frame.frm_height + 2);
            goto_point text point frame.frm_end;
            fmove text point 1; ())
  end;
  highlight frame;
  let top_window = Window.top frame.frm_window in
  let xterm = top_window.top_term in
  Selection.setSelection xterm#display xterm#window XA.xa_primary
    (fun target ->
      if target = XA.xa_string then 
        match !highlighted with
          None -> raise Not_found
        | Some (frame,debut,fin) -> 
            let (buf, text, _) = Frame.buf_text_point frame in
            let curseur = new_point text in
            let final = new_point text in
            set_position text curseur debut;
            set_position text final fin;
            let str = Text.region text curseur final in
            remove_point text curseur;
            remove_point text final;
            
            1, str
      else raise Not_found
  ) !Eloop.event_time
*)
@

% seen highlight in previous chapter

\subsection{Mouse copy/paste}

<<[[Config.init_global_map()]] mouse keys setup>>=
Keymap.add_global_key [NormalMap, XK.xk_Pointer_Button3]
  Mouse.mouse_save_then_kill;
Keymap.add_global_key [NormalMap, XK.xk_Pointer_Button2]
  Mouse.mouse_yank_at_click;
@


<<function [[Simple.mouse_yank_at_click]]>>=
let  mouse_yank_at_click _frame =
failwith "Simple.mouse_yank_at_click: TODO"
[@@interactive "insert_at_point"]
(*
  let top_window = Window.top frame.frm_window in
  let frame = mouse_set_active top_window in
  let (buf, text, point) = Frame.buf_text_point frame in
  let xterm = Window.xterm top_window in
  let str = WX_xterm.get_cutbuffer xterm in
  Text.insert text point str;
  Text.fmove text point (String.length str)
*)
@
% normally should get the Xwindow clipboard string

<<function [[Simple.mouse_save_then_kill]]>>=
let mouse_save_then_kill _frame =
  failwith "Simple.mouse_save_then_kill: TODO"
[@@interactive]
(*
  let top_window = Window.top frame.frm_window in
  let frame = Top_window.find_selected_frame top_window in
  let (buf, text, point) = Frame.buf_text_point frame in
  let mark = Ebuffer.get_mark buf point in
  Text.with_new_point text (fun new_point ->
    Frame.move_point frame new_point !mouse_x !mouse_y;
    if point = new_point then begin
      let (start,term) =
        if point < mark then (point,mark) else (mark,point) 
      in
      Text.delete text start (Text.distance text start term)
    end else begin
      let xterm = Window.xterm top_window in
      goto_point text mark point;
      goto_point text point new_point;
      let str = Text.region text mark point in
      kill_string str;
      WX_xterm.set_cutbuffer xterm str;
      highlight frame
    end
  )
*)
@



\subsection{System clipboard}
% snarf for plan9?

\subsection{Resize}

<<[[Top_window.handler()]] match event cases>>=
| Xtypes.XTResize (new_width, new_height) ->
    resize_window top_window.window 0 0 new_width (new_height - 1);
    top_window.top_mini_buffers |> List.iter (fun frame -> 
      let window = frame.frm_window in
      window.win_ypos <- new_height - 1;
      window.win_width <- new_width;
      Frame.install window frame
    );
    top_window.top_width <- new_width;
    top_window.top_height <- new_height;
    clear_message top_window;
    update_display ()
@          

<<function [[Top_window.resize_window]]>>=
let rec resize_window window xpos ypos width height =
  let old_width = window.win_width in
  let old_height = window.win_height in
  window.win_xpos <- xpos;
  window.win_ypos <- ypos;
  window.win_width <- width;
  window.win_height <- height;
  match window.win_down with
    WFrame frame -> Frame.install window frame
  | NoFrame -> assert false
  | HComb (w1,w2) ->
      let wi1 = w1.win_width * width / old_width in
      resize_window w1 xpos ypos wi1 height;
      resize_window w2 (xpos + wi1) ypos (width - wi1) height
  | VComb (w1,w2) ->
      let he1 = w1.win_height * height / old_height in
      resize_window w1 xpos ypos width he1;
      resize_window w2 xpos (ypos + he1) width (height - he1)
@

\section{Interactive select}
\l here?


\subsection{[[M-x foo]] and [[call_interactive()]]}
% maybe should start with a simpler select? like C-x C-f ?

<<meta keys>>=
[MetaMap, Char.code 'x'], Interactive.call_interactive;
@


<<function [[Interactive.call_interactive]]>>=
let call_interactive frame =
  let interactives = compute_interactives () in
  Select.select frame "M-x " meta_hist "" 
    (fun _ -> List.map fst interactives)
    (fun s -> s) 
    (fun s -> exec_interactive interactives frame s)
[@@interactive]
@
%old:
% <<meta actions>>=
% define_action "call_interactive"  Interactive.call_interactive;
% @

<<constant [[Interactive.meta_hist]]>>=
let meta_hist = ref []
@

% call_interactive -> <>
<<function [[Interactive.buf_interactives]]>>=
let compute_interactives () =
  Action.actions |> Hashtbl_.hash_to_list |> List.map (fun (s, _) ->
    s, (Action.execute_action s, None)
  )
@
%old: 
%let interactives buf =
%  let interactives = 
%    buf.buf_major_mode.maj_map.interactives @
%    (Globals.editor()).edt_map.interactives 
%  in
%  List.fold_left (fun list minor -> minor.min_map.interactives @ list) 
%   interactives buf.buf_minor_modes 

%alt:
% - interactive global/major/minor/buffer, but
%   not sure it's that useful to allow to customize the interactive
%   mapping in the major, minors, or buffer. A single global
%   interactive seems simpler. To have a consistent M-x compile
%   that always bind to the same action (and have this action then
%   possibly use buffer/major/minor variables).
%   It can be nice way to change an action_name e.g. color_buffer
%   to ocaml_color_buffer in the ocaml major mode, or 
%   in eshell to have begin_of_line means something
%   slightly different (to just go after the prompt), but this can
%   be done by using variables instead (e.g., color_buffer can use
%   a variable defining what is the coloring function per major mode,
%   or indent_buffer, which in fact lead to better code factorization
%   (see features/indent.ml)
% - just global interactive (where we reuse simple the actions hashtbl)


<<function [[Interactive.exec_interactive]]>>=
let exec_interactive interactives frame name =
  try
    let f, key = List.assoc name interactives in
    <<[[Interactive.exec_interactive()]] display if has a keybinding>>
    (* run it ! *)
    f frame
  with Not_found -> 
    Message.message frame ("No interactive command "^name)
@
%less: I think it should just use the actions, no need for this intermediate
% interactive thing.

<<[[Interactive.exec_interactive()]] display if has a keybinding>>=
key |> Option.iter (fun key_list ->
  Message.message frame
    ("you can run "^name^" by typing "^(Keymap.print_key_list key_list))
);
@


\subsection{Adding interactive functions}

% just put [@@interactive] in code! 
% PPX magic that translates in simple toplevel side effect to actions hashtbl.

%alt: 
% - Map.interactive, interactive_map, per-mode interactives, interactive
%   in config file, etc.
%   more powerful maybe, but uselessly complicated and not worth it I think
% - manual define_action in config.ml, or spread
% - [@@interactive] close to entity

%old:
%\subsubsection{[[Map.interactives]]}
% in addition to char_map and complex_binding
% <<[[Efuns.map]] other fields>>=
% mutable interactives : (action_name * (action * prefix option)) list;
% @
%% record key so useful so can display the list of bindings?
% <<type [[Efuns.prefix]]>>=
% and prefix = key list
% @

%old:
%\subsection{[[interactives_map]]}
% <<constant [[Config.interactives_map]]>>=
% let interactives_map = define_option ["interactives_map"] ""
%     (list_option string2_option) 
%   []
% @
% <<[[Config.toplevel]] set [[interactives_map]]>>=
% if !!interactives_map = [] then begin
%     interactives_map =:= List.map (fun x -> x, x ) [
%       <<[[interactives_map]] initial entries>>
%     ]
%   end    
% @
%<<[[interactives_map]] initial entries>>=
%@
% <<[[interactives_map]] initial entries>>=
% "save_options";
% "open_display";
% "unset_attr";
% (*"load_library";*)
% @      
%alt: 
% - major interactive actions in std_efunsrc.ml, but inconcistent
% - all interactive actions in std_efunsrc.ml, but lack cohesion
% - get rid of it! anyway why choose certain actions as interactives
%   and not other? every actions should be interactive.
% - @@interactive@@

%old:
% <<[[Config.init_global_map()]] add interactives from [[interactives_map]]>>=
% !!interactives_map |> List.iter (fun (name, action) ->
%   try
%     Keymap.add_interactive (Globals.editor()).edt_map name 
%       (Action.execute_action action)
%   with e ->
%     Log.printf "Error for action %s" action;
%     Log.exn "%s\n" e;
% );
% @
% <<function [[Keymap.add_interactive]]>>=
% let add_interactive map name f =
%     map.interactives <- (name, (f, None)) :: map.interactives
% @
% <<[[Keymap.interactive()]] add keylist and name to interactives list>>=
% map.interactives <- (name, (f, Some keylist)) :: map.interactives;
% @
% <<function [[Keymap.define_interactive_action]]>>=
% let define_interactive_action action_name action_fun =
%   Action.define_action action_name action_fun;
%   let map = (Globals.editor()).edt_map in
%   add_interactive map action_name action_fun
% @

\subsection{[[Select.select()]]}

<<function [[Select.select]]>>=
let select frame request history start completion_fun prefix_fun action =
  let map = Keymap.create () in
  let string = ref "" in
  Keymap.add_binding map [ControlMap, Char.code 'g'] (fun mini_frame -> 
    remove_completions mini_frame;
    Minibuffer.kill mini_frame frame
  );
  let completion = ref "_*NoCompletion*_" in
  let completions = ref [] in
  Keymap.add_binding map [NormalMap, XK.xk_Tab] (fun mini_frame ->
      (* TODO? was != but I think it should be <> *)
      if (Common.phys_not_equal !completion !string) then begin
        let text = mini_frame.frm_buffer.buf_text in
        completions := completion_fun !string;
        let suffix, n  = Utils.common_suffix !completions (prefix_fun !string)in
        completion := !string;
        Text.insert text mini_frame.frm_point suffix;
        Text.fmove text mini_frame.frm_point (String.length suffix);
        if n>1 
        then display_completions frame
                (Utils.completion !completions (prefix_fun !string));
        
      end else
      (* can be improved, by displaying another part of the completion buffer *)
        display_completions frame
          (Utils.completion !completions (prefix_fun !string))
  );
  set_history map string history;

  incremental_mini_buffer frame map request start
    (fun _frame str -> string := str;)
    (fun _old_frame str -> 
       (match !history with
        | hd :: _ when hd = str -> ()
        | _ ->
            if str <> "" 
            then history := str :: !history
        );
       remove_completions frame;
       action str
    ) |> ignore
@


\subsection{Incremental mini buffer}
% for select (and so completion), for search, replace.
% each time ask input to user.


<<function [[Select.incremental_mini_buffer]]>>=
let incremental_mini_buffer 
 frame ismap request default incremental_action end_action =
  let top_window = Window.top frame.frm_window in

  let incremental mini_frame =
    incremental_action frame (Text.to_string mini_frame.frm_buffer.buf_text)
  in
  let incremental_insert mini_frame =
    Edit.self_insert_command mini_frame;
    incremental mini_frame
  in

  for key = 32 to 127 do
    Keymap.add_binding ismap [NormalMap, key] incremental_insert
  done;
  Keymap.add_binding ismap [NormalMap, XK.xk_BackSpace] (fun mini_frame -> 
    Edit.delete_backspace_char mini_frame;
    incremental mini_frame
  );

  top_window.top_second_cursor <- Some frame;
  Minibuffer.create_return frame ismap request default (fun frame str -> 
    top_window.top_second_cursor <- None;
    end_action frame str
  )
@

<<function [[Minibuffer.create_return]]>>=
let create_return frame local_map request default action =
  let mini_frame = create frame local_map request in
  Edit.insert_string mini_frame default;
  Keymap.add_binding local_map [NormalMap, XK.xk_Return] 
    (return action frame);
  mini_frame
@
%todo: sure top_second_cursor get reseted? if do C-g in minibuffer?
% if exn?

<<function [[Minibuffer.return]]>>=
let return action old_frame = fun mini_frame ->
  let repstr = Text.to_string mini_frame.frm_buffer.buf_text in
  kill mini_frame old_frame;
  action old_frame repstr
@



<<function [[Text.to_string]]>>=
let to_string text =
  let len = text.text_size - text.gsize in
  if len = 0 
  then "" 
  else begin
    let str = Bytes.create len in
    let gpos = text.gpoint.pos in
    let gap_end = gpos + text.gsize in
    Bytes.blit text.text_string 0 str 0 gpos;
    Bytes.blit text.text_string gap_end str gpos (len- gpos);
    Bytes.to_string str
  end
@

\subsection{Secondary cursor}

% cursor is output, but strongly related to input, because it's
% an input feedback.

<<[[Efuns.top_window]] other fields>>=
mutable top_second_cursor : frame option;
@


<<[[Top_window.cursor_on()]] display secondary cursor>>=
top_window.top_second_cursor |> Option.iter (fun frame ->
  set_cursor_on top_window frame
)
@

<<[[Top_window.cursor_off()]] hide secondary cursor>>=
top_window.top_second_cursor |> Option.iter (fun frame ->
  set_cursor_off top_window frame
)
@


% safe sanity check because the invariant is fragile to maintain
% and I have bugs.
<<[[clean_display()]] sanity check second cursor and minibuffer>>=
(match top_window.top_mini_buffers, top_window.top_second_cursor with
 | _, None -> ()
 | _::_, Some _ -> ()
 | [], Some frame ->
     Error.error 
      (spf "clean_display: weird, second cursor for %s but no minibuffer"
       (frame.frm_buffer.buf_name));
     top_window.top_second_cursor <- None
)
@


\subsection{Interactive variables}

<<constant [[Complex.value_hist]]>>=
let value_hist = ref []
@

<<constant [[Complex.all_vars]]>>=
let all_vars = ref None
@

<<function [[Complex.all_variables]]>>=
let all_variables frame _ =
  let buf = frame.frm_buffer in
  match !all_vars with
    Some (f,l) when f == frame -> l
  | _ ->
      let list = 
        (Store.list buf.buf_vars) @ 
        (Store.list (Globals.editor()).edt_vars) 
      in
      all_vars := Some (frame, list);
      list
@

<<function [[Complex.set_local_variable]]>>=
let set_local_variable frame = 
  Select.select frame "set_local_variable : " variable_hist
    "" (all_variables frame) (fun s -> s) (fun variable ->
      Select.select_string frame (Printf.sprintf "%s : " variable)
      value_hist "" (fun value ->
          Store.input frame.frm_buffer.buf_vars variable value))
[@@interactive]
@

<<function [[Complex.set_global_variable]]>>=
let set_global_variable frame =
  Select.select frame "set_global_variable : " variable_hist
    "" (all_variables frame) (fun s -> s) (fun variable ->
      Select.select_string frame (Printf.sprintf "%s : " variable)
      value_hist "" (fun value ->
          Store.input (Globals.editor()).edt_vars variable value))
[@@interactive]
@


\chapter{Basic Features}
% Generic features?

\section{Navigating}
\l moving around

% see also mouse navigation earlier

<<navigating keys>>=
[NormalMap, XK.xk_Left], (fun frm -> ignore (Move.move_backward frm 1)); 
[NormalMap, XK.xk_Right], (fun frm -> ignore (Move.move_forward frm 1)); 
[ControlMap, Char.code 'b'], (fun frm -> ignore (Move.move_backward frm 1)); 
[ControlMap, Char.code 'f'], (fun frm -> ignore (Move.move_forward frm 1)); 

[ControlMap, XK.xk_Left ], (Frame.to_frame Move.backward_word);
[ControlMap, XK.xk_Right ], (Frame.to_frame Move.forward_word);  
(* ?? standard ?*)
[MetaMap, XK.xk_Left ], (Frame.to_frame Move.backward_word);
[MetaMap, XK.xk_Right ], (Frame.to_frame Move.forward_word);

[ControlMap, Char.code 'a'], Move.beginning_of_line;
[ControlMap, Char.code 'e'], Move.end_of_line;

[NormalMap, XK.xk_Up], Move.backward_line; 
[NormalMap, XK.xk_Down], Move.forward_line; 


[ControlMap, XK.xk_Up], (Frame.to_frame Move.backward_paragraph);
[ControlMap, XK.xk_Down], (Frame.to_frame Move.forward_paragraph);  

[NormalMap, XK.xk_Prior], Scroll.backward_screen; 
[NormalMap, XK.xk_Next], Scroll.forward_screen;

[ControlMap, XK.xk_Next], Move.end_of_file;
[ControlMap, XK.xk_Prior], Move.begin_of_file;
[MetaMap, Char.code '>'], Move.end_of_file;
[MetaMap, Char.code '<'], Move.begin_of_file;
@

%old:
% <<navigating actions>>=
% define_action "move_backward"  (fun frame -> ignore (Simple.move_backward frame 1));
% define_action "move_forward"   (fun frame -> ignore (Simple.move_forward frame 1));
% 
% define_action "backward_word"  (Frame.to_frame Simple.backward_word);
% define_action "forward_word"  (Frame.to_frame Simple.forward_word);  
% 
% define_action "beginning_of_line"  Simple.beginning_of_line;
% define_action "end_of_line"  Simple.end_of_line;
% 
% define_action "backward_line"  Simple.backward_line;
% define_action "forward_line"  Simple.forward_line;  
% 
% define_action "backward_paragraph"  (Frame.to_frame Simple.backward_paragraph);
% define_action "forward_paragraph"  (Frame.to_frame Simple.forward_paragraph);  
% 
% define_action "backward_screen"  Simple.backward_screen;
% define_action "forward_screen"  Simple.forward_screen;
% 
% define_action "begin_of_file"  Simple.begin_of_file;
% define_action "end_of_file"  Simple.end_of_file;
% 
% (* M-x *)
% define_action "goto_char" Complexe.goto_char;
% define_action "goto_line" Complexe.goto_line;
% @
%old:
% <<[[interactives_map]] initial entries>>=
% "goto_char";
% "goto_line";
% @

\subsection{Characters}

<<function [[Simple.move_backward]]>>=
let move_backward frame delta =
  let (_buf, text, point) = Frame.buf_text_point frame in
  Text.bmove text point delta
@

<<function [[Simple.move_forward]]>>=
let move_forward frame delta =
  let (_buf, text, point) = Frame.buf_text_point frame in
  Text.fmove text point delta
@
% Note that there is no mention of redisplay, or of adjusting
% the cursor. This is done automatically each time, based on
% the new value of frame.frm_point.


\subsection{Words and the syntax table}

%\section{Syntax table}
% was in core DS but better here I think

<<[[Efuns.buffer]] other fields>>=
mutable buf_syntax_table : bool array;
@

<<function [[Ebuffer.create_syntax_table]]>>=
let create_syntax_table ()  =
  let table = Array.make 256 false 
  in  
  for i = Char.code 'a' to Char.code 'z' do
    table.(i) <- true;
  done;
  for i = Char.code 'A' to Char.code 'Z' do
    table.(i) <- true;
  done;
  for i = Char.code '0' to Char.code '9' do
    table.(i) <- true;
  done;
  table
@

<<constant [[Ebuffer.default_syntax_table]]>>=
let default_syntax_table = create_syntax_table ()
@
% word consistuent? just a bool? emacs has more no?




<<function [[Simple.backward_word]]>>=
let backward_word buf point =
  let text = buf.buf_text in
  let syntax = buf.buf_syntax_table in
  in_prev_word text point syntax;
  to_begin_of_word text point syntax
@

<<function [[Simple.in_prev_word]]>>=
let in_prev_word text mark syntax =
  while Text.bmove_res text mark 1 = 1 &&
        (not syntax.(Char.code (Text.get_char text mark)))
  do () done
@

<<function [[Simple.to_begin_of_word]]>>=
let to_begin_of_word text mark syntax =
  if Text.bmove_res text mark 1 = 1 then
    begin
      while syntax.(Char.code (Text.get_char text mark)) &&
            (Text.bmove_res text mark 1) <> 0 
      do () done;
      if not syntax.(Char.code (Text.get_char text mark)) 
      then (Text.fmove text mark 1)
    end
@




<<function [[Simple.forward_word]]>>=
let forward_word buf point =
  let text = buf.buf_text in
  let syntax = buf.buf_syntax_table in
  in_next_word text point syntax;
  to_end_of_word text point syntax
@

<<function [[Simple.in_next_word]]>>=
let in_next_word text mark syntax =
  while (not syntax.(Char.code (Text.get_char text mark))) &&
        Text.fmove_res text mark 1 = 1 
  do () done
@

<<function [[Simple.to_end_of_word]]>>=
let to_end_of_word text mark syntax =
  while syntax.(Char.code (Text.get_char text mark)) &&
       (Text.fmove_res text mark 1) <> 0 
  do () done
@


% helpers for writing his own functions, e.g. C-s C-w uses that

<<function [[Simple.end_of_word]]>>=
let end_of_word  buf point =
  let text = buf.buf_text in
  let syntax = buf.buf_syntax_table in
  Text.with_dup_point text point (fun mark ->
    to_end_of_word text mark syntax;
    let s = Text.region text point mark in
    s
  )
@

<<function [[Simple.beginning_of_word]]>>=
let beginning_of_word buf point =
  let text = buf.buf_text in
  let syntax = buf.buf_syntax_table in
  Text.with_dup_point text point (fun mark ->
    to_begin_of_word text mark syntax;
    let s = Text.region text mark point in
    s
  )
@



\subsection{Lines}

<<function [[Simple.beginning_of_line]]>>=
let beginning_of_line frame =
  move_backward frame (begin_to_point frame) |> ignore
[@@interactive]
@
<<function [[Simple.begin_to_point]]>>=
let begin_to_point frame =
  let (_, text, point) = Frame.buf_text_point frame in
  Text.point_to_bol text point
@


<<function [[Simple.end_of_line]]>>=
let end_of_line frame =
  move_forward frame (point_to_end frame) |> ignore
[@@interactive]
@
<<function [[Simple.point_to_end]]>>=
let point_to_end frame =
  let (_, text, point) = Frame.buf_text_point frame in
  Text.point_to_eol text point
@



% mutually recursive because of goal_column()
<<function [[Simple.backward_line]]>>=
and backward_line frame =
  let text = frame.frm_buffer.buf_text in
  let point = frame.frm_point in
  if Text.point_line text point > 0 then begin
    let goal_col = goal_column frame in
    beginning_of_line frame;
    move_backward frame 1 |> ignore;
    move_to_goal_column frame goal_col;
  end
@
%old: was doing also some beginning_of_line when going up,
% end end_of_line when going down! I prefer
% to remain where I was column-wise
%old:
%    let old_x = begin_to_point frame in
%    beginning_of_line frame;
%    move_backward frame 1 |> ignore;
%    beginning_of_line frame;
%    move_forward  frame (min old_x (point_to_end frame)) |> ignore

<<function [[Simple.forward_line]]>>=
and forward_line frame =
  let text = frame.frm_buffer.buf_text in
  let point = frame.frm_point in
  if Text.point_line text point < Text.nbr_lines text then begin
    let goal_col = goal_column frame in
    end_of_line frame;
    move_forward frame 1 |> ignore;
    move_to_goal_column frame goal_col;
  end
@
%old:
%    if point_to_end frame = 0 then begin
%        move_forward frame 1 |> ignore;
%        end_of_line frame;
%    end else begin
%      let old_x = begin_to_point frame in
%      end_of_line frame;
%      move_forward frame 1 |> ignore;
%      move_forward frame (min old_x (point_to_end frame)) |> ignore



%\subsubsection{Goal column}
%pad: this was added by me! I get really confused
% when I don't have the exact look&feel of emacs!

%history:
% I struggled to implement that :):
% - I first added a type Bol | Col of int | Eol, but in fact
%   emacs does not do that, when you do eol and up, you don't
%   want to go to the eol, you want to remain at the same column.
% - Then I added a old_col_pos_max but it's tricky to get right
%   because other moving commands must reset it, but that means
%   ensuring an invariant at every places we use a move command.
% - In the end I had a look in microemacs and found the lastcmd
%   trick. In fact in emacs they uses that to and check if
%   the last command was a next-line or back-line. In fact
%   if you use M-x next-line instead of down you'll see that
%   the goal column is maintained only for the arrow keys, not
%   for the interactive version.

%emacs: 
% "It is the column where point was at the start of the current run
% of vertical motion commands."
<<constant [[Simple.temporary_goal_column]]>>=
let temporary_goal_column = 
  Store.create_abstr "Simple.temporary_goal_column"
@
% better than adding yet another field in the Buffer or Frame structure

<<function [[Simple.goal_column]]>>=
let rec goal_column frame =
  let cur_col = begin_to_point frame in
  if frame.frm_last_action == forward_line ||
     frame.frm_last_action == backward_line
  then 
    try Var.get_local frame.frm_buffer temporary_goal_column
    with Not_found -> cur_col
  else cur_col
@

<<function [[Simple.move_to_goal_column]]>>=
and move_to_goal_column frame goal_col =
  move_backward frame (begin_to_point frame) |> ignore;
  move_forward frame (min goal_col (point_to_end frame)) |> ignore;
  Var.set_local frame.frm_buffer temporary_goal_column goal_col
@


\subsection{Paragraphs}

<<function [[Simple.backward_paragraph]]>>=
let backward_paragraph buf point =
  let text = buf.buf_text in
  while Text.bmove_res text point 1 = 1 && 
        (let c = Text.get_char text point in c = '\n' || c = ' ')
  do () done;
  try
    Text.search_backward text (Str.regexp "\n *\n") point |> ignore;
    Text.fmove text point 1
  with Not_found -> Text.set_position text point 0
@
% so simple regexp :)

<<function [[Simple.forward_paragraph]]>>=
let forward_paragraph buf point =
  let text = buf.buf_text in
  while (let c = Text.get_char text point in c = '\n' || c = ' ') &&
         Text.fmove_res text point 1 = 1 
  do () done;
  try
    Text.search_forward text (Str.regexp "\n *\n") point |> ignore;
    Text.fmove text point 1
  with Not_found -> Text.set_position text point (Text.size text)
@

\subsection{Screens}

<<function [[Simple.backward_screen]]>>=
let backward_screen frame =
  frame.frm_force_start <- true;
  frame.frm_redraw <- true;
  frame.frm_y_offset <- frame.frm_y_offset - frame.frm_height + 2
@
%less: seems redundant a bit frm_force_start and frm_redraw no?
% +2?

<<function [[Simple.forward_screen]]>>=
let forward_screen frame =
  frame.frm_force_start <- true;
  frame.frm_redraw <- true;
  frame.frm_y_offset <- frame.frm_y_offset + frame.frm_height - 2
@


<<function [[Simple.scroll_line]]>>=
let scroll_line frame n =
  frame.frm_force_start <- true;
  frame.frm_redraw <- true;
  frame.frm_y_offset <- frame.frm_y_offset + n
@



\ifallcode

% pad stuff
<<function [[Simple.scroll_down]]>>=
let scroll_down frame =
  scroll_line frame 1;
  forward_line frame
[@@interactive]
@
%old:
% <<navigating actions>>=
% (* pad: *)
% define_action "scroll_up" Simple.scroll_up; 
% define_action "scroll_down" Simple.scroll_down; 
% define_action "scroll_other_up" Simple.scroll_other_up; 
% define_action "scroll_other_down" Simple.scroll_other_down; 
% @


<<function [[Simple.scroll_up]]>>=
let scroll_up frame =
  scroll_line frame (-1);
  backward_line frame
[@@interactive]
@

<<function [[Simple.scroll_other_up]]>>=
let scroll_other_up frame =
  Window.next scroll_up frame.frm_window
[@@interactive]
@

<<function [[Simple.scroll_other_down]]>>=
let scroll_other_down frame =
  Window.next scroll_down frame.frm_window
[@@interactive]
@

\fi
\subsection{File}


<<function [[Simple.begin_of_file]]>>=
let begin_of_file frame =
  let (_, text, point) = Frame.buf_text_point frame in
  <<save current pos from frame for position history navigation (in simple.ml)>>
  Text.set_position text point 0
[@@interactive]
@

<<function [[Simple.end_of_file]]>>=
let end_of_file frame =
  let (_, text, point) = Frame.buf_text_point frame in
  <<save current pos from frame for position history navigation (in simple.ml)>>
  Text.set_position text point (Text.size text)
[@@interactive]
@


\subsection{Specific positions}

<<function [[Complex.goto_char]]>>=
let goto_char frame =
  Select.simple_select frame "goto-char:" (fun name ->
    let char = int_of_string name in
    Text.set_position frame.frm_buffer.buf_text frame.frm_point char
  )
[@@interactive]
@

<<function [[Complex.goto_line]]>>=
let goto_line frame =
  Select.simple_select frame "goto-line:" (fun name ->
    let line = int_of_string name in
    <<save current pos from frame for position history navigation>>
    Text.goto_line frame.frm_buffer.buf_text frame.frm_point (line - 1)
  )
[@@interactive]
@

<<function [[Text.goto_line]]>>=
let goto_line text point y =
  if text.text_nlines - 1 <= y 
  then set_position text point (size text)
  else begin
    let line = text.text_newlines.(y) in
    point.pos <- line.position;
    point.line <- y
  end
@



%\subsection{Helpers}

<<function [[Text.point_to_eol]]>>=
let point_to_eol text point =
  low_distance text point.pos
    (text.text_newlines.(point.line + 1).position - 1)
@

<<function [[Text.point_to_bol]]>>=
(* less: kinda bol_to_point really *)
let point_to_bol text point =
  low_distance text 
    text.text_newlines.(point.line).position
    point.pos
@

<<function [[Text.point_to_eof]]>>=
let point_to_eof text point =
  low_distance text point.pos text.text_size
@

<<function [[Text.point_to_bof]]>>=
let point_to_bof text point =
  low_distance text 0 point.pos
@




<<function [[Text.point_to_lof]]>>=
let point_to_lof text point n =
  if n > 0 
  then point_to_eof text point
  else point_to_bof text point
@

<<function [[Text.point_to_lol]]>>=
let point_to_lol text point n =
  if n > 0 
  then point_to_eol text point
  else point_to_bol text point
@

<<function [[Text.point_to_line]]>>=
let point_to_line text point line =
  let pos = 
    if text.text_nlines <= line + 1 
    then text.text_size
    else text.text_newlines.(line).position
  in
  move_point_to_pos text point pos
@


\subsection{Positions history}
% meta!
% could be in advanced topic

%when you do big jump in a file, it's hard to "undo" what you did. You need
% to keep a history for such moves. It's easy to undo a forward screen,
% just do backward screen. It's not so easy to undo
% a goto begin_of_file, or a C-s. Enter buf_history_pos.


<<[[Efuns.buffer]] history fields>>=
mutable buf_history_pos: Text.point option array;
@
% stack with limited size
<<constant [[Simple.history_pos_max]]>>=
let history_pos_max = 10
@
% don't want too many dup points created, they can have a cost
% at some point


<<save current pos from frame for position history navigation>>=
Move.save_current_pos frame;
@
\ifallcode
<<save current pos from frame for position history navigation (in simple.ml)>>=
save_current_pos frame;
@
\fi

<<function [[Simple.save_current_pos]]>>=
let save_current_pos frame =
  let (buf, text, point) = Frame.buf_text_point frame in
  if Array.length buf.buf_history_pos < history_pos_max
  then buf.buf_history_pos <- Array.make history_pos_max None;
  let arr = buf.buf_history_pos in
  arr.(history_pos_max -1) |> Option.iter (fun pt ->
     Text.remove_point text pt
  );
  Array.blit arr 0 arr 1 (history_pos_max - 1);
  arr.(0) <- Some (Text.dup_point buf.buf_text point)
@
%bugfix: don't forget to remove_point! otherwise leak

<<navigating keys>>=
[ControlMap, Char.code 'u'; ControlMap, Char.code ' '], 
  Move.goto_last_saved_pos; 
@
%old:
% <<navigating actions>>=
% (* pad: *)
% define_action "goto_last_saved_pos" Simple.goto_last_saved_pos; 
% @
% normally in emacs C-u has a special meaning, but I think I use it
% only for this history position navigation thing so ...

<<function [[Simple.goto_last_saved_pos]]>>=
let goto_last_saved_pos frame =
  let (buf, text, point) = Frame.buf_text_point frame in
  if Array.length buf.buf_history_pos < history_pos_max
  then buf.buf_history_pos <- Array.make history_pos_max None;
  let arr = buf.buf_history_pos in
  let head = arr.(0) in
  Array.blit arr 1 arr 0 (history_pos_max - 1);
  arr.(history_pos_max - 1) <- None;
  match head with
  | Some pt -> Text.goto_point text point pt
  | None -> failwith "No position history"
[@@interactive]
@
%bugfix: don't forget to set to None otherwise will have duped
% point and will remove something that has been freed already

% see also search later which is also a form of navigation.

\section{Inserting}

% have seen already before low_insert

<<inserting keys>>=
[NormalMap, XK.xk_Return], Edit.insert_return; 
@

<<function [[Simple.insert_return]]>>=
let insert_return frame =
  insert_char frame '\n'
[@@interactive]
@
%old:
% <<inserting actions>>=
% define_action "insert_return"  Simple.insert_return;
% @


<<constant [[Simple.single_char]]>>=
let single_char = Bytes.make 1 ' '
@
% thread-safe?
\l probably useless opti now that we use Bytes.to_string anyway?

% basic key bindings -> self_insert_command -> <>
<<function [[Simple.insert_char]]>>=
(* could factorize and just call insert_string? *)
let insert_char frame char =
  let (_, text, point) = Frame.buf_text_point frame in
  Bytes.set single_char 0 char;
  Text.insert text point (Bytes.to_string single_char);
  Text.fmove text point 1
@




<<function [[Text.insert]]>>=
let insert text point str = 
   insert_res text point str |> ignore
@
<<function [[Text.insert_res]]>>=
let insert_res text point str =
  let (pos,len,modif) = low_insert text point.pos str in
  text.text_history <- Insertion(pos,len,modif) :: text.text_history;
  text.text_modified <- text.text_modified + 1;
  pos, len
@

% Insertion! For undo!




%\subsection{Overwrite mode}
% see minor mode section


\section{Deleting}

% have seen already before low_delete

<<deleting keys>>=
[NormalMap, XK.xk_BackSpace], Edit.delete_backspace_char; 
[ControlMap, Char.code 'd'], Edit.delete_char;
[NormalMap, XK.xk_Delete], Edit.delete_char; 

[MetaMap, Char.code 'd' ], (Frame.to_frame Edit.delete_forward_word);
[MetaMap, XK.xk_BackSpace ], (Frame.to_frame Edit.delete_backward_word);

[ControlMap, Char.code 'k'], Copy_paste.kill_end_of_line;
@

%old:
% <<deleting actions>>=
% define_action "delete_before_point"  Simple.delete_backspace_char;
% define_action "delete_at_point"  Simple.delete_char;
% 
% define_action "delete_forward_word"  (Frame.to_frame Simple.delete_forward_word);
% define_action "delete_backward_word"  (Frame.to_frame Simple.delete_backward_word);
% 
% define_action "kill_end_of_line"  Simple.kill_end_of_line;
% @


\subsection{Characters}

<<function [[Simple.delete_backspace_char]]>>=
let delete_backspace_char frame =
  let (_, text, point) = Frame.buf_text_point frame in
  if Text.bmove_res text point 1 <> 0 
  then Text.delete text point 1
[@@interactive]
@

<<function [[Simple.delete_char]]>>=
let delete_char frame =
  let (_, text, point) = Frame.buf_text_point frame in
  Text.delete text point 1
[@@interactive]
@

<<function [[Text.delete]]>>=
let delete text point len = 
  delete_res text point len |> ignore
@
<<function [[Text.delete_res]]>>=
let delete_res text point len =
  let (pos,str,modif) = low_delete text point.pos len in
  text.text_history <- Deletion(pos,str,modif) :: text.text_history;
  text.text_modified <- text.text_modified + 1;
  pos, str
@

% Deletion! For undo


\subsection{Words}

<<function [[Simple.delete_backward_word]]>>=
let delete_backward_word buf point =
  let text = buf.buf_text in
  Text.with_dup_point text point (fun old_point ->
    backward_word buf point;
    Text.delete text point (Text.distance text point old_point)
  )
@

<<function [[Simple.delete_forward_word]]>>=
let delete_forward_word buf point =
  let text = buf.buf_text in
  Text.with_dup_point text point (fun old_point ->
    forward_word buf point;
    let len = Text.distance text old_point point in
    Text.bmove text point len;
    Text.delete text point len
  )
@

\subsection{Lines}

<<function [[Simple.kill_end_of_line]]>>=
let kill_end_of_line frame =
  let (_, text, _) = Frame.buf_text_point frame in
  let eol = point_to_end frame in
  let len = 
    (* if already at eol then kill the newline *)
    if eol = 0 
    then 1 
    else eol 
  in
  kill_text text frame.frm_point len
[@@interactive]
@


\section{Copying and pasting}
\n was Moving, but can be confused as moving as in navigating

<<moving keys>>=
[ControlMap, Char.code ' '], Copy_paste.mark_at_point;
[ControlMap, Char.code 'w'], Copy_paste.kill_region;
[ControlMap, Char.code 'y'], Copy_paste.insert_killed;
[MetaMap, Char.code 'y'], Copy_paste.insert_next_killed;
[MetaMap, Char.code 'w'], Copy_paste.copy_region;
[c_x; NormalMap, Char.code 'h'], Copy_paste.mark_whole_buffer;
@
%old:
% <<moving actions>>=
% define_action "mark_at_point"  Complexe.mark_at_point;
% define_action "kill_region"  Simple.kill_region;
% define_action "insert_killed"  Simple.insert_killed;
% define_action "insert_next_killed"  Simple.insert_next_killed;
% define_action "copy_region"  Simple.copy_region;
% @

%related are the mouse selection and copy paste seen before

\subsection{Mark}

<<[[Efuns.buffer]] other fields>>=
mutable buf_mark : Text.point option;
@

<<function [[Complex.mark_at_point]]>>=
let mark_at_point frame =
  Ebuffer.set_mark frame.frm_buffer frame.frm_point;
  <<save current pos from frame for position history navigation>>
  Message.message frame "Mark set";
  ()
[@@interactive]
@


<<function [[Ebuffer.set_mark]]>>=
let set_mark buf point =
  let text = buf.buf_text in
  buf.buf_modified <- buf.buf_modified + 1;
  match buf.buf_mark with
  | None ->
      let mark = Text.dup_point text point in
      buf.buf_mark <- Some mark
  | Some mark ->
      Text.goto_point text mark point
@




<<function [[Ebuffer.get_mark]]>>=
let rec get_mark buf point =
  match buf.buf_mark with
  | None -> 
      set_mark buf point;
      get_mark buf point
  | Some mark -> mark
@

<<function [[Ebuffer.remove_mark]]>>=
let remove_mark buf =
  buf.buf_mark |> Option.iter (fun mark ->
    buf.buf_mark <- None;
    Text.remove_point buf.buf_text mark;
    buf.buf_modified <- buf.buf_modified + 1
  )
@


% can actually also navigate with the mark


\subsection{Cut}

<<function [[Simple.kill_region]]>>=
let kill_region frame =
  let (buf, text, point) = Frame.buf_text_point frame in
  let mark =
    match buf.buf_mark with
    | None -> failwith "No mark set"
    | Some mark -> mark
  in
  let (start,term) = 
    if mark > point then (point,mark) else (mark,point)
  in
  let _,region = Text.delete_res text start (Text.distance text start term) in
  (* less: would be better to do that in kill_string *)
  add_clipboard frame region;
  kill_string region
[@@interactive]
@


<<constant [[Simple.kill_ring]]>>=
let kill_ring = Array.make kill_max ""
@
<<constant [[Simple.kill_max]]>>=
let kill_max = 10
@
<<constant [[Simple.kill_size]]>>=
let kill_size = ref 0
@

<<function [[Simple.kill_string]]>>=
let kill_string str =
  Array.blit kill_ring 0 kill_ring 1 (kill_max - 1);
  incr kill_size;
  kill_ring.(0) <- str
@
% incr kill_size, but anyway usually use with min kill_max kill_size
% see below

\subsection{Copy}

% M-w, no by default, was in pc-select.el
<<function [[Simple.copy_region]]>>=
(* copy-region-as-kill-nomark in emacs *)
let copy_region frame =
  let (buf, text, point) = Frame.buf_text_point frame in
  let mark =
    match buf.buf_mark with
    | None -> failwith "No mark set"
    | Some mark -> 
        buf.buf_mark <- None;
        mark
  in
  let (start,term) = 
    if mark > point then (point,mark) else (mark,point)
  in
  let region = Text.sub text start (Text.distance text start term) in
  add_clipboard frame region;
  kill_string region;
  (* need a message because as opposed to a cut this is not directly visible *)
  Message.message frame "Region saved"
[@@interactive]
@
\t use remove_mark? leak?


<<function [[Text.sub]]>>=
let sub text point len =
  let str = Bytes.create len in
  blit str text point len |> ignore;
  Bytes.to_string str
@

<<function [[Text.blit]]>>=
let blit str text point len =
  let pos = point.pos in
  let len = min len (low_distance text pos text.text_size) in
  let gpos = text.gpoint.pos in
  let gap_end = gpos + text.gsize in
  if pos+len >= gpos && pos < gap_end 
  then clean_text text;
  (try
     Bytes.blit text.text_string pos str 0 len
   with e -> raise e
   );
  len
@
% why need clean_text? because the gap can contain undefined
% chars! clean_text will set the gap content to 0000 everywhere.

<<function [[Text.region]]>>=
let rec region text p1 p2 =
  if p1>p2 
  then region text p2 p1
  else sub text p1 (distance text p1 p2)
@

\subsection{Paste}



% c-y
<<function [[Simple.insert_killed]]>>=
let insert_killed frame =
  let (_, text, point) = Frame.buf_text_point frame in
(*
  let top_window = Window.top frame.frm_window in
  let graphic = Efuns.backend top_window in
  let str =
    match graphic.Xdraw.get_clipboard () with
    | None | Some "" -> kill_ring.(0)
    | Some s -> 
      graphic.Xdraw.set_clipboard None;
      s
  in
*)
  let str = kill_ring.(0) in

  let pos, len =  Text.insert_res text point str in
  Text.fmove text point len; 
  last_insert := Some(frame,pos,0,len)
[@@interactive]
@

<<constant [[Simple.last_insert]]>>=
let last_insert = ref None
@
% for M-y

% M-y
<<function [[Simple.insert_next_killed]]>>=
let insert_next_killed frame =
  let (_, text, point) = Frame.buf_text_point frame in
  match !last_insert with
  |  Some (oldframe,oldpoint,n,len) when 
        oldframe == frame && oldpoint + len = Text.get_position text point ->
      let n = 
        if n = (min !kill_size kill_max) - 1 
        then 0 
        else n+1 
      in
      Text.bmove text point len;
      Text.delete text point len;
      let pos, len =  Text.insert_res text point kill_ring.(n) in
      Text.fmove text point len;
      last_insert := Some(frame,pos,n,len)
  | _ -> ()
[@@interactive]
@

%subsection{CUA mode}?

\subsection{Mark navigation}
\n it's a navigation function, but I need to present the mark before

<<navigating keys>>=
[c_x; ControlMap, Char.code 'x'], Move.point_at_mark;
@
% I use C-u C-space for that? but I have a history of mark no?
% it's different, see 'Position history' section.

<<function [[Simple.point_at_mark]]>>=
let point_at_mark frame =
  let (buf, text, point) = Frame.buf_text_point frame in
  let mark = Ebuffer.get_mark buf point in
  let pos = Text.get_position text point in
  Text.goto_point text point mark;
  Text.set_position text mark pos
[@@interactive]
@
%old:
% <<misc actions>>=
% (* C-x map *)
% define_action "point_at_mark"  Simple.point_at_mark;
% @

\subsection{Highlighting the selection}
%less: mv in colors section?

%less: when done via mouse?
%todo: could be done also in CUA mode (aka pc-select mode)

%todo: use also for C-s?


\subsection{Clipboard}
\l could be in advanced topics

% clipboard is a simple idea for inter-process communication!

\section{Undo}
% Undo history?

%todo: and redo?

<<undoing keys>>=
[ControlMap, Char.code '_'], Edit.undo;
@



<<function [[Simple.undo]]>>=
let undo frame =
  let (_, text, point) = Frame.buf_text_point frame in
  let _action, at_point, len = Text.undo text in
  frame.frm_last_text_updated <- Text.version text - 1;
  <<save current pos from frame for position history navigation (in simple.ml)>>
  Text.set_position text point at_point;
  Text.fmove text point len
[@@interactive]
@
%old:
% <<undoing actions>>=
% define_action "undo"  Simple.undo;
% @


%\subsection{Helpers}


<<type [[Text.action]]>>=
and action =
  Insertion of position * int * int
| Deletion of position * string * int
<<[[Text.action]] other cases>>
@
% who generates that? the very low-level basic text operations!
% we rely on that! otherwise undo complicated.

<<function [[Text.undo]]>>=
let undo text =
  let rec undo action =
    let gpos = text.gpoint.pos in
    let gsize = text.gsize in
    match action with
    | Insertion(point_pos, len, modified) ->
        let point = if point_pos > gpos then point_pos + gsize else point_pos in
        let (pos,str,modif) = low_delete text point len in
        text.text_modified <- modified;
        Deletion(pos,str,modif), point_pos, 0
    | Deletion (point_pos, str, modified) ->
        let point = if point_pos > gpos then point_pos + gsize else point_pos in
        let (pos,len,modif) = low_insert text point str in
        text.text_modified <- modified;
        Insertion(pos,len,modif), point_pos, String.length str
    <<[[Text.undo()]] match action cases>>
  in
  match text.text_history with
    [] -> raise Not_found
  | action :: tail -> 
      let rev_action = undo action in
      text.text_history <- tail;
      rev_action
@
%todo: should push opposite action then? so can undo the undo?

<<[[Text.t]] history fields>>=
mutable text_history : action list;
@



<<[[Text.action]] other cases>>=
| Session of action list
@

<<type [[Text.session]]>>=
type session = int
@
% used in .mly

<<[[Text.undo()]] match action cases>>=
| Session actions ->
    let last_point = ref 0 in
    let last_len = ref 0 in
    let rev_actions =
      List.fold_left (fun undos action -> 
          let (rev_action,point,len) = undo action in
          last_point := point;
          last_len := len;
          rev_action :: undos
      ) [] actions
    in
    Session rev_actions, !last_point, !last_len
@


<<function [[Text.start_session]]>>=
let start_session text =   
  text.text_modified
@

<<function [[Text.commit_session]]>>=
let commit_session text session_date =
  if text.text_modified > session_date then
    let rec iter session history =
      match history with
        [] -> assert false
      | action :: history ->
          let date =
            match action with
              Session _ -> failwith "Can not commit nested sessions"
            | Insertion (_,_,date) -> date
            | Deletion (_,_,date) -> date
          in
          if date = session_date then
            text.text_history <- (Session (List.rev (action::session)))
            :: history
          else
            iter (action::session) history
    in
    iter [] text.text_history
@

<<function [[Text.with_session]]>>=
let with_session f text =
  let session = start_session text in
  let res = f () in
  commit_session text session;
  res
@

\chapter{Search and Replace}

\section{Searching}

%later: do like in firefox, display in a scrollbar or minimap
% the matched places

<<searching keys>>=
[ControlMap, Char.code 's'], Search.isearch_forward;
[ControlMap, Char.code 'r'], Search.isearch_backward;
(* standard? *)
[MetaMap, Char.code 's'], Search.isearch_forward_regexp;
[MetaMap, Char.code 'r'], Search.isearch_backward_regexp;
@
%old:
% <<searching actions>>=
% define_action "isearch_forward"  Search.isearch_forward;
% define_action "isearch_backward"  Search.isearch_backward;
% define_action "isearch_forward_regexp"  Search.isearch_forward_regexp;
% define_action "isearch_backward_regexp"  Search.isearch_backward_regexp;
% @

<<type [[Efuns.sens]]>>=
type sens = 
| Backward
| Forward
@

%todo: need highlighting, otherwise less useful. I really missed it
% when it was not working.

\subsection{Strings}

<<constant [[Search.isearch_forward]]>>=
let isearch_forward = isearch RegexpString Forward
[@@interactive]
@
<<constant [[Search.isearch_backward]]>>=
let isearch_backward = isearch RegexpString Backward
[@@interactive]
@

\subsection{Regexps}

<<constant [[Search.isearch_forward_regexp]]>>=
let isearch_forward_regexp = isearch Regexp Forward
[@@interactive]
@
<<constant [[Search.isearch_backward_regexp]]>>=
let isearch_backward_regexp = isearch Regexp Backward 
[@@interactive]
@

\subsection{Search mini frame }

% use incremental_mini_buffer function

\subsection{Secondary cursor}

\subsection{Gap management}

<<[[Text.t]] other fields>>=
mutable text_clean : bool;
@

<<[[Text.move_gpoint_to()]] reset [[text_clean]]>>=
text.text_clean <- false;
@

% search_xxx -> <>
<<function [[Text.clean_text]]>>=
let clean_text text =
  if not text.text_clean then begin
    let size = text.text_size in
    let gsize = text.gsize in
    let string = text.text_string in
    move_gpoint_to text size;
    Bytes.fill string (size - gsize) gsize '\000';
    text.text_clean <- true
  end
@
% when we move the gap we blit but we should reset the content
% of the gap so that search function dont look for content in
% this zone. Also we need to put the gap at the end. Otherwise
% the Str search function would not work.

%todo: but if search for 'abc' and the gap is before 'b',
% then the text_string will be  a00000000bc so
% the Str function will work?

\subsection{Helpers}

<<constant [[Search.last_search]]>>=
let last_search = ref ""
@

% should be a buffer setting
<<constant [[Search.case_fold]]>>=
(* todo: this should be a buffer variable, not a global *)
let case_fold = ref false
@

<<function [[Search.isearch]]>>=
let isearch to_regexp sens frame =
  let (buf, text, point) = Frame.buf_text_point frame in

  let ismap = Keymap.create () in
  let spoint = Text.dup_point text point in
  let orig = Text.get_position text point in
  <<save current pos from frame for position history navigation>>

  let sens = ref sens in
  let to_regexp = ref to_regexp in

  let request () =
    "isearch-"^
      (match !sens with
        Backward -> "backward"
      | Forward -> "forward"
    )^
      (match !to_regexp with
        Regexp -> "-regexp :"
      | RegexpString -> " :"
    )
  in

  let string = ref "" in
  let isearch_s () =
    last_search := !string;
    let regexp, _deltaTOREMOVE =
      match !to_regexp, !case_fold with
      | Regexp, true  -> Str.regexp_case_fold !string, 0
      | Regexp, false -> Str.regexp !string, 0
      | RegexpString, true -> Str.regexp_string_case_fold !string, String.length !string
      | RegexpString, false -> Str.regexp_string !string, String.length !string
    in  
    Text.goto_point text point spoint;
    match !sens with
    | Backward -> Text.search_backward text regexp point |> ignore
    | Forward ->  
        let len = Text.search_forward text regexp point in
     (* Printf.printf  "Found at %d len %d" (Text.get_position text point) len;
        print_newline ();*)
        Text.fmove text point len
  in
  let set_last mini_frame =
    if !string = "" then begin
      let (_, text, point) = Frame.buf_text_point mini_frame in
      Text.insert text point !last_search;
      Text.fmove text point (String.length !last_search);
      string := !last_search
    end
  in

  <<[[Search.isearch()]] key bindings>>
@



<<[[Search.isearch()]] key bindings>>=
Keymap.add_binding ismap [ControlMap, Char.code 's'] 
  (fun mini_frame ->
    set_last mini_frame;      
    Text.goto_point text spoint point;
    sens := Forward;
    isearch_s ();
    Minibuffer.update_request mini_frame (request ())
);    
Keymap.add_binding ismap [ControlMap, Char.code 'r']
  (fun mini_frame ->
    set_last mini_frame;      
    Text.goto_point text spoint point;
    sens := Backward;
    isearch_s ();
    Minibuffer.update_request mini_frame (request ())
);  

Keymap.add_binding ismap [ControlMap, Char.code 'w']
  (fun mini_frame ->
    (*      set_last mini_frame;       *)
    Text.goto_point text spoint point;
    let end_current_word = Move.end_of_word buf point in
    string := !string ^ end_current_word;
    Edit.insert_string mini_frame end_current_word;
    isearch_s ();
    Minibuffer.update_request mini_frame (request ())
  );

let _mini_frame =
  Select.incremental_mini_buffer frame ismap (request ()) !string
    (fun _frame str -> 
      string := str;
      isearch_s ()
  )
  (fun _frame str -> 
      last_search := str;
      Text.remove_point text spoint
  )
in
let kill_and f mini_frame =
  last_search := Text.to_string mini_frame.frm_buffer.buf_text;
  Minibuffer.kill mini_frame frame;
  f frame
in
Keymap.add_binding ismap [ControlMap, Char.code 'g']
  (fun mini_frame  ->
    Minibuffer.kill mini_frame frame;
    Text.set_position frame.frm_buffer.buf_text frame.frm_point orig
);
Keymap.add_binding ismap [NormalMap, XK.xk_Left]
  (fun mini_frame  ->
    Minibuffer.kill mini_frame frame;
    Move.move_backward frame 1 |> ignore
   );  
Keymap.add_binding ismap [NormalMap, XK.xk_Right]
  (fun mini_frame  ->
    Minibuffer.kill mini_frame frame;
    Move.move_forward frame 1 |> ignore
  );  
Keymap.add_binding ismap [NormalMap, XK.xk_Down] (kill_and Move.forward_line);
Keymap.add_binding ismap [NormalMap, XK.xk_Up] (kill_and Move.backward_line);
Keymap.add_binding ismap [ControlMap, Char.code 'a'] 
  (kill_and Move.beginning_of_line);
Keymap.add_binding ismap [ControlMap, Char.code 'e'] 
  (kill_and Move.end_of_line)
@


<<function [[Minibuffer.update_request]]>>=
let update_request frame request =
  let qlen = String.length request in
  let window = frame.frm_window in
  let top_window = Window.top window in
  let _mini_window = Window.create true window.win_up
      qlen window.win_ypos
      (top_window.top_width - qlen) 1
  in
  frame.frm_width <- top_window.top_width - qlen;
  frame.frm_xpos <- qlen;
  frame.frm_mini_buffer <- Some request;
  frame.frm_redraw <- true
@


<<function [[Text.search_forward]]>>=
let search_forward text regexp point =
  let gsize = text.gsize in
  let gap_end = text.gpoint.pos + gsize in

  if point.pos = text.gpoint.pos 
  then point.pos <- gap_end;
  if point.pos < gap_end 
  then clean_text text;

  let gap_end = text.gpoint.pos + gsize in  
  let string = Bytes.to_string text.text_string in
  let pos = Str.search_forward regexp string point.pos in
  let pos = if pos >= gap_end then pos - gsize else pos in
  set_position text point pos;
  Str.match_end () - Str.match_beginning ()
@


<<function [[Text.search_forward_matched]]>>=
let search_forward_matched text regexp point =
  let gsize = text.gsize in
  let gap_end = text.gpoint.pos + gsize in

  if point.pos = text.gpoint.pos 
  then point.pos <- gap_end;
  if point.pos < gap_end 
  then clean_text text;

  let string = Bytes.to_string text.text_string in
  let pos = Str.search_forward regexp string point.pos in
  let pos = 
    if pos >= text.gpoint.pos + gsize 
    then pos - gsize 
    else pos 
  in
  set_position text point pos;
  Str.matched_string string
@

<<function [[Text.search_forward_groups]]>>=
let search_forward_groups text regexp point groups =
  let gsize = text.gsize in
  let gap_end = text.gpoint.pos + gsize in

  if point.pos = text.gpoint.pos 
  then point.pos <- gap_end;
  if point.pos < gap_end 
  then clean_text text;

  let gap_end = text.gpoint.pos + gsize in  
  let string = Bytes.to_string text.text_string in
  let pos = Str.search_forward regexp string point.pos in
  let pos = if pos >= gap_end then pos - gsize else pos in
  let array = Array.init groups (fun i -> Str.matched_group (i+1) string) in
  set_position text point pos;
  array
@

<<function [[Text.search_backward]]>>=
let search_backward text regexp point =
  if point.pos > text.gpoint.pos 
  then clean_text text;
  let string = Bytes.to_string text.text_string in
  let start_pos =     
    if point.pos > 0 
    then point.pos - 1 
    else raise Not_found 
  in
  let pos =  Str.search_backward regexp string start_pos in
  set_position text point pos;
  Str.match_end () - Str.match_beginning ()
@

<<function [[Text.search_backward_groups]]>>=
let search_backward_groups text regexp point groups =  
  if point.pos > text.gpoint.pos 
  then clean_text text;
  let string = Bytes.to_string text.text_string in
  let start_pos =     
    if point.pos > 0 
    then point.pos - 1 
    else raise Not_found  
  in
  let pos =  Str.search_backward regexp string start_pos in
  let array = Array.init groups (fun i -> Str.matched_group (i+1) string) in
  set_position text point pos;
  array
@





\section{Replacing}

<<replacing keys>>=
[MetaMap, Char.code '%'], Search.query_replace_string;
@


%\section{Regexps}
% mv later?

<<type [[Efuns.to_regexp]]>>=
type to_regexp =
  Regexp
| RegexpString
@

<<function [[Efuns.string_to_regex]]>>=
let string_to_regex s = s, Str.regexp s
@


<<constant [[Efuns.regexp_option]]>>=
let regexp_option = Options.define_type "Regexp" 
    (fun v -> match v with
        Value s ->  string_to_regex s | _ -> raise Not_found)
  (fun (s,_r) -> Value s)
@
% where need that? for c_error_regexp config file

\subsection{Strings}

<<function [[Search.replace_string]]>>=
let replace_string frame =
  select_replace frame "Replace string: " (fun str ->
  select_replace frame "with string: "    (fun str2 ->
    replace RegexpString frame NoQuery str str2
  ))
[@@interactive]
@
%old:
% <<replacing actions>>=
% define_action "replace_string" Search.replace_string;
% define_action "replace_regexp" Search.replace_regexp;
% define_action "query_replace_string" Search.query_replace_string;
% define_action "query_replace_regexp" Search.query_replace_regexp;
% @
% <<[[interactives_map]] initial entries>>=
% "replace_string";
% "replace_regexp";
% "query_replace_string";
% "query_replace_regexp";
% @

<<function [[Search.query_replace_string]]>>=
let query_replace_string frame =
  select_replace frame "Replace string: " (fun str ->
  select_replace frame "with string: "    (fun str2 ->
    replace RegexpString frame (Query ( frame, "Replace string ? (y/n)"))
        str str2
  ))
[@@interactive]
@

\subsection{Regexps}

<<function [[Search.replace_regexp]]>>=
let replace_regexp frame =
  select_replace frame "Replace Regexp: " (fun str ->
  select_replace frame "with string: " (fun str2 ->
    replace Regexp frame NoQuery str str2
  ))
[@@interactive]
@

<<function [[Search.query_replace_regexp]]>>=
let query_replace_regexp frame =
  select_replace frame "Replace regexp: " (fun str ->
  select_replace frame "with string: "    (fun str2 ->
    replace Regexp frame (Query (frame, "Replace regexp ? (y/n)")) str str2
  ))
[@@interactive]
@

\subsection{Helpers}

<<function [[Text.replace_matched]]>>=
let replace_matched text repl =
  Str2.replace_matched repl text.text_string
@


<<function [[Search.select_replace]]>>=
let select_replace frame request action =
  Select.select_string frame request string_history "" action 
@



<<function [[Search.replace]]>>=
let replace flag frame query str repl =
  let (_, text, point) = Frame.buf_text_point frame in
  <<save current pos from frame for position history navigation>>
  let regexp = to_regexp flag str in
  let session = Text.start_session text in
  let n = ref 0 in
  try
    let last_pos = ref (Text.get_position text point) in
    match flag,query with
      Regexp, NoQuery ->
        while not (* (Top_window.check_abort frame) *) false do
          let len = Text.search_forward text regexp point in
          let pos = Text.get_position text point in
          if pos = !last_pos then 
            (if Text.fmove_res text point 1 = 0 then raise Exit)
          else begin
              last_pos := pos;
              let result = Text.replace_matched text repl in
              let (_,_matched) = Text.delete_res text point len in
              Text.insert text point result;
              Text.fmove text point (String.length result);
              n := !n + 1
            end
        done
    | RegexpString, NoQuery ->
        let delta = String.length repl in
        while not (* (Top_window.check_abort frame) *) false do
          let len = Text.search_forward text regexp point in
          let pos = Text.get_position text point in
          if pos = !last_pos then 
            (if Text.fmove_res text point 1 = 0 then raise Exit)
          else begin
              last_pos := pos;
              Text.delete text point len;
              Text.insert text point repl;
              Text.fmove text point delta;
              n := !n + 1
            end
        done
    | Regexp, Query (frame,request) ->
        let top_window = Window.top frame.frm_window in
        let rec iter () =
          let len = Text.search_forward text regexp point in
          let pos = Text.get_position text point in
          if pos = !last_pos then begin
              (if Text.fmove_res text point 1 = 0 then raise Exit);
              iter ();
            end
          else begin
              last_pos := pos;
              top_window.top_second_cursor <- Some frame;
              let _ = Select.select_yes_or_no frame request 
                  (fun yes ->
                    if yes then
                      begin
                        let result = Text.replace_matched text repl in
                        let (_,_matched) = Text.delete_res text point len in
                        Text.insert text point result;
                        Text.fmove text point (String.length result);
                        n := !n + 1
                      end;
                    iter ()) in
              ()
            end
        in
        iter ()
    | RegexpString, Query (frame,request) ->
        let delta = String.length repl in
        let top_window = Window.top frame.frm_window in
        let rec iter () =
          let len = Text.search_forward text regexp point in
          let pos = Text.get_position text point in
          if pos = !last_pos then begin
              (if Text.fmove_res text point 1 = 0 then raise Exit);
              iter ();
            end
          else begin
              last_pos := pos;
              top_window.top_second_cursor <- Some frame;
              let _ = Select.select_yes_or_no frame request 
                  (fun yes ->
                    if yes then
                      begin
                        Text.delete text point len;
                        Text.insert text point repl;
                        Text.fmove text point delta;
                        n := !n + 1
                      end;
                    iter ()) 
              in
              ()
            end
        in
        iter ()
  with 
  | Not_found ->
      Text.commit_session text session;
      Message.message frame ("Replace "^(string_of_int !n)^" occurences")
  | _ ->
      Text.commit_session text session
@


\chapter{Multiple Buffers}

% will present 4 different ways to switch buffers:
%  - menu
%  - C-x b interactive
%  - C-x k to kill the current buffer (which in effect switch to next one)
%  - cycling


<<function [[Simple.buffer_list]]>>=
let buffer_list () =
  (Globals.editor()).edt_buffers |> Hashtbl_.hash_to_list |> List.map fst
@


%\section{Buffer names}

% can have ambiguity?
% no buf_name should be unique, so using it as a key to
% pass to change_buffer() should be enough
% (after all it's used as a key in location.edt_buffers)

% Ebuffer.create -> <>
<<function [[Ebuffer.get_name]]>>=
let get_unique_name filename =
  let basename = Filename.basename filename in
  let name = 
    if basename = "" 
    then (Filename.basename (Filename.dirname filename)) ^ "/"
    else basename
  in
  let i = ref 0 in
  let compute_name () =
    if !i =|= 0 
    then name 
    else Printf.sprintf "%s<%d>" name !i
  in
  try
    while true do
      let _ = Hashtbl.find (Globals.editor()).edt_buffers (compute_name ()) 
      in 
      incr i
    done; 
    assert false
  with Not_found -> 
    compute_name ()
@


\section{Buffers menu}

%\subsection{Graphical popup menu}

<<[[Config]] buffers menu setup>>=
Top_window.buffers_menu := (fun top_window _button () ->
    let buffers = ref [] in
    let edt = Globals.editor() in
    Hashtbl.iter (fun name _buf -> buffers := name :: !buffers) edt.edt_buffers;
    let _desc = Array.map (fun name -> 
          (name, Top_window.wrap top_window (fun top_window ->
                let frame = top_window.top_active_frame in
                let window = frame.frm_window in
                Frame.change_buffer window name
            )))
      (Array.of_list !buffers) in

    (* X11 *)
    (*
    let menu = new WX_popup.t top_window.top_root desc in
    let (x,y) = button#root_coordinates in
    menu#popup_once x (y + button#height) (Some !WX_types.button_event)
    *)
    failwith "Std_menu: show menus TODO"
    )
@
%todo: special major mode

%\subsection{Frame menu}

%old:
% <<buffer navigating actions>>=
% define_action "buffer_menu"  Buffer_menu.menu;
% @

\section{Changing the buffer}

%\section{Navigation}

<<buffer management keys>>=
[c_x; NormalMap, Char.code 'b'], Multi_buffers.change_buffer;
@

<<function [[Complex.change_buffer]]>>=
let change_buffer frame =
  let default = get_previous_frame () in
  set_previous_frame frame;
  select_buffer frame " Switch to buffer: " default (fun str ->
    Frame.change_buffer frame.frm_window str
  )
[@@interactive]
@
%old:
% <<buffer management actions>>=
% (* C-x map *)
% define_action "change_buffer"  Multi_buffers.change_buffer;
% @
% <<buffer management actions>>=
% define_action "switch_to_other_buffer"  Multi_buffers.switch_to_other_buffer;
% @

% set_previous_frame is also used in load_buffer, each time
% is close to switch to another buffer in the current frame.


<<function [[Frame.change_buffer]]>>=
let change_buffer window name = 
  try
    let buf = Hashtbl.find (Globals.editor()).edt_buffers name in
    let frame = create window None buf in
    Hooks.exec_named_hooks !!change_buffer_hooks frame;
    status_name frame buf.buf_name
  with Not_found -> ()
@

% what about the old frame? should be killed no?
% so that it gets a change to kill its associated buffer too

\section{Killing the buffer}

% how kill a buffer? it's connected to a frame, so need
% to kill the frame? but then buffer is gc'ed?

<<file menu entries>>=
"Kill Buffer", "kill_buffer";
@

<<buffer management keys>>=
[c_x; NormalMap, Char.code 'k'], Multi_buffers.kill_buffer;
@
%old:
% <<buffer management actions>>=
% (* C-x map *)
% define_action "kill_buffer"  Multi_buffers.kill_buffer;
% @

<<function [[Simple.kill_buffer]]>>=
let kill_buffer frame =
  let window = frame.frm_window in
  let buf = frame.frm_buffer in

  let new_buf = 
    match !prev_buffers with
    | x::xs when x <> buf.buf_name -> 
        prev_buffers := xs;
        (try 
          Hashtbl.find (Globals.editor()).edt_buffers x
        with Not_found -> 
          next_buffer buf
        )
    | _ -> next_buffer buf 
  in

  let _new_frame = Frame.create window None new_buf in
  if buf.buf_shared = 0 
  then Ebuffer.kill buf
[@@interactive]
@
%less: can aspectize the prev_buffers things, so that more stuff together
%note: when buf_shared gets down to 0? With Frame.kill.
% But who calls Frame.kill? Frame.install!
% Ebuffer.kill below should not be used in plugins and hoping it will
% kill a buffer.
% What you want is kill the frame managing the buffer, and then
% once you're sure there are no more reference to the buf
% then you can kill it.
% Which is what kill_buffer above does.


<<function [[Ebuffer.kill]]>>=
let kill buf =
  let edt = Globals.editor() in
  Hashtbl.remove edt.edt_buffers buf.buf_name;
  buf.buf_filename |> Option.iter (fun filename ->
    Hashtbl.remove edt.edt_files filename
  );
  List.iter (fun f -> f () ) buf.buf_finalizers;
(* TODO Gc.compact (); this cause some segfault under plan9 with ocaml light *)
  buf.buf_shared <- -1
@
% let the gc do its work! put to -1 because maybe
% some code still has a ref to the buffer, in which case
% it will raise BufferKilled exn


\section{Cycling buffers}
% of frame?

% LeFessant specific?

<<constant [[Select.prev_buffers]]>>=
(* todo: maybe this should be in frame.ml, next to change_buffer,
 * so change_buffer can maintain it instead of imposing to everyone
 * to use set_previous_frame just before Frame.change_buffer.
 * todo: or do via change_buffer_hook?
 *)
let prev_buffers = ref []
@

<<function [[Complex.left_buffer]]>>=
let left_buffer frame =
  set_previous_frame frame;
  Frame.change_buffer frame.frm_window 
    (match !prev_buffers with
    | name :: buffer :: tail ->
        prev_buffers := tail @ [name]; 
        buffer
    | _ -> raise Not_found
    )
[@@interactive]
@
%old:
% <<buffer navigating actions>>=
% (* C-M map *)
% define_action "left_buffer"  Multi_buffers.left_buffer;
% (* C-M map *)
% define_action "right_buffer"  Multi_buffers.right_buffer;
% @

<<function [[Complex.right_buffer]]>>=
let right_buffer frame =
  set_previous_frame frame;
  Frame.change_buffer frame.frm_window 
    (match !prev_buffers with
    | name :: tail ->
        (match List.rev tail with
        | buffer :: tail ->
            prev_buffers := name :: (List.rev tail);
            buffer
        | _ -> raise Not_found
        )
    | _ -> raise Not_found
    )
[@@interactive]
@


<<function [[Select.set_previous_frame]]>>=
let set_previous_frame frame = 
  let name = frame.frm_buffer.buf_name in
  prev_buffers := name :: (Utils.list_removeq !prev_buffers name)
@


\section{Pinning buffers}
% LeFessant extension I think

<<buffer navigating keys>>=
(* pinning, lefessant?? *)
[ControlMetaMap, XK.xk_Down], Multi_buffers.down_buffer;
[ControlMetaMap, XK.xk_Up], Multi_buffers.up_buffer;
@


<<constant [[Complex.up_buffer]]>>=
let up_buffer = ref ""
@

<<function [[Complex.down_buffer]]>>=
let down_buffer frame = 
  up_buffer := frame.frm_buffer.buf_name
[@@interactive]
@

<<function [[Complex.up_buffer]]>>=
let up_buffer frame =
  if !up_buffer = "" 
  then raise Not_found;
  set_previous_frame frame;
  Frame.change_buffer frame.frm_window !up_buffer
[@@interactive]
@
%old:
% <<buffer navigating actions>>=
% (* C-M map *)
% define_action "down_buffer"  Multi_buffers.down_buffer;
% (* C-M map *)
% define_action "up_buffer"  Multi_buffers.up_buffer;
% @

\chapter{Multiple Windows}
% frames?

% recall window_down type!

% rendering:
% Top_window.update_display -> <> -> Frame.display
<<function [[Window.iter]]>>=
let iter f window = 
  let rec iter1 window =
    match window.win_down with
    | HComb (w1,w2) -> iter1 w1; iter1 w2       
    | VComb (w1,w2) -> iter1 w1; iter1 w2
    | WFrame frame -> f frame
    | NoFrame -> ()
  in
  iter1 window
@

% the active window??

% changed when navigate window, or delete windows.
% one_frame | Window.next | ... -> <>
<<function [[Frame.active]]>>=
let active frame =
  let top_window = Window.top frame.frm_window in
  top_window.top_active_frame <- frame;
  frame.frm_buffer.buf_filename |> Option.iter (fun filename ->
    (Globals.editor()).edt_dirname <- Filename.dirname filename
  )
@
% so edt_dirname is dirname of active frame!

\section{Creating sub windows}

<<[[edit_menu]] entries>>=
"Cut Frame", "vertical_cut_frame";
@

<<frame management keys>>=
[c_x; NormalMap, Char.code '2'], Multi_frames.vertical_cut_frame;    
[c_x; NormalMap, Char.code '3'], Multi_frames.horizontal_cut_frame;    
@
% a bit like fork! and then can use C-x b to exec :)

<<function [[Multi_frames.v_cut_frame]]>>=
let vertical_cut_frame frame =
  if frame.frm_mini_buffer = None 
  then Frame.create (cut_frame frame) None frame.frm_buffer |> ignore
[@@interactive]
@
%old: 
% <<frame management actions>>=
% (* C-x map *)
% define_action "vertical_cut_frame"  Multi_frames.v_cut_frame;    
% (* C-x map *)
% define_action "horizontal_cut_frame"  Multi_frames.h_cut_frame;    
% @


<<function [[Multi_frames.h_cut_frame]]>>=
let horizontal_cut_frame frame =
  if frame.frm_mini_buffer = None 
  then
    let window = frame.frm_window in
    if window.win_width > 10 then begin
      let wi = window.win_width / 2 in
      let w1 = Window.create false
                 (Window window) window.win_xpos window.win_ypos
                 wi window.win_height in
      let w2 = Window.create false (Window window) (window.win_xpos + wi) 
                 window.win_ypos
                 (window.win_width - wi) window.win_height in
      window.win_down <- HComb (w1,w2);
      Frame.install w1 frame;
      Frame.create w2 None frame.frm_buffer |> ignore
    end
[@@interactive]
@

% usually create also subwindows when run certain commands,
% like M-!, in which case the code usually looks like
% let newwin = Multi_frames.cut_frame frame in 
% Frame.create buf newwin ...


<<function [[Multi_frames.cut_frame]]>>=
let cut_frame frame =
  let window = frame.frm_window in
  if window.win_height > 3 then
    let h = window.win_height / 2 in
    let w1 = Window.create false
        (Window window) window.win_xpos window.win_ypos
        window.win_width h in
    let w2 = Window.create false (Window window) window.win_xpos 
        (window.win_ypos + h) 
      window.win_width (window.win_height - h) in
    window.win_down <- VComb (w1,w2);
    Frame.install w1 frame;
    w2 
  else
    window
@

\section{Deleting sub windows}

<<[[edit_menu]] entries>>=
"One Frame", "one_frame";
"Delete Frame", "delete_frame";
@
%bug? not sure v_cut_frame will work!
<<frame management keys>>=
[c_x; NormalMap, Char.code '1'], Multi_frames.one_frame;
[c_x; NormalMap, Char.code '0'], Multi_frames.delete_frame;
@

<<function [[Multi_frames.one_frame]]>>=
let one_frame frame =
  if frame.frm_mini_buffer = None 
  then
    let window = frame.frm_window in
    let top_window = Window.top window in
    if not (top_window.window == window) then
      begin
        Frame.install top_window.window frame;
        Frame.active frame
      end
[@@interactive]
@


<<function [[Multi_frames.delete_frame]]>>=
let delete_frame frame =
  if frame.frm_mini_buffer = None 
  then
    let window = frame.frm_window in
    match window.win_up with
    | TopWindow _ -> ()
    | Window upwin ->
        Frame.install upwin frame;
        Frame.active frame
[@@interactive]
@
%old:
% <<frame management actions>>=
% (* C-x map *)
% define_action "one_frame"  Multi_frames.one_frame;
% (* C-x map *)
% define_action "delete_frame"  Multi_frames.delete_frame;
% @

% upper window gets active




% (Frame.create -> Frame.install) | Minibuffer.kill  -> <>
<<function [[Frame.kill]]>>=
let kill frame = 
  let (buf, text, point) = buf_text_point frame in
  <<[[Frame.kill()]] setting [[frm_killed]] field>>
  buf.buf_shared <- buf.buf_shared - 1;
  Text.remove_point text buf.buf_point;
  Text.remove_point text buf.buf_start;
  buf.buf_point <- point;
  buf.buf_start <- frame.frm_start
@
% this will be called when you create a new frame for an existing
% window in which case Frame.install iter over all frames in
% the window and kill them all.


% ??? -> <>
<<function [[Multi_frames.remove_frame]]>>=
let remove_frame frame =
  if frame.frm_mini_buffer = None then
    let window = frame.frm_window in
    match window.win_up with
    | TopWindow _ -> ()
    | Window upwin ->
        Window.prev (Frame.install upwin) window
@

\section{Navigating windows}

<<frame navigation keys>>=
[c_x; NormalMap, Char.code 'o'], Multi_frames.next_frame;
@

<<function [[Multi_frames.next_frame]]>>=
let next_frame frame =
  let window = frame.frm_window in
  Window.next Frame.active window
[@@interactive]
@
%old:
% <<frame navigation actions>>=
% (* C-x map *)
% define_action "next_frame"  Multi_frames.next_frame;
% @


<<function [[Window.next]]>>=
let rec next f window =
  match window.win_up with
  | TopWindow top_window -> first f top_window.window
  | Window win ->
      match win.win_down with
        HComb (_w1,w2) ->
          if w2 == window 
          then next f win
          else first f w2
      | VComb (_w1,w2) ->
          if w2 == window 
          then next f win
          else first f w2
      | _ -> ()
@


%\section{Navigation}


% ?? -> <>
<<function [[Window.first]]>>=
let rec first f window =
  match window.win_down with
    WFrame frame -> f frame
  | HComb (w1,_w2) -> first f w1
  | VComb (w1,_w2) -> first f w1
  | NoFrame -> ()
@

% ?? -> <>
<<function [[Window.last]]>>=
let rec last f window =
  match window.win_down with
    WFrame frame -> f frame
  | HComb (_w1,w2) -> last f w2
  | VComb (_w1,w2) -> last f w2
  | NoFrame -> ()
@


% ?? -> <>
<<function [[Window.prev]]>>=
let rec prev f window =
  match window.win_up with
    TopWindow top_window -> 
      if window == top_window.window then ()
      else 
        last f top_window.window
  | Window win ->
      match win.win_down with
        HComb (w1,_w2) ->
          if w1 == window 
          then prev f win
          else last f w1
      | VComb (w1,_w2) ->
          if w1 == window 
          then prev f win
          else last f w1
      | _ -> ()
@



\chapter{Major Modes}

% structured vs text editor and more
% https://github.com/shaunlebron/history-of-lisp-editing

% have seen very generic features before, navigating, insert/delete,
% search/replace. Now we will see more specific features. File
% specific features!

<<[[Efuns.buffer]] other fields>>=
mutable buf_major_mode : major_mode;
@
% note that major mode is a property of the buffer! not the frame.

<<type [[Efuns.major_mode]]>>=
and major_mode = {
    maj_name : string;
    maj_map : map;

    mutable maj_hooks : (buffer -> unit) list;
    mutable maj_vars : Store.t;

    (* another customization is the syntax table! don't forget
     * to call Ebuffer.create_syntax_table and modify
     * buf.buf_syntax_table otherwise you'll modify
     * the shared syntax table
     *)
  }
@

% toplevel fondamental_mode | every major modes  -> <>
<<function [[Ebuffer.new_major_mode]]>>=
let new_major_mode name hook_opt = {
    maj_name = name;
    maj_map = Keymap.create ();
    maj_hooks = (match hook_opt with None -> [] | Some hook -> [hook]);
    maj_vars = Store.new_store ();
  }
@
%old: was passing hooks as parameter, but always 0 or 1 elt


% set_buffer_mode -> <>
<<function [[Ebuffer.set_major_mode]]>>=
let set_major_mode buf mode =
  if !Globals.debug
  then UCommon.pr2 (spf "setting %s major mode" mode.maj_name);
  buf.buf_modified <- buf.buf_modified + 1;
  buf.buf_major_mode <- mode;
  mode.maj_hooks |> List.iter (fun f -> 
    try f buf 
    with exn -> Error.error_exn "set_major_mode" exn
  )
@


<<[[Efuns.status]] other fields>>=
mutable stat_mode : major_mode;
@



\section{Fundamental mode}

<<function [[Ebuffer.fondamental_mode]]>>=
let fondamental_mode frame =
  set_major_mode frame.frm_buffer fondamental__mode
[@@interactive]
@
%old:
% <<major mode actions>>=
% define_action "fondamental_mode" fondamental_mode;
% @
% <<[[interactives_map]] initial entries>>=
% "fondamental_mode";
% @


% it's fundamental-mode normally :) french :)

<<constant [[Ebuffer.fondamental_mode]]>>=
let fondamental__mode = new_major_mode "Fondamental" None (* no hooks *)
@

% always same pattern and flow:
% "xxx_mode" action -> xxx_mode func -> xxx_mode variable -> hooks (install)

\section{Auto detection}

<<constant [[Ebuffer.modes_alist]]>>=
let modes_alist = Store.create_abstr "modes_alist"
@
% who sets it? the start_hook of many programming modes


<<constant [[Ebuffer.suffix_reg]]>>=
let suffix_reg = Str.regexp "\\(.*\\)<[0-9]+>$"
@
%$

% Ebuffer.create -> <> (as hook <- create_buf_hook <- add_hook <>)
<<function [[Ebuffer.set_buffer_mode]]>>=
let set_buffer_mode buf =
  let buf_name = 
    match buf.buf_filename with
      None -> 
        (try
           if Str.string_match suffix_reg buf.buf_name 0 
           then Str.matched_group 1 buf.buf_name 
           else buf.buf_name 
         with exn -> 
           Error.error_exn "set_buffer_mode" exn;
           buf.buf_name
         )
    | Some file_name -> file_name 
  in 
  let modes_alist = Var.get_var buf modes_alist in
  (* must use != here, because modes_alist contain functional values *)
  if (Common.phys_not_equal !modes_old modes_alist) then begin
    regexp_alist := modes_alist |> List.map (fun (file_reg, major) ->
      Str.regexp file_reg, major
    );
    modes_old := modes_alist;
  end;
  try
    !regexp_alist |> List.iter (fun (regexp, major) ->
      if Str.string_match regexp buf_name 0 
      then
        try
          set_major_mode buf major;
          raise Exit
        with 
        | Exit -> raise Exit
        | exn -> 
          Error.error_exn "set_buffer_mode" exn;
          raise Exit
    ) 
  with Exit -> ()
@
% ugly those raise Exit

% opti, memo in regexp_alist
<<constant [[Ebuffer.modes_old]]>>=
let modes_old = ref []
@
<<constant [[Ebuffer.regexp_alist]]>>=
let regexp_alist = ref []
@

<<toplevel [[Ebuffer]] starting hook>>=
let _ =
  Hooks.add_start_hook (fun () ->
    Var.set_global create_buf_hook [set_buffer_mode];
    Var.set_global modes_alist []
  )
@
% important hook!!


\section{Status line}

<<[[Frame.create_without_top()]] adjust status of frame>>=
status_major_mode frame;
@

<<function [[Frame.status_major_mode]]>>=
let status_major_mode frame  =
  let buf = frame.frm_buffer in
  let status = frame.frm_status in
  if not (Common.phys_equal status.stat_modes buf.buf_minor_modes &&
           Common.phys_equal status.stat_mode buf.buf_major_mode
    ) then
    begin
      status.stat_modes <- buf.buf_minor_modes;
      status.stat_mode <- buf.buf_major_mode;
      status_print status (Printf.sprintf "(%s)" 
          (String.concat " "
            (buf.buf_major_mode.maj_name ::
            (List.map (fun m -> m.min_name) status.stat_modes))))
      StatMode;
    end
@

%<<function Frame.print_list>>=
%let rec print_list list =
%  match list with
%    [] -> ""
%  | [ele] -> ele
%  | ele :: ( (_ :: _) as tail) ->
%      ele ^ " " ^ (print_list tail)
%@
% common.join " ", or String.concat " "

\section{Major mode variables and keys}

<<function [[Var.set_major_var]]>>=
let set_major_var maj var value = 
  Store.set maj.maj_vars var value
@

<<function [[Keymap.add_major_key]]>>=
let add_major_key major prefix action = 
  add_binding major.maj_map prefix action
@
%old:  interactive major.maj_map 


<<[[Ebuffer.get_binding()]] major mode key search>>=
(let b = Keymap.get_binding buf.buf_major_mode.maj_map keylist in
  match b with
    Prefix _map -> binding := b
  | Function _f -> binding := b; raise Exit
  | Unbound -> ());
@

<<[[Var.get_var()]] try with major mode variables>>=
Store.get buf.buf_major_mode.maj_vars var
@

\section{Customization examples}

% the variable and keymap seen before is already the way
% to have some customization. But there are more.

% https://channel9.msdn.com/Blogs/Seth-Juarez/Anders-Hejlsberg-on-Modern-Compiler-Construction
% needs of IDE/editor:
%  - syntax coloring -> lexer enough
%  - folding -> need parser
%  - error checking, method completion -> need type checker
% analysis mode:
%  - push-mode: compiler go down the tree carrying info from top
%  - pull-mode: completion tool go up the tree to pull out information
%    incrementally. Erase the world each time. Just save the ASTs in memory.
%    (julien does more, he typecheck the whole world each time)
% We can put a language intelligence in one external tool, and editor can
% communicate with it. Editor does not have to know anything about the langage.
% Just need a protocol (using JSON for instance) to communicate with the
% external program.

\subsection{Colors}
% Attributes.

% see section on colors in Text chapter

%https://github.com/sublimehq/Packages/blob/master/OCaml/OCaml.sublime-syntax
% but in the end longer than the ocamllex spec of ocaml :)
% (ok maybe it's more fault tolerant, but still)

\subsection{Indentation}

\subsection{Abbrevs}

\subsection{Structures}
%less: merge with abbrevs?

%ex: data passed to install_structures
%      [c_c; n'; NormalMap, Char.code 'b'], "begin ^^ end^^";
%      [c_c; n'; NormalMap, Char.code 'f'], "for ^^ to ^^ do\n^^";
%      [c_c; n'; NormalMap, Char.code 'w'], "while ^^ do\n^^\ndone";
% a kind of abbrev


<<misc keys>>=
[ c_c; NormalMap, Char.code '-'], Structure.next_hole;
@

% Simple.insert_structure -> <>
<<function [[Simple.next_hole]]>>=
(* a hole is two consecutive '^' chars *)
let next_hole frame = 
  let (_, text, point) = Frame.buf_text_point frame in
  Text.with_dup_point text point (fun curseur ->
    while 
      not ((Text.get_char text curseur = '^') && (Text.fmove_res text curseur 1 = 1) &&
        (Text.get_char text curseur = '^')) && (Text.fmove_res text curseur 1 = 1)  do () done;
    if Text.get_char text curseur = '^' then
      (Text.bmove text curseur 1;
        Text.delete text curseur 2;
        Text.goto_point text point curseur);
  )
[@@interactive]
@
%old:
% <<misc actions>>=
% (* C-M map *)
% define_action "next_hole" Structure.next_hole;
% @

% install_structures -> <>
<<function [[Simple.insert_structure]]>>=
let insert_structure s frame =
  let (_, text, point) = Frame.buf_text_point frame in
  Text.insert text point s;
  next_hole frame
@
% ???
<<function [[Simple.install_structures]]>>=
let install_structures buf list =
  list |> List.iter (fun (key, s) ->
    Keymap.add_binding buf.buf_map key (insert_structure s)
  )
@

\subsection{Compilation and errors}

% next error variable

\subsection{Outline}
% or put with minor mode? after all it's a bit similar
% to paren_mode where each major mode can customize what
% is a paren-able character.

\subsection{Completion}
% simple completion, smart (contextual) completion

\chapter{Minor Modes}

% diff with major mode? can have multi minor mode, but
% could unify and have multi major mode? or major mode
% is just the one to display first?

<<[[Efuns.buffer]] other fields>>=
mutable buf_minor_modes : minor_mode list;
@

<<type [[Efuns.minor_mode]]>>=
and minor_mode = {
    min_name : string;
    min_map : map;

    mutable min_hooks : (buffer -> unit) list;
    mutable min_vars : Store.t;
  }
@

%dead:?
%<<function Ebuffer.new_minor_mode>>=
%let new_minor_mode name = {
%    min_name = name;
%    min_map = Keymap.create ();
%    min_hooks = [];
%    min_vars = Store.vars ()
%  }
%@


<<function [[Ebuffer.new_minor_mode]]>>=
let new_minor_mode name hooks  = {
    min_name = name;
    min_map = Keymap.create ();
    min_hooks = hooks;
    min_vars = Store.new_store ()
  }
@


<<function [[Ebuffer.set_minor_mode]]>>=
let set_minor_mode buf mode =
  buf.buf_minor_modes <- mode :: buf.buf_minor_modes;
  buf.buf_modified <- buf.buf_modified + 1;
  mode.min_hooks |> List.iter (fun f -> 
    try f buf 
    with exn -> Error.error_exn "set_minor_mode" exn
  ) 
@

<<function [[Ebuffer.del_minor_mode]]>>=
let del_minor_mode buf minor =
  buf.buf_minor_modes <- 
    List.fold_right (fun mode list -> 
      if Common.phys_equal mode minor then begin
        buf.buf_modified <- buf.buf_modified + 1;
        list
      end else (mode :: list)
    ) buf.buf_minor_modes []
@


<<[[Efuns.status]] other fields>>=
mutable stat_modes : minor_mode list;
@


\section{Example}
%less: maybe better to use paren mode as example, more concrete
% instead of all those empty functions, harder to understand.

<<constant [[Minor_mode_sample.minor_mode_name]]>>=
let minor_mode_name = "my_minor"
@

% empty install hook
<<function [[Minor_mode_sample.install]]>>=
let install _buf = 
  ()
@

%!! that's what you will modify
<<constant [[Minor_mode_sample.mode]]>>=
let mode = Ebuffer.new_minor_mode  minor_mode_name [install]
@


<<function [[Minor_mode_sample.minor_mode_fun]]>>=
let minor_mode_fun _frame = ()
@


<<toplevel [[Minor_mode_sample._1]]>>=
let _ = 
  List.iter
    (fun key -> 
      Keymap.add_binding mode.min_map [NormalMap, Char.code key]
        minor_mode_fun
  )
  [ ] (* no keys *)
@

%ex:
%<<toplevel Paren_mode._1>>=
%let _ = 
%  List.iter
%    (fun key -> 
%      Keymap.add_binding mode.min_map [NormalMap, Char.code key] find_matching
%  ) [ ')'; '}'; ']' ]
%@


<<toplevel [[Minor_mode_sample._2]]>>=
let _ = 
  Action.define_action (minor_mode_name ^ "_mode") 
    (Minor_modes.toggle_minor mode)
@
% could be define_buffer_action too as don't use any info from the frame
%todo: could factorize this idiom

<<function [[Ebuffer.has_minor_mode]]>>=
let has_minor_mode buf minor =
  List.memq minor buf.buf_minor_modes
@
%old: was called modep

\section{Minor mode variables and keys}

<<function [[Var.set_minor_var]]>>=
let set_minor_var min var value = 
  Store.set min.min_vars var value
@

<<function [[Keymap.add_minor_key]]>>=
let add_minor_key minor prefix action = 
  add_binding minor.min_map prefix action
@
%old:  interactive minor.min_map 



<<[[Ebuffer.get_binding()]] minor mode key search>>=
buf.buf_minor_modes |> List.iter (fun minor ->
  let b = Keymap.get_binding minor.min_map keylist in
  match b with
    Prefix _map -> binding := b
  | Function _f -> binding := b; raise Exit
  | Unbound -> ()
); 
@

<<[[Var.get_var()]] try with minor mode variables>>=
let rec iter list =
  match list with
  | [] -> raise Not_found
  | min :: list -> 
      try
        Store.get min.min_vars var
      with _ -> iter list
in
iter buf.buf_minor_modes
@





\chapter{Extra Features}

%todo: implement more features! especially good one in Atom/Sublime/VsCode/...
% - multiple cursors (but does not work well with gap buffer)
%   http://emacsrocks.com/e13.html

\section{Running external commands}

% and get result in a buffer! "everything is a buffer"
% so can then use all the tools in emacs to manipulate the output
% of this external command

<<external commands keys>>=
[MetaMap, Char.code '!'], System.shell_command;
@

<<constant [[System.shell_hist]]>>=
let shell_hist = ref []
@
<<function [[System.shell_command]]>>=
let shell_command frame =
  Select.select_string frame "Run command:" shell_hist "" (fun cmd -> 
    let pwd = (Globals.editor()).edt_dirname in
    start_command pwd "*Command*" (Multi_frames.cut_frame frame) cmd None |> ignore)
[@@interactive]
@
%old:
% <<external command actions>>=
% define_action "shell_command"  System.shell_command;
% @


<<function [[System.start_command]]>>=
let start_command pwd buf_name window cmd end_action_opt =
  let end_action =
    match end_action_opt with
    | None  -> (fun _buf _status -> ())
    | Some f -> f
  in
  let buf = system pwd buf_name cmd end_action in
  let frame = Frame.create window None buf in
  frame
@

%emacs:
% we can use threads! no more emacs lisp limitations

<<function [[System.system]]>>=
let system pwd buf_name cmd end_action =
  let (pid,inc,outc) = open_process pwd cmd in
  let text = Text.create "" in
  let curseur = Text.new_point text in
  let buf = Ebuffer.create buf_name None text (Keymap.create ()) in
  (* !!! *)
  buf.buf_sync <- true;

  let ins = Unix.descr_of_in_channel inc in
  let tampon = Bytes.create 1000 in
  let active = ref true in
  let edt = Globals.editor () in
  Concur.add_reader ins (fun () ->
    let _pos,str = Text.delete_res text curseur
                    (Text.point_to_eof text curseur) in
    let len = input inc tampon 0 1000 in
    Mutex.lock edt.edt_mutex;
    if len =|= 0 then begin
      let _pid,status = waitpid [WNOHANG] pid in
      (match status with 
      | WEXITED s -> Text.insert_at_end text (spf "Exited with status %d\n" s); 
          close_in inc;
          close_out outc;
          (try end_action buf s with _ -> ())
      | _ -> Text.insert_at_end text "Broken pipe" 
      );
      Text.set_position text curseur (Text.size text);
      active := false;
      (* redraw screen *)
      Top_window.update_display ();

      Mutex.unlock edt.edt_mutex;
      Concur.remove_reader ins; (* Kill self *)
    end
    else
      Text.insert_at_end text (Bytes.sub_string tampon 0 len);

    Text.set_position text curseur (Text.size text);
    Text.insert text curseur str;
    buf.buf_modified <- buf.buf_modified +1;

    (* redraw screen *)
    Top_window.update_display ();
    Mutex.unlock edt.edt_mutex
  );

  let lmap = buf.buf_map in
  Keymap.add_binding lmap [NormalMap, XK.xk_Return] (fun frame ->
    let point = frame.frm_point in
    Text.insert text point "\n";
    Text.fmove text point 1;
    if !active then (* to avoid a segmentation fault in Ocaml *) begin
      let str = Text.sub text curseur 
          (Text.point_to_eof text curseur) in
      Text.set_position text curseur (Text.size text);
      (* synchronize viewpoint *)
      output_substring outc str 0 (String.length str);
      flush outc
    end
  );
  <<[[System.system()]] set finalizer, to intercept killed frame>>
  buf
@


<<function [[System.open_process]]>>=
let open_process pwd cmd =
  let (in_read, in_write) = pipe() in
  let (out_read, out_write) = pipe() in
  let inchan = in_channel_of_descr in_read in
  let outchan = out_channel_of_descr out_write in
  match fork() with
  | 0 ->
      if out_read <> Unix.stdin then begin
        dup2 out_read Unix.stdin; 
        close out_read 
      end;
      if in_write <> Unix.stdout ||  in_write <> Unix.stderr then begin
        if in_write <> Unix.stdout 
        then dup2 in_write Unix.stdout;
        if in_write <> Unix.stderr 
        then dup2 in_write Unix.stderr; 
        close in_write 
      end;
      List.iter close [in_read;out_write];
      (* I prefer to do it here than in the caller *)
      Sys.chdir pwd;
      execv "/bin/sh" [| "/bin/sh"; "-c"; cmd |]
      (* never here! *)
      (* exit 127 (* for ocaml light *) *)
  | pid -> 
      Unix.close out_read;
      Unix.close in_write;
      (pid, inchan, outchan)
@


<<function [[Text.insert_at_end]]>>=
let insert_at_end text str =
  low_insert text text.text_size str |> ignore;
  text.text_history <- [];
  text.text_modified <- text.text_modified + 1
@

\subsection{Threads and mutex}

<<[[Efuns.editor]] other fields>>=
edt_mutex : Mutex.t;
@
% have multiple threads? need mutual exclusion?
% need that for System!
% (also maybe need that too have multiple top_windows).

\subsection{Finalizers}

<<[[Efuns.buffer]] other fields>>=
mutable buf_finalizers : (unit -> unit) list;
@
% when need that? if attached to a process?

<<[[System.system()]] set finalizer, to intercept killed frame>>=
buf.buf_finalizers <- (fun () -> 
  (try 
     Unix.kill pid Sys.sigkill;
     waitpid [] pid |> ignore;
   with _ -> ()
  );
  Concur.remove_reader ins
) :: buf.buf_finalizers;
@



\subsection{Synchronous buffers}

<<[[Efuns.buffer]] other fields>>=
mutable buf_sync : bool;
@

<<[[Frame.display()]] if buf sync goto end of text>>=
if buf.buf_sync && buf.buf_modified <> frame.frm_last_buf_updated 
then Text.set_position text point (Text.size text); 
@
% go at the end automatically even if no action was made
%todo: except if start to mv? in which case remove the buf_sync?


\section{Compilation and grep mode}

<<file menu entries>>=
"Compile", "compile";
@


\subsection{[[M-x grep]]}

<<constant [[Compil.grep_command]]>>=
let grep_command = define_option ["compil"; "grep_command"] "" string_option
    "grep -n"
@

<<constant [[Compil.grep_hist]]>>=
let grep_hist = ref ["grep -n "]
@

<<function [[Compil.grep]]>>=
let grep frame =
  let default = List.hd !grep_hist in
  Select.select_string frame 
    (Printf.sprintf "Grep command: %s (default: %s) " !!grep_command default)
    grep_hist ""
    (fun cmd -> 
      let cmd = if cmd = "" then default else cmd in
      let cmd = !!grep_command ^ " " ^ cmd in
      let cdir = Frame.current_dir frame in
      let comp_window =
        match !compilation_frame with
        | None -> Multi_frames.cut_frame frame 
        | Some (new_frame,error_point, _) ->
            Text.remove_point new_frame.frm_buffer.buf_text error_point;
            Ebuffer.kill new_frame.frm_buffer;
            if new_frame.frm_killed 
            then Multi_frames.cut_frame frame
            else new_frame.frm_window 
      in
      let comp_frame = System.start_command cdir "*Grep*" comp_window cmd 
         (Some (fun buf _status -> color_buffer buf))
      in
      Frame.active frame; 
      let buf = comp_frame.frm_buffer in
      let error_point = Text.new_point buf.buf_text in
      compilation_frame := Some (comp_frame, error_point, cdir)
      (* todo? no set major mode? *)
  )
[@@interactive]
@
%old:
% <<external command actions>>=
% define_action "grep" Compil.grep;
% define_action "compile" Compil.compile;
% @
% <<[[interactives_map]] initial entries>>=
% "compile";
% "grep";
% @


<<function [[Frame.current_dir]]>>=
let current_dir frame =
  let buf = frame.frm_buffer in
  match buf.buf_filename with
  | Some filename -> Filename.dirname filename ^ "/"
  | None -> (Globals.editor()).edt_dirname ^ "/"
@
% note that edt_dirname is actually the dirname of the file of the
%  active frame (or the cwd of efuns when it was started)

\subsection{[[M-x compile]]}

%<<function Config.compile>>=
%(*
%let compile frame =
%  Interactive.exec_interactive (Interactive.buf_interactives frame.frm_buffer) 
%    frame "compile"
%*)
%@
% ???

<<constant [[Compil.make_hist]]>>=
let make_hist = ref [!!make_command]
@
<<constant [[Compil.make_command]]>>=
(* old: was "make -k" to keep going after first error, but I prefer without*)
let make_command = define_option ["compil";"make_command"] ""
    string_option "make"
@

<<function [[Compil.compile]]>>=
let compile frame =
  let default = List.hd !make_hist in
  Select.select_string frame 
    ("Compile command: (default :"^ default^") " )
    make_hist ""
    (fun cmd -> 
      let cmd = if cmd = "" then default else cmd in (* cmd ||| default *)
      let cdir = Frame.current_dir frame in
      <<[[Compil.compile()]] find possibly cdir with a makefile>>
      let comp_window =
        match !compilation_frame with
        | None -> Multi_frames.cut_frame frame 
        | Some (new_frame,error_point, _) ->
            Text.remove_point new_frame.frm_buffer.buf_text error_point;
            Ebuffer.kill new_frame.frm_buffer;
            if new_frame.frm_killed 
            then Multi_frames.cut_frame frame
            else new_frame.frm_window 
      in
      (* this makes also comp_frame the active frame *)
      let comp_frame = 
        System.start_command cdir "*Compile*" comp_window cmd 
        (Some (fun buf _status -> color_buffer buf))
      in
      (* switch back cursor to original frame *)
      Frame.active frame;
      let buf = comp_frame.frm_buffer in
      let error_point = Text.new_point buf.buf_text in
      compilation_frame := Some (comp_frame, error_point, cdir);

      (* propagate vars *)
      let buf2 = frame.frm_buffer in
      (try 
         let x = Var.get_var buf2 find_error in
         Var.set_local buf find_error x
       with Not_found | Failure _ -> ()
      );
      (try 
         let x =  Var.get_var buf2 find_error_location_regexp in
         Var.set_local buf find_error_location_regexp x
       with Not_found | Failure _ -> ()
      );
      (try 
         let x =  Var.get_var buf2 find_error_error_regexp in
         Var.set_local buf find_error_error_regexp x
       with Not_found | Failure _ -> ()
      );
      (* set major mode *)
      Ebuffer.set_major_mode buf mode

  )
[@@interactive]
@
%old:
% <<misc actions>>=
% (*define_action "compile" compile;*)
% @


<<constant [[Compil.compilation_frame]]>>=
let compilation_frame = ref None
@


\subsection{Finding the makefile automatically}

<<constant [[Compil.compile_find_makefile]]>>=
let compile_find_makefile = define_option ["compil";"find_makefile"] ""
    bool_option true
@

<<[[Compil.compile()]] find possibly cdir with a makefile>>=
let cdir, cmd = 
  match () with
  | _ when cmd =~ "^cd +\\([^;]+\\);\\(.*\\)$" ->
      let (dir, cmd) = Common.matched2 cmd in
      let finaldir = expand_tilde dir in
      finaldir, cmd
  | _ when !!compile_find_makefile && cmd =~ "^make" ->
    (* try to find a Makefile in the directory *)
      let rec iter dir =
        if Sys.file_exists (Filename.concat dir "Makefile") ||
           Sys.file_exists (Filename.concat dir "makefile") ||
           Sys.file_exists (Filename.concat dir "GNUmakefile")
        then dir 
        else
          let newdir = Filename.dirname dir in
          if newdir = dir 
          then cdir 
          else iter newdir
      in
      iter cdir, cmd
  | _ -> cdir, cmd
in
@

\subsection{Go to next error}

<<misc keys>>=
[c_x;NormalMap, Char.code '`' ], Compil.next_error;
@

%old:
% <<misc actions>>=
% (* C-x map *)
% define_action "next_error"  Compil.next_error;
% @
%pad: C-n


<<constant [[Compil.find_error]]>>=
let find_error = Store.create_abstr "find_error"
@


<<function [[Compil.next_error]]>>=
let next_error top_frame =
  match !compilation_frame with
  | None -> Message.message top_frame "No compilation started"
  | Some (frame, error_point, cdir) ->      
      if frame.frm_killed 
      then Frame.unkill (Multi_frames.cut_frame top_frame) frame;

      let (buf, text, point) = Frame.buf_text_point frame in
      let find_error = find_error_of_buf buf in
      try
        let error = find_error text error_point in
        Text.set_position text frame.frm_start error.err_msg;
        Text.set_position text point error.err_msg;
        frame.frm_force_start <- true;
        frame.frm_redraw <- true;
        if error.err_filename <> "" then
          let filename = 
            if error.err_filename =~ "^/"
            then error.err_filename
            else Filename.concat cdir error.err_filename 
          in
          let buf = Ebuffer.read filename (Keymap.create ()) in
          (* new frame for error buffer *)
          let frame = 
            try Frame.find_buffer_frame buf 
            with Not_found ->
                if Common.phys_equal frame top_frame then
                  let new_window = Top_window.create ()
                      (*Window.display top_window*) 
                  in
                  Frame.create new_window.window None buf
                else
                  Frame.create top_frame.frm_window None buf
          in
          let text = buf.buf_text in
          let point = frame.frm_point in
          Text.point_to_line text point error.err_line;
          Text.fmove text point error.err_begin;
          Frame.active frame
      with Not_found ->
        Message.message top_frame "No more errors"
[@@interactive]
@

\section{Efuns server and client}

% dual of previous sections in some sense since this time
% it's external commands that calls efuns instead of efuns
% calling external commands.

\subsection{The server}

<<constant [[Server.user]]>>=
let user = 
  try Sys.getenv "USER" 
  with _ -> "noname"
@

<<constant [[Server.socket_name]]>>=
let socket_name = 
  (Printf.sprintf "/tmp/efuns-server.%s.%s:0" user !Globals.displayname)
@

<<constant [[Server.started]]>>=
let started = ref false
@

<<type [[Server.proto]]>>=
type command =
  | LoadFile of string (* filename *) * int (* pos *) * int (* line *) * string
@

<<function [[Server.read_command]]>>=
let read_command fd =
  let inc = in_channel_of_descr fd in
  try
    let cmd = input_value inc in
    match cmd with
    | LoadFile (name, pos, line, str) ->
        let window = 
            let edt = Globals.editor () in
            match edt.top_windows with
            | [] -> failwith "no top windows"
            | x::_ -> x.top_active_frame.frm_window
        in
        let frame = Frame.load_file window name in
        let (_, text, point) = Frame.buf_text_point frame in
        if pos <> 0 
        then Text.set_position text point pos;
        if line <> 0 
        then Text.goto_line text point line;
        if str <> ""
        (* bugfix: need the begin/end here, otherwise update below in then *)
        then begin                 
          let regexp = Str.regexp_string str in
          Text.search_forward text regexp point |> ignore;
        end;
        Top_window.update_display () 
  with
    _ -> Concur.remove_reader fd 
@
%pad: I pass now a frame_opt, so can also pass None and get top_window
% from Globals.editors, which allow then to call Server.start from pad.ml
% when there is no frame yet.
%old: wrap top_window ...

<<function [[Server.module_accept]]>>=
let module_accept s = 
  let fd,_ = accept s in
  Unix.set_close_on_exec fd;
  Concur.add_reader fd (fun _ -> read_command fd)
@

<<function [[Server.start]]>>=
(* old: this used to take an optional frame but was useless I think *)
let start () =
  if not !started then
  Utils.catchexn "Efuns server:" (fun _ ->
      let s = Unix.socket PF_UNIX SOCK_STREAM 0 in

      if Sys.file_exists socket_name 
      then begin 
        UCommon.pr2 (spf "socket file %s already exists; cancelling the server"
              socket_name);
        (* alt: unlink here, so if you run multiple efuns, the last one wins*)
      end else begin
        Unix.bind s (ADDR_UNIX socket_name);
        Unix.listen s 254;
        Unix.set_nonblock s;
        Unix.set_close_on_exec s;
        Concur.add_reader s (fun _ -> 
          started := true;
          module_accept s
        );
       Hooks.add_hook Misc_features.exit_hooks (fun () -> Unix.unlink socket_name);
      end
  )  
@
%old:
% <<misc actions>>=
% define_action "start_server" Server.start;
% @
% <<[[interactives_map]] initial entries>>=
% "start_server";
% @

%alt: we could put a @@interactive "start_server" here, or rename
% the function. This shows one pro for having an explicit 
% interactive call separate from the action (but very very small pro)

%old:
%     let top_window = Window.top frame.frm_window in
%     let display = top_window.top_root#display  in
%     ...
%      let atom = X.internAtom display efuns_property false in
%      X.changeProperty display top_window.top_root#window 
%        PropModeReplace atom XA.xa_string 1 socket_name;

\subsection{The client: [[efuns_client]]}


<<constant [[Efuns_client.pos]]>>=
let pos = ref 0
@

<<constant [[Efuns_client.string]]>>=
let string = ref ""
@

<<constant [[Efuns_client.filename]]>>=
let filename = ref None
@

<<toplevel [[Efuns_client._1]]>>=
let _ = Arg.parse [
    "-pos", Arg.Int (fun i -> pos := i)," <int>: set position";
    "-line", Arg.Int (fun i -> line := i)," <int>: set line";
    "-str", Arg.String (fun s -> string := s)," <string>: search string";
  ] (fun name -> filename := Some name)
  "efuns_server: connect to efuns"
@

<<constant [[Efuns_client.pos]]([[(client/efuns_client.ml)]])>>=
let pos = !pos    
@

<<constant [[Efuns_client.filename]]([[(client/efuns_client.ml)]])>>=
let filename = match !filename with
    None -> failwith "efuns_server: filename missing"
  | Some s -> s
@

<<constant [[Efuns_client.string]]([[(client/efuns_client.ml)]])>>=
let string = !string
@

<<constant [[Efuns_client.filename]] ([[client/efuns_client.ml]])2>>=
let filename = 
  if Filename.is_relative filename 
  then Filename.concat (Sys.getcwd ()) filename 
  else filename
@


<<constant [[Efuns_client.display]]>>=
let display = 
  ""
  (*Xlib.openDisplay "" *)
@

<<constant [[Efuns_client.socket_name]]>>=
let user = 
  try Sys.getenv "USER" 
  with _ -> "noname"

let socket_name = 
  (Printf.sprintf "/tmp/efuns-server.%s.%s:0" user display)
  (* (Xlib.getWholeProperty display root atom).gp_value *)
@

<<toplevel [[Efuns_client._2]]>>=
let _ =  if not (Sys.file_exists socket_name) then raise Not_found
@


<<toplevel [[Efuns_client._3]]>>=
let (_inc,outc) = Unix.open_connection (Unix.ADDR_UNIX socket_name)
let _ =  
  output_value outc (Server.LoadFile (filename,pos,!line, string)); 
  flush outc
@


\section{[[M-x eval]]}

% <<constant [[Complex.eval_history]]>>=
% let eval_history = ref []
% @
% 
% <<function [[Complex.eval]]>>=
% let eval frame =
%   Select.select_string frame "Eval:" eval_history "" (fun str ->
%     let top_window = Window.top frame.frm_window in
%     (* This is not enough: the paths also may have changed. *)
%     Top_window.message top_window 
%       (*(Dyneval.eval 
%         (let len = String.length str in
%         if str.[len - 1] = ';' && str.[len -2 ] = ';' then str else
%         str ^ " ;;"))
%       *)(failwith "Complex.eval???")
%     )
% @
%old:
% <<meta actions>>=
% define_action "eval" Complexe.eval;  
% @
% <<[[interactives_map]] initial entries>>=
% "eval";  
% @


\section{Completion}

%Expansion des abbreviations: 
%deux fonctions principales: 
%- "dabbrev_expand": expansion des mots a partir de mots trouves dans les
%     buffers (binding normap "M-/").
%- "expand_sabbrev": expansion des mots a partir d'abbreviations trouvees
%    dans des tables associees au buffer (variable "abbrev_table") 
%    (binding normal: un caractere de fin de mot (espace,newline,..))

<<misc keys>>=
[NormalMap, Char.code ' '], Abbrevs.char_expand_abbrev;
[MetaMap, Char.code '/'], Abbrevs.dabbrev_expand;
@

%old:
% <<toplevel [[Abbrevs._1]]>>=
% let _ =
%   Action.define_action "char_expand_abbrev" (fun frame ->
%       expand_sabbrev frame; 
%       Simple.self_insert_command frame
%   );
%   Action.define_action "dabbrev_expand" dabbrev_expand;
%   ()
% @

<<function [[Abbrevs.expand_sabbrev]]>>=
let expand_sabbrev frame =
  try
    let (buf, text, point) = Frame.buf_text_point frame in
    let abbrevs = Var.get_local buf abbrev_table in
    let str =
      Text.with_dup_point text point (fun mark ->
        Move.to_begin_of_word text point buf.buf_syntax_table;
        Text.region text point mark 
      )
    in
    let len = String.length str in
    try
      let repl = Hashtbl.find abbrevs str in
      Text.delete text point len;
      Text.insert text point repl;
      Text.fmove text point (String.length repl); ()
    with
      Not_found -> Text.fmove text point len; ()
  with _ -> ()
@

<<function [[Abbrevs.dabbrev_expand]]>>=
let dabbrev_expand frame = 
  let (buf, text, point) = Frame.buf_text_point frame in
  let syntax = buf.buf_syntax_table in
  let loop = ref false in
  let s, buf, pos, history =
    match !dabbrev_buf with
      Some (s, for_frame, for_position, for_len,buf, pos, history) 
      when frame == for_frame && for_position = Text.get_position text point ->
        Text.bmove text point for_len;
        Text.delete text point for_len;
        s, buf, pos, history
    | _ -> 
        let str = Move.beginning_of_word buf point in
        str , buf, 
        Text.get_position text point - String.length str, []
  in
  let truelen = String.length s in
  let s = escaped s in
  Text.bmove text point truelen;
  let regexp = Str.regexp s in
  let rec iter curr_buf pos =
    let curr_text = curr_buf.buf_text in
    Text.with_new_point curr_text (fun mark ->
      Text.set_position curr_text mark pos;
      try
        let rec restart () =
          let _len = Text.search_backward curr_text regexp mark in
          if curr_text == text && mark = point then
            raise Exit
          else
            if Text.bmove_res curr_text mark 1 <> 0 then
              if syntax.(Char.code (Text.get_char curr_text mark)) 
              then begin Text.fmove curr_text mark 1; restart () end
              else Text.fmove curr_text mark 1
            else
              ()
        in
        let rec first () =
          restart ();
          Text.fmove curr_text mark truelen;
          let m = Move.end_of_word curr_buf mark in
          if List.mem m history then begin
            Text.bmove curr_text mark truelen; 
            first ()
          end else begin
            Text.fmove text point truelen;
            let _,len = Text.insert_res text point m in
            Text.fmove text point len;
            dabbrev_buf := Some (s, frame, Text.get_position text point, len, 
              curr_buf, Text.get_position curr_text mark, m :: history);
          end
        in
        first ()
      with 
      | Not_found ->
          let curr_buf = Multi_buffers.next_buffer curr_buf in
          if curr_buf == buf 
          then
            if !loop 
            then raise Not_found
            else loop := true (* to avoid infinite loop *)
          ;
          iter curr_buf (Text.size curr_buf.buf_text) 
      | Exit ->
          Text.fmove text point truelen;
          dabbrev_buf := None;
          raise Not_found
     )
  in
  iter buf pos; ()
[@@interactive]
@

<<function [[Simple.next_buffer]]>>=
(* useful when want to iterate over all buffers, e.g. in dabbrev_expand *)
let next_buffer buf =
  let buf_list = Utils.list_of_hash (Globals.editor()).edt_buffers in
  let rec iter list =
    match list with
      [] -> raise Not_found 
    | (_name,b) :: tail ->
        if b == buf 
        then 
          match tail with
          | [] -> snd (List.hd buf_list) (* go back to head *)
          | (_,b)::_ -> b
        else
          iter tail
  in
  iter buf_list
@


<<constant [[Abbrevs.dabbrev_buf]]>>=
let dabbrev_buf = ref None
@

<<constant [[Abbrevs.abbrev_table]]>>=
let abbrev_table = Store.create "abbrev_table" 
    (fun table ->
      let s = ref "" in 
      Hashtbl.iter (fun s1 s2 ->
          s := Printf.sprintf "%s%s --> %s\n" !s s1 s2
      ) table;
      !s
  )
  Store.no_input
@

<<function [[Abbrevs.escaped]]>>=
let escaped s =
  let n = ref 0 in
  let len = String.length s in
  for i = 0 to len - 1 do
    let c = String.get s i in
    match c with
      '\\' | '[' | ']' | '^' -> incr n
    | _ -> ()
  done;
  if !n = 0 then s else
  let ss = Bytes.create (len + !n) in
  let p = ref 0 in
  for i = 0 to len - 1 do
    let c = String.get s i in
    (match c with
        '\\' | '[' | ']' | '^' -> 
          Bytes.set ss !p '\\';
          incr p
      | _ -> ());
    Bytes.set ss !p c;
    incr p    
  done;
  Bytes.to_string ss
@

\section{Colored filenames}
% and directories
% dircolors.ml

\section{Transforming}
% maybe move in extra features?

<<transforming keys>>=
[ControlMap, Char.code 't'], (Frame.to_frame Edit.transpose_chars);
[MetaMap, Char.code 't'], (Frame.to_frame Edit.transpose_words);

[MetaMap, Char.code 'l'], (fun frm ->
  Edit.on_word frm.frm_buffer frm.frm_point String.lowercase_ascii
);
[MetaMap, Char.code 'u'], (fun frm ->
  Edit.on_word frm.frm_buffer frm.frm_point String.uppercase_ascii
);
[MetaMap, Char.code 'c'], (fun frm ->
  Edit.on_word frm.frm_buffer frm.frm_point String.capitalize_ascii
);
[MetaMap, XK.xk_q], Transform.fill_paragraph;
@

%old:
% <<transforming actions>>=
% define_action "transpose_chars"  (Frame.to_frame Simple.transpose_chars);
% define_action "transpose_words"  (Frame.to_frame Simple.transpose_words);
% 
% define_action "lowercase_word" (fun frame ->
%   Simple.on_word frame.frm_buffer frame.frm_point String.lowercase
% );
% define_action "uppercase_word" (fun frame ->
%   Simple.on_word frame.frm_buffer frame.frm_point String.uppercase
% );
% define_action "capitalize_word" (fun frame ->
%   Simple.on_word frame.frm_buffer frame.frm_point String.capitalize
% );
% 
% define_action "fill_paragraph" Simple.fill_paragraph;
% @

\subsection{Characters}

% exchange
<<function [[Simple.transpose_chars]]>>=
let transpose_chars buf point =
  let text = buf.buf_text in
  text |> Text.with_session (fun () ->
    Text.bmove text point 1;
    let _pos, c1 = Text.delete_res text point 1 in
    Text.fmove text point 1;
    Text.insert text point c1;
  );
  Text.fmove text point 1;
  ()
@

\subsection{Words}
%\subsection{Case changing}

<<function [[Simple.transpose_words]]>>=
let transpose_words buf point =
  let text = buf.buf_text in
  text |> Text.with_session (fun () ->
    let syntax = buf.buf_syntax_table in
    in_prev_word text point syntax;
    to_begin_of_word text point syntax;
    Text.with_dup_point text point (fun pos1 ->
      to_end_of_word text point syntax;
      let _,word1 = Text.delete_res text pos1 (Text.distance text pos1 point) in
      Text.goto_point text point pos1;
      in_next_word text point syntax;
      Text.with_dup_point text point (fun pos2 ->
        to_end_of_word text point syntax;
        let _,word2 = Text.delete_res text pos2 (Text.distance text pos2 point) in    
        Text.insert text pos1 word2;
        Text.insert text pos2 word1;
        Text.fmove text point (String.length word1);
  )))
@

% for uppercase/lowercase
<<function [[Simple.on_word]]>>=
let on_word buf point f =
  let text = buf.buf_text in
  text |> Text.with_session (fun () ->
    let syntax = buf.buf_syntax_table in
    to_begin_of_word text point syntax;
    Text.with_dup_point text point (fun pos1 ->
      to_end_of_word text point syntax;
      let _,word1 = Text.delete_res text pos1 (Text.distance text pos1 point) in
      let w = f word1 in
      Text.insert text pos1 w;
      Text.fmove text point (String.length w);
    )
  )
@

\subsection{Filling}

%less: mv to fill_mode.ml?

<<constant [[Simple.line_comment]]>>=
let line_comment = Store.create_abstr "Fill_mode.line_comment"
@
% dead?

<<function [[Simple.fill_paragraph]]>>=
(* We will have to modify this to handle line_comment soon !! *)
let fill_paragraph frame =
  let (buf, text, point) = Frame.buf_text_point frame in
  text |> Text.with_session (fun () ->
    Text.with_dup_point text point (fun start ->
    Move.backward_paragraph buf start;
    Text.with_dup_point text start (fun fin ->
      Move.forward_paragraph buf fin;

      simplify text start fin;
      Text.insert text start "\n";
      let rec iter count last_space =
        if Text.compare text start fin < 0 then
        if Text.fmove_res text start 1 =|= 1 then 
          let c = Text.get_char text start in  
            if c =$= ' ' then (* good, a new space *)
              iter (count+1) 0
          else
          if count > 75 && count <> last_space then 
              begin
              Text.bmove text start (last_space+1);
              Text.delete text start 1;
              Text.insert text start "\n";
              Text.fmove text start 1;
              iter 0 0
              end
            else
              iter (count+1) (last_space+1)
      in
      iter 0 0;  
      Text.insert text fin "\n";
  )))
[@@interactive]
@

<<function [[Simple.simplify]]>>=
let simplify text start point =
  Text.with_dup_point text start (fun start ->
    let rec iter last_c =
      if start < point then
        let c = Text.get_char text start in
        if c =$= ' ' || c =$= '\n' || c =$= '\t' then
          ( Text.delete text start 1;
            iter ' ')
        else
        if last_c =$= ' ' then
          ( Text.insert text start " ";
            Text.fmove text start 2;
            iter 'a')
        else
          ( Text.fmove text start 1;
            iter 'a')
    in
    iter 'a'
  )
@


\section{Misc}

\subsection{Electric}

% for fill_mode
<<function [[Simple.electric_insert_space]]>>=
let electric_insert_space frame =
  Edit.self_insert_command frame;
  let (buf, text, point) = Frame.buf_text_point frame in
  let line_len = Text.point_to_bol text point in
  if line_len > 75 then
    Text.with_dup_point text point (fun mark ->
      try
        while (Move.backward_word buf mark;
            Text.point_to_bol text mark > 75) do () done;
        Move.forward_word buf mark; 
        Move.backward_word buf mark;
        Text.insert text mark "\n"
      with Not_found -> ()
    )
@

\subsection{Hungry}
% advanced topic?

<<deleting keys>>=
(* ?? *)
[ControlMap, XK.xk_BackSpace], Electric.hungry_electric_delete;
@
%old:
% <<deleting actions>>=
% define_action "hungry_electric_delete"  Simple.hungry_electric_delete;
% @


<<function [[Simple.hungry_char]]>>=
let hungry_char c = 
  c = ' ' || c = '\n' || c = '\t'
@

% seems similar to M-backspace

% C-backspace
<<function [[Simple.hungry_electric_delete]]>>=
let hungry_electric_delete frame =
  let (_, text, _) = Frame.buf_text_point frame in
  text |> Text.with_session (fun () ->
   let c1 = previous_char frame in
   Edit.delete_backspace_char frame;
   let c2 = previous_char frame in
   if hungry_char c1 && hungry_char c2 then
     try
       Edit.delete_backspace_char frame;
       while 
         let c = previous_char frame in
         hungry_char c        
       do
         Edit.delete_backspace_char frame
       done;
       Edit.insert_char frame ' '
     with Not_found -> ()
  )
[@@interactive]
@
% hungry and electric?

<<function [[Simple.previous_char]]>>=
let previous_char frame =
  let (_, text, point) = Frame.buf_text_point frame in
  if Text.bmove_res text point 1 = 0 then raise Not_found;
  let c = Text.get_char text point in
  Text.fmove text point 1;
  c
@


\subsection{Read-only}

% useful for instance for special major mode like 
% buffer_menu, completion, outline_mode, etc., where don't want 
% edition at all.

<<[[Text.t]] other fields>>=
mutable text_readonly : bool;
@

<<[[Text.low_insert()]] fail if readonly buffer>>=
if text.text_readonly 
then failwith "Buffer is read-only";
@


%getter
<<function [[Text.readonly]]>>=
let readonly text = 
  text.text_readonly
@
%setter
<<function [[Text.toggle_readonly]]>>=
let toggle_readonly text = 
  text.text_readonly <- not text.text_readonly
@


\chapter{Advanced Topics}

\section{Tabs}

% This should not exist I think. It complicates stuff.
% Which is why I put it in advanced topics.
% But maybe I should put it closer to the ^M representation stuff.

%(* for J.G. Malecki: tabs have a different representation depending
% * their position in the text (as in xterms) 
% *)

<<[[Ebuffer.create()]] adjust charreprs>>=
buf.buf_charreprs.(9) <- String.make !tab_size ' ';
@

<<constant [[Ebuffer.tab_size]]>>=
let tab_size = ref 9
@
% was 9, but really want 9?
%todo: should be a major mode variable

<<[[Text.compute_representation()]] compute charrepr, special char>>=
if charcode = 9 
then tabreprs.(!repr_cursor mod 9)
@
%todo: ! should use tab_size, so should pass it to compute_representation

<<[[Text.compute_representation()]] compute [[char_repr]], special char>>=
if char_code = 9 
then tabreprs.(!repr_cursor mod 9)
@

<<constant [[Text.tabreprs]]>>=
let tabreprs = [|
    "         ";
    "        ";
    "       ";
    "      ";
    "     ";
    "    ";
    "   ";
    "  ";
    " ";
    ""
  |]
@
% 8 columns tab!
% should be different if decide to have something different than
% 9 tab_size?


<<constant [[Minibuffer.charreprs]]>>=
let charreprs = Array.init 256 (fun i -> String.make 1 (Char.chr i))
@
<<toplevel [[Minibuffer._1]]>>=
let _ =
  charreprs.(9) <- String.make !Ebuffer.tab_size ' '
@




\section{Unicode}

% charreprs?

\section{Accents and AZERTY}

% Simple.toplevel for add_start_hook for azerty keys -> <>
<<function [[Simple.char_insert_command]]>>=
let char_insert_command char frame =
  let buf = frame.frm_buffer in
  <<[[Simple.self_insert_command()]] if overwrite mode>>
  else insert_char frame char
@
%less: could factorize code with self_insert_command

<<[[core_map]] entries>>=
([
(* see pbs_accent.txt in this directory
*)
] |> List.map (fun (key, char) ->
    (* special for AZERTY keyboards *)
        [NormalMap, key], (Edit.char_insert_command char)
    )
) @
@
%old:
%todo: implement accents!
%  Keymap.add_global_key editor [NormalMap, XK.xk_dead_circumflex]
%    "circumflex" (char_insert_command '^');

\section{Mini maps}

% Yeah!

\section{Signals}

<<exception [[Main.SigInt]]>>=
exception SigInt
@

<<[[main()]] set signal handlers>>=
Utils.register_exn (fun e ->
  match e with
  | Unix.Unix_error (error,f,arg) ->
      Printf.sprintf "Unix error %s: %s %s" f (Unix.error_message error) arg
  | _ -> raise e
);
Printexc.record_backtrace true;

Sys.signal Sys.sigint (Sys.Signal_handle (fun _ ->  
  (* Should auto-save all buffers, and then exit ... *)
  exit 1
)) |> ignore; 
Sys.signal Sys.sigterm (Sys.Signal_handle (fun _ ->  
  (* Should auto-save all buffers, and then exit ... *)
  raise SigInt
)) |> ignore;
Sys.signal Sys.sighup (Sys.Signal_handle (fun _ -> 
  raise SigInt
)) |> ignore;
@

\section{Dynamic linking}

<<[[main()]] command line options>>=
  "-I",Arg.String (fun s -> Globals.load_path =:= 
      (Utils.string_to_path s) @ !!Globals.load_path), "<path>: Load Path";
@
%dead? or for dynlink?

<<constant [[Efuns.load_path]]>>=
let load_path = define_option ["efuns_path"] 
  "<load_path> is the path where modules (.cmo and .cma) can be found
  for dynamic linking." path_option []
@

<<constant [[Efuns.path]]>>=
let path = (*Dyneval.load_path*) ref []
@

<<constant [[Efuns.efuns_path]]>>=
let efuns_path = [ 
      (Filename.concat Utils.homedir ".efuns") ;
(*
      Version.efuns_lib; 
      Version.installdir; 
      Version.ocamllib
*)
  ]
@

<<toplevel [[Efuns]] load path>>=
let _ = 
  path := !!load_path @ efuns_path;
  option_hook load_path (fun _ -> path := !!load_path @ efuns_path)
@

\section{Misc}

%\section{X11}

%<<constant [[Efuns.xdefaults]]>>=
%let xdefaults = try Sys.getenv "XUSERFILESEARCHPATH" with
%    Not_found -> Filename.concat Utils.homedir ".Xdefaults"
%@

% <<toplevel [[Efuns._2]]>>=
% let _ =
%   begin    
%     try
%       let efuns_res = 
%         let path = try Utils.string_to_path (Sys.getenv "XFILESEARCHPATH") with _ -> 
%               [] in
%         let xenv = try Sys.getenv "XENVIRONMENT" with _ -> "" in
%         let xroot = try Filename.concat  (Sys.getenv "X11ROOT")
%             "lib/X11/app-defaults/" with _ -> "" in
%         Utils.find_in_path (path@[
%             xenv; xroot; "/usr/X11/lib/X11/app-defaults/"]) "Efuns"
%       in
%       Xrm.safe_load x_res efuns_res
%     with _ -> ()
%   end;
%   Xrm.safe_load x_res xdefaults
% @

% <<constant [[Efuns.x_res]]>>=
% let x_res = Xrm.create ()
% @
% 
% <<constant [[Efuns.t]]>>=
% let t = x_res
% @




%\section{Multiple top windows}
% Called actually frame in emacs terminology, but confusing I think.
% I don't think this feature is very useful.

% This used to require also the display parameter passed around,
% but I've removed it for now.

% this is why have list top_window in location.top_windows.

%<<misc keys>>=
%<<window management keys>>
%@
%old:
% <<misc actions>>=
% <<window management actions>>
% @

%<<constant [[Keymap.n_5]]>>=
%let n_5 = (NormalMap, Char.code '5')
%@
%
%<<window management keys>>=
%(* less: delete *)
%[c_x; n_5; NormalMap, Char.code 'f'], Misc.window_load_buffer;
%[c_x; n_5; NormalMap, Char.code 'b'], Misc.window_change_buffer;
%[c_x; n_5; NormalMap, Char.code '0'], Top_window.delete_window;
%@
%old:
% <<window management actions>>=
% (* C-x 5 map *)
% define_action "window_load_buffer"  Complexe.window_load_buffer;
% (* C-x 5 map *)
% define_action "window_change_buffer"  Complexe.window_change_buffer;
% (* C-x 5 map *)
% define_action "delete_window"  Top_window.delete_window;
% @


%<<function [[Complex.window_load_buffer]]>>=
%let window_load_buffer frame = 
%  Select.select_file_from_pwd frame "Find file: " 
%    (fun str -> 
%      let top_window = Top_window.create ()
%          (Window.display top_window)
%      in
%      Frame.load_file top_window.window str |> ignore
%    )
%[@@interactive]
%@
%
%<<function [[Complex.window_change_buffer]]>>=
%let window_change_buffer frame =
%  Multi_buffers.select_buffer frame "Switch to buffer in new frame: " 
%    (Multi_buffers.get_previous_frame ())
%    (fun name ->
%      let top_window = Top_window.create ()
%      in
%      Frame.change_buffer top_window.window name
%  )
%[@@interactive]
%@
%
%<<function [[Top_window.delete_window]]>>=
%let delete_window frame =
%  let top_window = Window.top frame.frm_window in
%  let loc = Efuns.loc() in
%  if List.length loc.top_windows > 1 then
%    let xterm = Window.xterm top_window in
%    top_window.top_appli#destroy;
%    WX_xterm.destroy_window xterm;
%    Frame.kill_all top_window.window;
%    loc.top_windows <- Utils.list_remove loc.top_windows
%      top_window
%[@@interactive]
%@
%
%<<function [[Frame.kill_all]]>>=
%let kill_all window =
%  Window.iter kill window
%@
%
%
%<<constant [[Efuns.init_frames]]>>=
%let init_frames = ref []
%@
%<<[[main()]] command line options>>=
%  "-frame", Arg.String (fun s -> init_frames := s:: !init_frames), "<file>: open a frame with <file>";
%@





\chapter{Conclusion}








\appendix

\chapter{Error Management}

\section{Logging}

<<function [[Efuns.error]]>>=
let error_exn s exn =
  let bt = Printexc.get_backtrace () in
  (* less: this introduces a dependency to pfff, but allows for
   * better reporting. An alternative solution would be to register
   * exn handlers/formatters
   *)
  (match exn with 
  | Parsing_error.Lexical_error _ | Parsing_error.Syntax_error _ ->
     let ex = Exception.catch exn in
     (* TODO
     let err = Error_code.exception_to_error "XXX" ex in
     pr2 (Error_code.string_of_error err)
      *)
     UCommon.pr2 (Dumper.dump ex)
  | _ -> ()
  );
  UCommon.pr2 (spf "error: %s (exn = %s). backtrace:\n%s" 
        s (Common.exn_to_s exn) bt);
  flush stderr
@
% better to not mix print_xxx with printf, so let's use printf everywhere
%pad: this is actually now Globals.error


\section{[[*Messages*]]}

% ??? -> <>
<<function [[Ebuffer.message]]>>=
(* todo: vs Message.message? *)
let message _buf m =
  let name = "*Messages*" in
  try
    let buf = Hashtbl.find (Globals.editor()).edt_buffers name in
    Text.insert_at_end buf.buf_text (m^"\n");
  with Not_found ->
    create name None (Text.create (m^"\n")) (Keymap.create ()) |> ignore
@


\section{[[*backtrace*]]}

%there is a giant try somewhere?
% if do some failwith in the code, e.g. failwith "Buffer is read-only",
% then catched? and displayed nicely?
% yes!

<<[[Top_window.handle_key()]] handle exception of [[try_map]]>>=
| e -> 
    (* bugfix: call get_backtrace() first! otherwise the code above
     * may throw exn, which can be catched, which modifies the backtrace
     *)
    let bt = Printexc.get_backtrace () in
    let str = spf "Uncaught exception %s" (Utils.printexn e) in
    if !Globals.debug
    then UCommon.pr2 str;
    message top_window  str;
    let buf = Ebuffer.default "*backtrace*" in
    let text = buf.buf_text in
    Text.insert_at_end text str;
    Text.insert_at_end text "\n";
    Text.insert_at_end text bt;
    Text.insert_at_end text "\n"
@

% have seen lots of 
%  try xxx 
%  with exn ->
%    Globals.error "set_buffer_mode: exn = %s" (Common.exn_to_s exn);
%  before

\chapter{Debugging}

% can use ocamldebug! fantastic!

<<constants [[Efuns.debug_xxx]]>>=
let debug = ref false
let debug_graphics = ref false
let debug_display = ref false
let debug_init = ref false
@

%less: would be good to have a -debug_init so at least print out
% all those hooks that are run at startup time

<<[[main()]] command line options>>=
"-debug", Arg.Set Globals.debug, 
" for debugging";
"-debug_graphics", Arg.Set Globals.debug_graphics, 
" for debugging";
"-debug_display", Arg.Set Globals.debug_display, 
" for debugging";
"-debug_init", Arg.Set Globals.debug_init, 
" for debugging";

"-debugger", Arg.Unit (fun () ->
  Globals.debug := true;
), " for debugging";
@

\section{Actions trace: [[-debug]]}

<<[[Top_window.try_map()]] if debug, print action name>>=
if !Globals.debug
then begin
  let found = ref false in
  Action.actions |> Hashtbl.iter  (fun k v ->
    match v with
    (* subtle: this will work only if f2 was not a closure *)
    | FrameAction f2 when Common.phys_equal f f2 ->
        found := true;
        UCommon.pr2 (spf "action: %s" k)
    | _ -> ()
  );
  if not !found
  then UCommon.pr2 ("action not found");
end;
@
%alt: store the function name in FrameAction

\section{Graphics commands trace: [[-debug_graphics]]}

\chapter{Profiling}

\chapter{Heterogeneous [[Store]]}

% quite important when you want each mode to be able to store
% variables in the buffer, but each of those variables have
% different types. It's like you want a list of things or,
% an assoc, but each element value has a different type.
% Could do via Variant encapsulation, but annoying.
% Enters the heterogeneous map using phantom type tricks!

% Another cool thing is that you can use the same variable 
% to access element in different store (global store, major mode store, etc.)

%old: was called local.ml (why local?)

\section{Interface}

<<signature type [[Store.t]]>>=
type t
@
%old: was called vars

<<signature function [[Store.new_store]]>>=
(* constructor *)
val new_store : unit -> t
@
%old: was called vars

<<signature type [[Store.var]]>>=
type 'a var
@

<<signature function [[Store.get]]>>=
val get : t -> 'a var -> 'a
@
%subtle:
%  phantom type!

<<signature function [[Store.set]]>>=
val set : t -> 'a var -> 'a -> unit
@

<<signature functions [[Store.create_xxx]]>>=
val create_int : string -> int var
val create_string : string -> string var
val create_float : string -> float var
@

% let allvars = vars ()
% let myintvar = create_int "myint"
% let mystrvar = create_string "mystr"

% set allvars myintvar 2
% set allvars mystrvar "foo"

% let i = get allvars myintvar
% let s = get allvars mystrvar

\section{Implementation}

\subsection{[[vars]]}

<<type [[Store.t]]>>=
type t = (string, Obj.t ref) Vars.t ref
@

<<module Store.Vars>>=
module Vars = Map_
@
% Map string -> 'a


<<function [[Store.new_store]]>>=
let new_store () = 
  ref Vars.empty
@
%old: was called vars

\subsection{[[var]]}

<<type [[Store.var]]>>=
type 'a var = string
@
% phantom type!

% could be a gensym, but string is better for error messages?

<<function [[Store.create_int]]>>=
let create_int name = 
  create name string_of_int int_of_string
@

<<function [[Store.create_float]]>>=
let create_float name = 
  create name string_of_float float_of_string
@

<<function [[Store.create_string]]>>=
let create_string name = 
  create name id id
@


<<global [[Store.vars_table]]>>=
let (vars_table :
    (string, (Obj.t -> string) * (string -> Obj.t)) Hashtbl.t)
  = Hashtbl.create 203
@
% global to all vars! can't have the same key in different
%   table but with different type!
% could be a gensym with int for the key.

<<signature function [[Store.create]]>>=
val create : string -> ('a -> string) -> (string -> 'a) -> 'a var
@

<<function [[Store.create]]>>=
let create name print input =
  try
    let _ = Hashtbl.find vars_table name in
    failwith (Printf.sprintf "A variable named %s already exists" name)
  with
    Not_found ->
      Hashtbl.add vars_table name (Obj.magic print, Obj.magic input);
      name
@


<<signature functions [[Store.create_xxx]]>>=
val create_abstr : string -> 'a var
@

<<function [[Store.create_abstr]]>>=
let create_abstr name = 
  create name no_print no_input
@

<<function [[Store.no_print]]>>=
let no_print x = 
  "<abstr>:" ^ (Dumper.dump x)
@
<<function [[Store.no_input]]>>=
let no_input (_s : string) = failwith "This variable can not be set"
@
% ???

\subsection{Getter/setter}

<<function [[Store.get]]>>=
let get vars var =  
  Obj.magic !(Vars.find var !vars)
@

<<function [[Store.set]]>>=
let set vars var value =
  let value = Obj.repr value in
  try
    let r = Vars.find var !vars in
    r := value
  with
    Not_found -> 
      vars := Vars.add var (ref value) !vars
@

\subsection{Misc}

<<signature functions [[Store]]>>=
val no_input : string -> 'a
val no_print : 'a -> string

val set_input : t -> 'a var -> string -> unit
val get_print : t -> 'a var -> string
val list : t -> string list

val print : t -> string -> string
val input : t -> string -> string -> unit
@

<<function [[Store.get_print]]>>=
let get_print vars var =
  let value = get vars var in
  let (p, _i) = Hashtbl.find vars_table var in
  p value  
@

<<function [[Store.set_input]]>>=
let set_input vars var value =
  let (_p, i) = Hashtbl.find vars_table var in
  set vars var (i value)
@

<<function [[Store.list]]>>=
let list vars =
  let list = ref [] in
  Vars.iter (fun var _value ->
      list := var :: !list;
  ) !vars;
  !list
@

<<constant [[Store.print]]>>=
let print = get_print
@

<<constant [[Store.input]]>>=
let input = set_input
@


\chapter{Configuration File}

% options.ml
% quite important again, you want the editor to be customizable!
% Could be a chapter before? Configurability?
% And again it's typed configuration options!
% The schema/types are defined in the .ml, the config file stores
% the values.

\section{[[Options]]}

% define_option


\section{[[Parameter]]}

% interface
<<[[Config._5]] start hooks options>>=
Parameter.add_option_parameter Compil.compile_find_makefile;
Parameter.add_option_parameter Text.add_amount;
@


<<type [[Simple.parameter]]>>=
type t = 
 string * ((string -> Obj.t) * (Obj.t -> string) * Obj.t Options.t)
@

<<constant [[Simple.parameters_var]]>>=
let parameters_var = Store.create_abstr "parameters"
@




<<function [[Simple.add_option_parameter]]>>=
let add_option_parameter option =
  add_parameter (shortname option)
   (fun s -> from_value (get_type option) (Value s))
   (fun v -> 
      match to_value (get_type option) v with
        Value s -> s
      | _ -> failwith "Unable to print option"
    ) 
    option
@

<<function [[Simple.add_parameter]]>>=
let add_parameter (name : string) (input : string -> 'a) 
  (print : 'a -> string) (param : 'a Options.t) =
  let (input : string -> Obj.t) = Obj.magic input in
  let (print : Obj.t -> string) = Obj.magic print in
  let (param : Obj.t Options.t) = Obj.magic param in
  Var.set_global parameters_var (
    (name, (input, print, param)) :: 
    (try Var.get_global parameters_var with _ -> []))
@



<<constant [[Simple.all_params]]>>=
let all_params = ref None
@

<<function [[Simple.all_parameters]]>>=
let all_parameters _frame _ =
  let parameters = 
    try Var.get_global parameters_var with _ -> []
  in
  match !all_params with
    Some (f,l) when f == parameters -> l
  | _ ->
      let list = List.map fst parameters in
      all_params := Some (parameters, list);
      list
@


<<constant [[Complex.parameters_hist]]>>=
let parameters_hist = ref []
@

<<function [[Complex.set_parameter]]>>=
let set_parameter frame = 
  let parameters = Var.get_global Parameter.parameters_var in
  Select.select frame "set-parameter : " parameters_hist
    "" (Parameter.all_parameters frame) (fun s -> s) (fun variable ->
      Select.select_string frame (Printf.sprintf "%s : " variable)
      value_hist "" (fun value ->
          let (input,_print,param) = List.assoc variable parameters
          in
          param =:= input value))
[@@interactive]
@
%old:
% <<toplevel [[Complex._1]]>>=
% let _ =
%   Hook.add_start_hook (fun () ->
%     let edt = Globals.editor() in
%       Keymap.add_interactive edt.edt_map "set_local_variable" 
%         Interactive.set_local_variable;
%       Keymap.add_interactive edt.edt_map "set_global_variable" 
%         Interactive.set_global_variable;
%       Keymap.add_interactive edt.edt_map "set_parameter" set_parameter;
%       Keymap.add_interactive edt.edt_map "get_parameter" get_parameter;
%   )
% @

<<function [[Complex.get_parameter]]>>=
let get_parameter frame =
  let parameters = Var.get_global Parameter.parameters_var in  
  Select.select frame "get-parameter : " parameters_hist
    "" (Parameter.all_parameters frame) (fun s -> s) (fun variable ->
      Top_window.mini_message frame 
        (Printf.sprintf "%s : %s" variable (
          let (_input,print,param) = List.assoc variable parameters
          in
          print !!param)))
[@@interactive]
@




\chapter{Major Mode Examples}

%editor package systems:
% https://elpa.gnu.org/packages/
% https://atom.io/packages
% https://github.com/sublimehq/Packages
% vscode marketplace (very nice, reviews, rank, icons, screenshots)

% not here:
%  - makefile
%  - ocaml toplevel
% via ocamllex:
%  - html
%  - C
%  - ocaml
%  - tex

%old:
% <<[[interactives_map]] initial entries>>=
% "makefile_mode";
% "ocaml_mode";
% "c_mode";
% "tex_mode";
% @


\section{Shell mode}

\section{Buffers menu}

\section{Dired}

%\chapter{Major Language Modes Examples}
\section{Lisp mode}

<<function [[Text.lexing]]>>=
let lexing text curseur end_point =
  clean_text text;
  Lexing.from_function (fun str len ->
    let len = min len (distance text curseur end_point) in
    let len = blit str text curseur len in
    fmove text curseur len;
    len
  )
@

\chapter{Minor Mode Examples}

%old:
% <<[[interactives_map]] initial entries>>=
% "paren_mode";
% "abbrevs_mode";
% "fill_mode";
% 
% "tab_mode";
% (*"accents_mode";*)
% "ocaml_minor_mode";
% "merlin_mode";
% (*"ocaml_compiler_mode";*)
% @


\section{Abbrevs}

\section{Paren}
% useful! edwin power!
% right now it's only working when you activated the minor mode,
% and when you type a closing paren.

% note that when I did not have it, I really missed it!

<<constant [[Paren_mode.mode]]>>=
let mode = Ebuffer.new_minor_mode "paren" []
@

<<function [[Paren_mode.find_matching]]>>=
let find_matching frame = 
  Edit.self_insert_command frame; 
  highlight_paren frame
@

<<toplevel [[Paren_mode._1]]>>=
let _ = 
  (* alt: we could use a major mode var that specifies what is a parenthesis *)
  [')'; '}'; ']'] |> List.iter (fun key -> 
    Keymap.add_minor_key mode [NormalMap, Char.code key] find_matching
  )
@

%todo: do also a show_paren mode? so when hover paren it highlights the
% matching one

<<function [[Paren_mode.paren_mode]]>>=
let paren_mode = 
  Minor_modes.toggle_minor mode
[@@interactive]
@



<<function [[Simple.is_paren_end]]>>=
let is_paren_end c = (c == '}') || (c == ']') || (c == ')')
  <<[[Simple.is_paren_end()]] extra conditions>>
@

<<function [[Simple.is_paren_begin]]>>=
let is_paren_begin c = (c == '{') || (c == '[') || (c == '(')
  <<[[Simple.is_paren_begin()]] extra conditions>>

@



% Paren_mode.find_matching | Abbrevs_mode.find_matching -> <>
<<function [[Simple.highlight_paren]]>>=
let highlight_paren frame =
  let (buf, text, point) = Frame.buf_text_point frame in

  <<[[Simple.highlight_paren()]] special code for HTML modes>>

  (* bugfix: I was using Text.with_dup_point but we must store cursor
   * in highlighted_chars, which then was causing some out_of_bound exn
   * when exciting efuns, and also some weird display bugs,
   * because remove_point was putting some -1 in cursor!
   *)
  let cursor = Text.dup_point text point in
  try
    (* no previous char (this should never happen when called from
     * find_matching) *)
    if Text.bmove_res text cursor 1 = 0 
    then raise Exit;
  
    let c = Text.get_char text cursor in
    (* right now we highlight only when you type a closing paren *)
    if not (is_paren_end c) 
    then raise Exit;
  
    let rec iter stack =
      if Text.bmove_res text cursor 1 = 0 
      then begin 
        Top_window.mini_message frame "No matching parenthesis";
        raise Exit
      end;
  
      let d = Text.get_char text cursor in
      if is_paren_end d 
      then iter (d :: stack)
      else
        if is_paren_begin d 
        then
          match stack with
          | [] -> (* found matching par *)
            let attr = Text.get_attr text cursor in
            <<[[Simple.highlight_paren()]] remember highlighted chars>>
            Text.set_attr text cursor (attr lor Text.highlight_bit);
            buf.buf_modified <- buf.buf_modified + 1
          | _c :: stack -> (* don't try to match *)
            (* we could check they are matching chars (like '{' with '}') *)
            iter stack
        else iter stack
    in
    iter []
  with Exit ->
   Text.remove_point text cursor
@




\ifallcode
<<[[Simple.is_paren_end()]] extra conditions>>=
  ||  (!htmlp && c == '>')
@
<<[[Simple.is_paren_begin()]] extra conditions>>=
  ||  (!htmlp && c == '<')
@
<<constant [[Simple.htmlp]]>>=
let htmlp = ref false
@
<<[[Simple.highlight_paren()]] special code for HTML modes>>=
htmlp := (!Top_window.keypressed = Char.code '>');
@
\fi

\section{Fill}

%\section{Accents}

\section{Overwrite mode}

<<constant [[Simple.overwrite_mode]]>>=
let overwrite_mode = Ebuffer.new_minor_mode "Over" []
@

<<misc keys>>=
[NormalMap, XK.xk_Insert], Edit.toggle_overwrite_mode;
@


<<function [[Edit.toggle_overwrite_mode]]>>=
let toggle_overwrite_mode frm =
  let buf = frm.frm_buffer in
  let mode = overwrite_mode in
  if Ebuffer.has_minor_mode buf mode 
  then Ebuffer.del_minor_mode buf mode
  else Ebuffer.set_minor_mode buf mode
[@@interactive "overwrite_mode"]
@
%old:
% <<[[interactives_map]] initial entries>>=
% "overwrite_mode";
% @


<<[[Simple.self_insert_command()]] if overwrite mode>>=
if Ebuffer.has_minor_mode buf overwrite_mode 
then insert_at_place frame char
@

<<function [[Simple.insert_at_place]]>>=
let insert_at_place frame char =
  let (_, text, point) = Frame.buf_text_point frame in
  let c = Text.get_char text point in
  if c = '\n' 
  then insert_char frame char
  else begin
    Text.delete text point 1;
    Bytes.set single_char 0 char;    
    Text.insert text point (Bytes.to_string single_char);
    Text.fmove text point 1
  end
@
%old:  let _sessionTODOBUG = Text.start_session text in



\chapter{Extra Code}

%TODO: got "Counter too large" error without the \ifallcode
\ifallcode
#include "Editor_extra.nw"
\fi

%\chapter{Changelog}
%\label{sec:changelog}

\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
BOL  = Beginning Of Line
EOL  = End Of Line
BOF  = Beginning Of File
EOF  = End Of File
LOF  = ??
LOL  = ??
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Indexes}

%src: wc.nw in noweb source
Here is a list of the identifiers used, and where they appear.
Underlined entries indicate the place of definition.
This index is generated automatically.

\l \twocolumn does not work yet for the index
\nowebindex

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}
\bibliography{principia-latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
